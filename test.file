/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

;export  type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Word
 * 
 */
;export  type Word = $Result.DefaultSelection<Prisma.$WordPayload>
/**
 * Model Meaning
 * 
 */
;export  type Meaning = $Result.DefaultSelection<Prisma.$MeaningPayload>
/**
 * Model Sentence
 * 
 */
;export  type Sentence = $Result.DefaultSelection<Prisma.$SentencePayload>
/**
 * Model User
 * 
 */
;export  type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UsersOnWords
 * 
 */
;export  type UsersOnWords = $Result.DefaultSelection<Prisma.$UsersOnWordsPayload>
/**
 * Model UsersOnMeanings
 * 
 */
;export  type UsersOnMeanings = $Result.DefaultSelection<Prisma.$UsersOnMeaningsPayload>
/**
 * Model WordList
 * 
 */
;export  type WordList = $Result.DefaultSelection<Prisma.$WordListPayload>
/**
 * Model WordsOnWordLists
 * 
 */
;export  type WordsOnWordLists = $Result.DefaultSelection<Prisma.$WordsOnWordListsPayload>
/**
 * Model UsersOnWordLists
 * 
 */
;export  type UsersOnWordLists = $Result.DefaultSelection<Prisma.$UsersOnWordListsPayload>

/**
 * Enums
 */
;export  namespace $Enums {
  ;export  const WordDefinitionSourceType: {
  DICTIONARY_API: 'DICTIONARY_API',
  OTHER: 'OTHER'
};

;export  type WordDefinitionSourceType = (typeof WordDefinitionSourceType)[keyof typeof WordDefinitionSourceType]


;export  const SentenceSourceType: {
  CHATGPT: 'CHATGPT',
  OTHER: 'OTHER'
};

;export  type SentenceSourceType = (typeof SentenceSourceType)[keyof typeof SentenceSourceType]


;export  const UserMeaningRelation: {
  IGNORE: 'IGNORE',
  LEARN: 'LEARN'
};

;export  type UserMeaningRelation = (typeof UserMeaningRelation)[keyof typeof UserMeaningRelation]

}

;export  type WordDefinitionSourceType = $Enums.WordDefinitionSourceType

;export  const WordDefinitionSourceType: typeof $Enums.WordDefinitionSourceType

;export  type SentenceSourceType = $Enums.SentenceSourceType

;export  const SentenceSourceType: typeof $Enums.SentenceSourceType

;export  type UserMeaningRelation = $Enums.UserMeaningRelation

;export  const UserMeaningRelation: typeof $Enums.UserMeaningRelation

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Words
 * const words = await prisma.word.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
;export  class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Words
   * const words = await prisma.word.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.word`: Exposes CRUD operations for the **Word** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Words
    * const words = await prisma.word.findMany()
    * ```
    */
  get word(): Prisma.WordDelegate<ExtArgs>;

  /**
   * `prisma.meaning`: Exposes CRUD operations for the **Meaning** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Meanings
    * const meanings = await prisma.meaning.findMany()
    * ```
    */
  get meaning(): Prisma.MeaningDelegate<ExtArgs>;

  /**
   * `prisma.sentence`: Exposes CRUD operations for the **Sentence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sentences
    * const sentences = await prisma.sentence.findMany()
    * ```
    */
  get sentence(): Prisma.SentenceDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.usersOnWords`: Exposes CRUD operations for the **UsersOnWords** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsersOnWords
    * const usersOnWords = await prisma.usersOnWords.findMany()
    * ```
    */
  get usersOnWords(): Prisma.UsersOnWordsDelegate<ExtArgs>;

  /**
   * `prisma.usersOnMeanings`: Exposes CRUD operations for the **UsersOnMeanings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsersOnMeanings
    * const usersOnMeanings = await prisma.usersOnMeanings.findMany()
    * ```
    */
  get usersOnMeanings(): Prisma.UsersOnMeaningsDelegate<ExtArgs>;

  /**
   * `prisma.wordList`: Exposes CRUD operations for the **WordList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WordLists
    * const wordLists = await prisma.wordList.findMany()
    * ```
    */
  get wordList(): Prisma.WordListDelegate<ExtArgs>;

  /**
   * `prisma.wordsOnWordLists`: Exposes CRUD operations for the **WordsOnWordLists** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WordsOnWordLists
    * const wordsOnWordLists = await prisma.wordsOnWordLists.findMany()
    * ```
    */
  get wordsOnWordLists(): Prisma.WordsOnWordListsDelegate<ExtArgs>;

  /**
   * `prisma.usersOnWordLists`: Exposes CRUD operations for the **UsersOnWordLists** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsersOnWordLists
    * const usersOnWordLists = await prisma.usersOnWordLists.findMany()
    * ```
    */
  get usersOnWordLists(): Prisma.UsersOnWordListsDelegate<ExtArgs>;
}

;export  namespace Prisma {
  ;export  import DMMF = runtime.DMMF

  ;export  type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  ;export  import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  ;export  import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  ;export  import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  ;export  import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  ;export  import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  ;export  import PrismaClientValidationError = runtime.PrismaClientValidationError
  ;export  import NotFoundError = runtime.NotFoundError

  /**
   * Re-;export  of sql-template-tag
   */
  ;export  import sql = runtime.sqltag
  ;export  import empty = runtime.empty
  ;export  import join = runtime.join
  ;export  import raw = runtime.raw
  ;export  import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  ;export  import Decimal = runtime.Decimal

  ;export  type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  ;export  type Metrics = runtime.Metrics
  ;export  type Metric<T> = runtime.Metric<T>
  ;export  type MetricHistogram = runtime.MetricHistogram
  ;export  type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  ;export  import Extension = $Extensions.UserArgs
  ;export  import getExtensionContext = runtime.Extensions.getExtensionContext
  ;export  import Args = $Public.Args
  ;export  import Payload = $Public.Payload
  ;export  import Result = $Public.Result
  ;export  import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.11.0
   * Query Engine version: efd2449663b3d73d637ea1fd226bafbcf45b3102
   */
  ;export  type PrismaVersion = {
    client: string
  }

  ;export  const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  ;export  type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  ;export  interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  ;export  type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  ;export  type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  ;export  interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  ;export  type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  ;export  const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  ;export  const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  ;export  const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  ;export  type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  ;export  type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  ;export  type Enumerable<T> = T | Array<T>;

  ;export  type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  ;export  type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  ;export  type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  ;export  type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  ;export  type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  ;export  type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  ;export  type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  ;export  type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  ;export  type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  ;export  type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  ;export  type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  ;export  type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  ;export  type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  ;export  type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  ;export  type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  ;export  type Boolean = True | False

  // /**
  // 1
  // */
  ;export  type True = 1

  /**
  0
  */
  ;export  type False = 0

  ;export  type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  ;export  type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  ;export  type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  ;export  type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  ;export  type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  ;export  const type: unique symbol;



  /**
   * Used by group by
   */

  ;export  type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  ;export  type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  ;export  const ModelName: {
    Word: 'Word',
    Meaning: 'Meaning',
    Sentence: 'Sentence',
    User: 'User',
    UsersOnWords: 'UsersOnWords',
    UsersOnMeanings: 'UsersOnMeanings',
    WordList: 'WordList',
    WordsOnWordLists: 'WordsOnWordLists',
    UsersOnWordLists: 'UsersOnWordLists'
  };

  ;export  type ModelName = (typeof ModelName)[keyof typeof ModelName]


  ;export  type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  ;export  type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'word' | 'meaning' | 'sentence' | 'user' | 'usersOnWords' | 'usersOnMeanings' | 'wordList' | 'wordsOnWordLists' | 'usersOnWordLists'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Word: {
        payload: Prisma.$WordPayload<ExtArgs>
        fields: Prisma.WordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WordFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WordFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WordPayload>
          }
          findFirst: {
            args: Prisma.WordFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WordFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WordPayload>
          }
          findMany: {
            args: Prisma.WordFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WordPayload>[]
          }
          create: {
            args: Prisma.WordCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WordPayload>
          }
          createMany: {
            args: Prisma.WordCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.WordDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WordPayload>
          }
          update: {
            args: Prisma.WordUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WordPayload>
          }
          deleteMany: {
            args: Prisma.WordDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.WordUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.WordUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WordPayload>
          }
          aggregate: {
            args: Prisma.WordAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWord>
          }
          groupBy: {
            args: Prisma.WordGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WordGroupByOutputType>[]
          }
          count: {
            args: Prisma.WordCountArgs<ExtArgs>,
            result: $Utils.Optional<WordCountAggregateOutputType> | number
          }
        }
      }
      Meaning: {
        payload: Prisma.$MeaningPayload<ExtArgs>
        fields: Prisma.MeaningFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MeaningFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MeaningPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MeaningFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MeaningPayload>
          }
          findFirst: {
            args: Prisma.MeaningFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MeaningPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MeaningFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MeaningPayload>
          }
          findMany: {
            args: Prisma.MeaningFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MeaningPayload>[]
          }
          create: {
            args: Prisma.MeaningCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MeaningPayload>
          }
          createMany: {
            args: Prisma.MeaningCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MeaningDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MeaningPayload>
          }
          update: {
            args: Prisma.MeaningUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MeaningPayload>
          }
          deleteMany: {
            args: Prisma.MeaningDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MeaningUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MeaningUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MeaningPayload>
          }
          aggregate: {
            args: Prisma.MeaningAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMeaning>
          }
          groupBy: {
            args: Prisma.MeaningGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MeaningGroupByOutputType>[]
          }
          count: {
            args: Prisma.MeaningCountArgs<ExtArgs>,
            result: $Utils.Optional<MeaningCountAggregateOutputType> | number
          }
        }
      }
      Sentence: {
        payload: Prisma.$SentencePayload<ExtArgs>
        fields: Prisma.SentenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SentenceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SentencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SentenceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SentencePayload>
          }
          findFirst: {
            args: Prisma.SentenceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SentencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SentenceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SentencePayload>
          }
          findMany: {
            args: Prisma.SentenceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SentencePayload>[]
          }
          create: {
            args: Prisma.SentenceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SentencePayload>
          }
          createMany: {
            args: Prisma.SentenceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SentenceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SentencePayload>
          }
          update: {
            args: Prisma.SentenceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SentencePayload>
          }
          deleteMany: {
            args: Prisma.SentenceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SentenceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SentenceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SentencePayload>
          }
          aggregate: {
            args: Prisma.SentenceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSentence>
          }
          groupBy: {
            args: Prisma.SentenceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SentenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.SentenceCountArgs<ExtArgs>,
            result: $Utils.Optional<SentenceCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UsersOnWords: {
        payload: Prisma.$UsersOnWordsPayload<ExtArgs>
        fields: Prisma.UsersOnWordsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsersOnWordsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersOnWordsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsersOnWordsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersOnWordsPayload>
          }
          findFirst: {
            args: Prisma.UsersOnWordsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersOnWordsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsersOnWordsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersOnWordsPayload>
          }
          findMany: {
            args: Prisma.UsersOnWordsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersOnWordsPayload>[]
          }
          create: {
            args: Prisma.UsersOnWordsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersOnWordsPayload>
          }
          createMany: {
            args: Prisma.UsersOnWordsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UsersOnWordsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersOnWordsPayload>
          }
          update: {
            args: Prisma.UsersOnWordsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersOnWordsPayload>
          }
          deleteMany: {
            args: Prisma.UsersOnWordsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UsersOnWordsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UsersOnWordsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersOnWordsPayload>
          }
          aggregate: {
            args: Prisma.UsersOnWordsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUsersOnWords>
          }
          groupBy: {
            args: Prisma.UsersOnWordsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UsersOnWordsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsersOnWordsCountArgs<ExtArgs>,
            result: $Utils.Optional<UsersOnWordsCountAggregateOutputType> | number
          }
        }
      }
      UsersOnMeanings: {
        payload: Prisma.$UsersOnMeaningsPayload<ExtArgs>
        fields: Prisma.UsersOnMeaningsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsersOnMeaningsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersOnMeaningsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsersOnMeaningsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersOnMeaningsPayload>
          }
          findFirst: {
            args: Prisma.UsersOnMeaningsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersOnMeaningsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsersOnMeaningsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersOnMeaningsPayload>
          }
          findMany: {
            args: Prisma.UsersOnMeaningsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersOnMeaningsPayload>[]
          }
          create: {
            args: Prisma.UsersOnMeaningsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersOnMeaningsPayload>
          }
          createMany: {
            args: Prisma.UsersOnMeaningsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UsersOnMeaningsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersOnMeaningsPayload>
          }
          update: {
            args: Prisma.UsersOnMeaningsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersOnMeaningsPayload>
          }
          deleteMany: {
            args: Prisma.UsersOnMeaningsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UsersOnMeaningsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UsersOnMeaningsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersOnMeaningsPayload>
          }
          aggregate: {
            args: Prisma.UsersOnMeaningsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUsersOnMeanings>
          }
          groupBy: {
            args: Prisma.UsersOnMeaningsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UsersOnMeaningsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsersOnMeaningsCountArgs<ExtArgs>,
            result: $Utils.Optional<UsersOnMeaningsCountAggregateOutputType> | number
          }
        }
      }
      WordList: {
        payload: Prisma.$WordListPayload<ExtArgs>
        fields: Prisma.WordListFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WordListFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WordListPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WordListFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WordListPayload>
          }
          findFirst: {
            args: Prisma.WordListFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WordListPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WordListFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WordListPayload>
          }
          findMany: {
            args: Prisma.WordListFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WordListPayload>[]
          }
          create: {
            args: Prisma.WordListCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WordListPayload>
          }
          createMany: {
            args: Prisma.WordListCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.WordListDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WordListPayload>
          }
          update: {
            args: Prisma.WordListUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WordListPayload>
          }
          deleteMany: {
            args: Prisma.WordListDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.WordListUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.WordListUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WordListPayload>
          }
          aggregate: {
            args: Prisma.WordListAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWordList>
          }
          groupBy: {
            args: Prisma.WordListGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WordListGroupByOutputType>[]
          }
          count: {
            args: Prisma.WordListCountArgs<ExtArgs>,
            result: $Utils.Optional<WordListCountAggregateOutputType> | number
          }
        }
      }
      WordsOnWordLists: {
        payload: Prisma.$WordsOnWordListsPayload<ExtArgs>
        fields: Prisma.WordsOnWordListsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WordsOnWordListsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WordsOnWordListsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WordsOnWordListsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WordsOnWordListsPayload>
          }
          findFirst: {
            args: Prisma.WordsOnWordListsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WordsOnWordListsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WordsOnWordListsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WordsOnWordListsPayload>
          }
          findMany: {
            args: Prisma.WordsOnWordListsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WordsOnWordListsPayload>[]
          }
          create: {
            args: Prisma.WordsOnWordListsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WordsOnWordListsPayload>
          }
          createMany: {
            args: Prisma.WordsOnWordListsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.WordsOnWordListsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WordsOnWordListsPayload>
          }
          update: {
            args: Prisma.WordsOnWordListsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WordsOnWordListsPayload>
          }
          deleteMany: {
            args: Prisma.WordsOnWordListsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.WordsOnWordListsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.WordsOnWordListsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WordsOnWordListsPayload>
          }
          aggregate: {
            args: Prisma.WordsOnWordListsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWordsOnWordLists>
          }
          groupBy: {
            args: Prisma.WordsOnWordListsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WordsOnWordListsGroupByOutputType>[]
          }
          count: {
            args: Prisma.WordsOnWordListsCountArgs<ExtArgs>,
            result: $Utils.Optional<WordsOnWordListsCountAggregateOutputType> | number
          }
        }
      }
      UsersOnWordLists: {
        payload: Prisma.$UsersOnWordListsPayload<ExtArgs>
        fields: Prisma.UsersOnWordListsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsersOnWordListsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersOnWordListsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsersOnWordListsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersOnWordListsPayload>
          }
          findFirst: {
            args: Prisma.UsersOnWordListsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersOnWordListsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsersOnWordListsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersOnWordListsPayload>
          }
          findMany: {
            args: Prisma.UsersOnWordListsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersOnWordListsPayload>[]
          }
          create: {
            args: Prisma.UsersOnWordListsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersOnWordListsPayload>
          }
          createMany: {
            args: Prisma.UsersOnWordListsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UsersOnWordListsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersOnWordListsPayload>
          }
          update: {
            args: Prisma.UsersOnWordListsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersOnWordListsPayload>
          }
          deleteMany: {
            args: Prisma.UsersOnWordListsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UsersOnWordListsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UsersOnWordListsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsersOnWordListsPayload>
          }
          aggregate: {
            args: Prisma.UsersOnWordListsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUsersOnWordLists>
          }
          groupBy: {
            args: Prisma.UsersOnWordListsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UsersOnWordListsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsersOnWordListsCountArgs<ExtArgs>,
            result: $Utils.Optional<UsersOnWordListsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  ;export  const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  ;export  type DefaultPrismaClient = PrismaClient
  ;export  type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  ;export  interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  ;export  type LogLevel = 'info' | 'query' | 'warn' | 'error'
  ;export  type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  ;export  type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  ;export  type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  ;export  type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  ;export  type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  ;export  type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  ;export  type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  ;export  type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  ;export  function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  ;export  type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  ;export  type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type WordCountOutputType
   */

  ;export  type WordCountOutputType = {
    meanings: number
    users: number
    WordsOnWordLists: number
  }

  ;export  type WordCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meanings?: boolean | WordCountOutputTypeCountMeaningsArgs
    users?: boolean | WordCountOutputTypeCountUsersArgs
    WordsOnWordLists?: boolean | WordCountOutputTypeCountWordsOnWordListsArgs
  }

  // Custom InputTypes

  /**
   * WordCountOutputType without action
   */
  ;export  type WordCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordCountOutputType
     */
    select?: WordCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * WordCountOutputType without action
   */
  ;export  type WordCountOutputTypeCountMeaningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeaningWhereInput
  }


  /**
   * WordCountOutputType without action
   */
  ;export  type WordCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersOnWordsWhereInput
  }


  /**
   * WordCountOutputType without action
   */
  ;export  type WordCountOutputTypeCountWordsOnWordListsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WordsOnWordListsWhereInput
  }



  /**
   * Count Type MeaningCountOutputType
   */

  ;export  type MeaningCountOutputType = {
    sentences: number
    users: number
  }

  ;export  type MeaningCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sentences?: boolean | MeaningCountOutputTypeCountSentencesArgs
    users?: boolean | MeaningCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes

  /**
   * MeaningCountOutputType without action
   */
  ;export  type MeaningCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeaningCountOutputType
     */
    select?: MeaningCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * MeaningCountOutputType without action
   */
  ;export  type MeaningCountOutputTypeCountSentencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SentenceWhereInput
  }


  /**
   * MeaningCountOutputType without action
   */
  ;export  type MeaningCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersOnMeaningsWhereInput
  }



  /**
   * Count Type UserCountOutputType
   */

  ;export  type UserCountOutputType = {
    words: number
    meanings: number
    UsersOnWordLists: number
  }

  ;export  type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    words?: boolean | UserCountOutputTypeCountWordsArgs
    meanings?: boolean | UserCountOutputTypeCountMeaningsArgs
    UsersOnWordLists?: boolean | UserCountOutputTypeCountUsersOnWordListsArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  ;export  type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  ;export  type UserCountOutputTypeCountWordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersOnWordsWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  ;export  type UserCountOutputTypeCountMeaningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersOnMeaningsWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  ;export  type UserCountOutputTypeCountUsersOnWordListsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersOnWordListsWhereInput
  }



  /**
   * Count Type WordListCountOutputType
   */

  ;export  type WordListCountOutputType = {
    words: number
    users: number
  }

  ;export  type WordListCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    words?: boolean | WordListCountOutputTypeCountWordsArgs
    users?: boolean | WordListCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes

  /**
   * WordListCountOutputType without action
   */
  ;export  type WordListCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordListCountOutputType
     */
    select?: WordListCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * WordListCountOutputType without action
   */
  ;export  type WordListCountOutputTypeCountWordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WordsOnWordListsWhereInput
  }


  /**
   * WordListCountOutputType without action
   */
  ;export  type WordListCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersOnWordListsWhereInput
  }



  /**
   * Models
   */

  /**
   * Model Word
   */

  ;export  type AggregateWord = {
    _count: WordCountAggregateOutputType | null
    _min: WordMinAggregateOutputType | null
    _max: WordMaxAggregateOutputType | null
  }

  ;export  type WordMinAggregateOutputType = {
    id: string | null
    word: string | null
    transcription: string | null
    audio: string | null
    source: $Enums.WordDefinitionSourceType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  ;export  type WordMaxAggregateOutputType = {
    id: string | null
    word: string | null
    transcription: string | null
    audio: string | null
    source: $Enums.WordDefinitionSourceType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  ;export  type WordCountAggregateOutputType = {
    id: number
    word: number
    transcription: number
    audio: number
    source: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  ;export  type WordMinAggregateInputType = {
    id?: true
    word?: true
    transcription?: true
    audio?: true
    source?: true
    createdAt?: true
    updatedAt?: true
  }

  ;export  type WordMaxAggregateInputType = {
    id?: true
    word?: true
    transcription?: true
    audio?: true
    source?: true
    createdAt?: true
    updatedAt?: true
  }

  ;export  type WordCountAggregateInputType = {
    id?: true
    word?: true
    transcription?: true
    audio?: true
    source?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  ;export  type WordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Word to aggregate.
     */
    where?: WordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Words to fetch.
     */
    orderBy?: WordOrderByWithRelationInput | WordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Words from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Words.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Words
    **/
    _count?: true | WordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WordMaxAggregateInputType
  }

  ;export  type GetWordAggregateType<T extends WordAggregateArgs> = {
        [P in keyof T & keyof AggregateWord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWord[P]>
      : GetScalarType<T[P], AggregateWord[P]>
  }




  ;export  type WordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WordWhereInput
    orderBy?: WordOrderByWithAggregationInput | WordOrderByWithAggregationInput[]
    by: WordScalarFieldEnum[] | WordScalarFieldEnum
    having?: WordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WordCountAggregateInputType | true
    _min?: WordMinAggregateInputType
    _max?: WordMaxAggregateInputType
  }

  ;export  type WordGroupByOutputType = {
    id: string
    word: string
    transcription: string
    audio: string | null
    source: $Enums.WordDefinitionSourceType
    createdAt: Date
    updatedAt: Date
    _count: WordCountAggregateOutputType | null
    _min: WordMinAggregateOutputType | null
    _max: WordMaxAggregateOutputType | null
  }

  type GetWordGroupByPayload<T extends WordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WordGroupByOutputType[P]>
            : GetScalarType<T[P], WordGroupByOutputType[P]>
        }
      >
    >


  ;export  type WordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    word?: boolean
    transcription?: boolean
    audio?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    meanings?: boolean | Word$meaningsArgs<ExtArgs>
    users?: boolean | Word$usersArgs<ExtArgs>
    WordsOnWordLists?: boolean | Word$WordsOnWordListsArgs<ExtArgs>
    _count?: boolean | WordCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["word"]>

  ;export  type WordSelectScalar = {
    id?: boolean
    word?: boolean
    transcription?: boolean
    audio?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  ;export  type WordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meanings?: boolean | Word$meaningsArgs<ExtArgs>
    users?: boolean | Word$usersArgs<ExtArgs>
    WordsOnWordLists?: boolean | Word$WordsOnWordListsArgs<ExtArgs>
    _count?: boolean | WordCountOutputTypeDefaultArgs<ExtArgs>
  }


  ;export  type $WordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Word"
    objects: {
      meanings: Prisma.$MeaningPayload<ExtArgs>[]
      users: Prisma.$UsersOnWordsPayload<ExtArgs>[]
      WordsOnWordLists: Prisma.$WordsOnWordListsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      word: string
      transcription: string
      audio: string | null
      source: $Enums.WordDefinitionSourceType
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["word"]>
    composites: {}
  }


  type WordGetPayload<S extends boolean | null | undefined | WordDefaultArgs> = $Result.GetResult<Prisma.$WordPayload, S>

  type WordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WordCountAggregateInputType | true
    }

  ;export  interface WordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Word'], meta: { name: 'Word' } }
    /**
     * Find zero or one Word that matches the filter.
     * @param {WordFindUniqueArgs} args - Arguments to find a Word
     * @example
     * // Get one Word
     * const word = await prisma.word.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WordFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, WordFindUniqueArgs<ExtArgs>>
    ): Prisma__WordClient<$Result.GetResult<Prisma.$WordPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Word that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WordFindUniqueOrThrowArgs} args - Arguments to find a Word
     * @example
     * // Get one Word
     * const word = await prisma.word.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WordFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WordFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WordClient<$Result.GetResult<Prisma.$WordPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Word that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordFindFirstArgs} args - Arguments to find a Word
     * @example
     * // Get one Word
     * const word = await prisma.word.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WordFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, WordFindFirstArgs<ExtArgs>>
    ): Prisma__WordClient<$Result.GetResult<Prisma.$WordPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Word that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordFindFirstOrThrowArgs} args - Arguments to find a Word
     * @example
     * // Get one Word
     * const word = await prisma.word.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WordFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WordFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WordClient<$Result.GetResult<Prisma.$WordPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Words that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Words
     * const words = await prisma.word.findMany()
     * 
     * // Get first 10 Words
     * const words = await prisma.word.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wordWithIdOnly = await prisma.word.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WordFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WordFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WordPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Word.
     * @param {WordCreateArgs} args - Arguments to create a Word.
     * @example
     * // Create one Word
     * const Word = await prisma.word.create({
     *   data: {
     *     // ... data to create a Word
     *   }
     * })
     * 
    **/
    create<T extends WordCreateArgs<ExtArgs>>(
      args: SelectSubset<T, WordCreateArgs<ExtArgs>>
    ): Prisma__WordClient<$Result.GetResult<Prisma.$WordPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Words.
     *     @param {WordCreateManyArgs} args - Arguments to create many Words.
     *     @example
     *     // Create many Words
     *     const word = await prisma.word.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WordCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WordCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Word.
     * @param {WordDeleteArgs} args - Arguments to delete one Word.
     * @example
     * // Delete one Word
     * const Word = await prisma.word.delete({
     *   where: {
     *     // ... filter to delete one Word
     *   }
     * })
     * 
    **/
    delete<T extends WordDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, WordDeleteArgs<ExtArgs>>
    ): Prisma__WordClient<$Result.GetResult<Prisma.$WordPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Word.
     * @param {WordUpdateArgs} args - Arguments to update one Word.
     * @example
     * // Update one Word
     * const word = await prisma.word.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WordUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, WordUpdateArgs<ExtArgs>>
    ): Prisma__WordClient<$Result.GetResult<Prisma.$WordPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Words.
     * @param {WordDeleteManyArgs} args - Arguments to filter Words to delete.
     * @example
     * // Delete a few Words
     * const { count } = await prisma.word.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WordDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WordDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Words.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Words
     * const word = await prisma.word.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WordUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, WordUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Word.
     * @param {WordUpsertArgs} args - Arguments to update or create a Word.
     * @example
     * // Update or create a Word
     * const word = await prisma.word.upsert({
     *   create: {
     *     // ... data to create a Word
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Word we want to update
     *   }
     * })
    **/
    upsert<T extends WordUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, WordUpsertArgs<ExtArgs>>
    ): Prisma__WordClient<$Result.GetResult<Prisma.$WordPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Words.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordCountArgs} args - Arguments to filter Words to count.
     * @example
     * // Count the number of Words
     * const count = await prisma.word.count({
     *   where: {
     *     // ... the filter for the Words we want to count
     *   }
     * })
    **/
    count<T extends WordCountArgs>(
      args?: Subset<T, WordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Word.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WordAggregateArgs>(args: Subset<T, WordAggregateArgs>): Prisma.PrismaPromise<GetWordAggregateType<T>>

    /**
     * Group by Word.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WordGroupByArgs['orderBy'] }
        : { orderBy?: WordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Word model
   */
  readonly fields: WordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Word.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  ;export  interface Prisma__WordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    meanings<T extends Word$meaningsArgs<ExtArgs> = {}>(args?: Subset<T, Word$meaningsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeaningPayload<ExtArgs>, T, 'findMany'> | Null>;

    users<T extends Word$usersArgs<ExtArgs> = {}>(args?: Subset<T, Word$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersOnWordsPayload<ExtArgs>, T, 'findMany'> | Null>;

    WordsOnWordLists<T extends Word$WordsOnWordListsArgs<ExtArgs> = {}>(args?: Subset<T, Word$WordsOnWordListsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WordsOnWordListsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Word model
   */ 
  interface WordFieldRefs {
    readonly id: FieldRef<"Word", 'String'>
    readonly word: FieldRef<"Word", 'String'>
    readonly transcription: FieldRef<"Word", 'String'>
    readonly audio: FieldRef<"Word", 'String'>
    readonly source: FieldRef<"Word", 'WordDefinitionSourceType'>
    readonly createdAt: FieldRef<"Word", 'DateTime'>
    readonly updatedAt: FieldRef<"Word", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Word findUnique
   */
  ;export  type WordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Word
     */
    select?: WordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordInclude<ExtArgs> | null
    /**
     * Filter, which Word to fetch.
     */
    where: WordWhereUniqueInput
  }


  /**
   * Word findUniqueOrThrow
   */
  ;export  type WordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Word
     */
    select?: WordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordInclude<ExtArgs> | null
    /**
     * Filter, which Word to fetch.
     */
    where: WordWhereUniqueInput
  }


  /**
   * Word findFirst
   */
  ;export  type WordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Word
     */
    select?: WordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordInclude<ExtArgs> | null
    /**
     * Filter, which Word to fetch.
     */
    where?: WordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Words to fetch.
     */
    orderBy?: WordOrderByWithRelationInput | WordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Words.
     */
    cursor?: WordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Words from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Words.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Words.
     */
    distinct?: WordScalarFieldEnum | WordScalarFieldEnum[]
  }


  /**
   * Word findFirstOrThrow
   */
  ;export  type WordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Word
     */
    select?: WordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordInclude<ExtArgs> | null
    /**
     * Filter, which Word to fetch.
     */
    where?: WordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Words to fetch.
     */
    orderBy?: WordOrderByWithRelationInput | WordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Words.
     */
    cursor?: WordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Words from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Words.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Words.
     */
    distinct?: WordScalarFieldEnum | WordScalarFieldEnum[]
  }


  /**
   * Word findMany
   */
  ;export  type WordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Word
     */
    select?: WordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordInclude<ExtArgs> | null
    /**
     * Filter, which Words to fetch.
     */
    where?: WordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Words to fetch.
     */
    orderBy?: WordOrderByWithRelationInput | WordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Words.
     */
    cursor?: WordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Words from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Words.
     */
    skip?: number
    distinct?: WordScalarFieldEnum | WordScalarFieldEnum[]
  }


  /**
   * Word create
   */
  ;export  type WordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Word
     */
    select?: WordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordInclude<ExtArgs> | null
    /**
     * The data needed to create a Word.
     */
    data: XOR<WordCreateInput, WordUncheckedCreateInput>
  }


  /**
   * Word createMany
   */
  ;export  type WordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Words.
     */
    data: WordCreateManyInput | WordCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Word update
   */
  ;export  type WordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Word
     */
    select?: WordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordInclude<ExtArgs> | null
    /**
     * The data needed to update a Word.
     */
    data: XOR<WordUpdateInput, WordUncheckedUpdateInput>
    /**
     * Choose, which Word to update.
     */
    where: WordWhereUniqueInput
  }


  /**
   * Word updateMany
   */
  ;export  type WordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Words.
     */
    data: XOR<WordUpdateManyMutationInput, WordUncheckedUpdateManyInput>
    /**
     * Filter which Words to update
     */
    where?: WordWhereInput
  }


  /**
   * Word upsert
   */
  ;export  type WordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Word
     */
    select?: WordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordInclude<ExtArgs> | null
    /**
     * The filter to search for the Word to update in case it exists.
     */
    where: WordWhereUniqueInput
    /**
     * In case the Word found by the `where` argument doesn't exist, create a new Word with this data.
     */
    create: XOR<WordCreateInput, WordUncheckedCreateInput>
    /**
     * In case the Word was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WordUpdateInput, WordUncheckedUpdateInput>
  }


  /**
   * Word delete
   */
  ;export  type WordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Word
     */
    select?: WordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordInclude<ExtArgs> | null
    /**
     * Filter which Word to delete.
     */
    where: WordWhereUniqueInput
  }


  /**
   * Word deleteMany
   */
  ;export  type WordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Words to delete
     */
    where?: WordWhereInput
  }


  /**
   * Word.meanings
   */
  ;export  type Word$meaningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meaning
     */
    select?: MeaningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MeaningInclude<ExtArgs> | null
    where?: MeaningWhereInput
    orderBy?: MeaningOrderByWithRelationInput | MeaningOrderByWithRelationInput[]
    cursor?: MeaningWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeaningScalarFieldEnum | MeaningScalarFieldEnum[]
  }


  /**
   * Word.users
   */
  ;export  type Word$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnWords
     */
    select?: UsersOnWordsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersOnWordsInclude<ExtArgs> | null
    where?: UsersOnWordsWhereInput
    orderBy?: UsersOnWordsOrderByWithRelationInput | UsersOnWordsOrderByWithRelationInput[]
    cursor?: UsersOnWordsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersOnWordsScalarFieldEnum | UsersOnWordsScalarFieldEnum[]
  }


  /**
   * Word.WordsOnWordLists
   */
  ;export  type Word$WordsOnWordListsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordsOnWordLists
     */
    select?: WordsOnWordListsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordsOnWordListsInclude<ExtArgs> | null
    where?: WordsOnWordListsWhereInput
    orderBy?: WordsOnWordListsOrderByWithRelationInput | WordsOnWordListsOrderByWithRelationInput[]
    cursor?: WordsOnWordListsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WordsOnWordListsScalarFieldEnum | WordsOnWordListsScalarFieldEnum[]
  }


  /**
   * Word without action
   */
  ;export  type WordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Word
     */
    select?: WordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordInclude<ExtArgs> | null
  }



  /**
   * Model Meaning
   */

  ;export  type AggregateMeaning = {
    _count: MeaningCountAggregateOutputType | null
    _min: MeaningMinAggregateOutputType | null
    _max: MeaningMaxAggregateOutputType | null
  }

  ;export  type MeaningMinAggregateOutputType = {
    id: string | null
    term: string | null
    partOfSpeech: string | null
    meaning: string | null
    createdAt: Date | null
    updatedAt: Date | null
    wordId: string | null
  }

  ;export  type MeaningMaxAggregateOutputType = {
    id: string | null
    term: string | null
    partOfSpeech: string | null
    meaning: string | null
    createdAt: Date | null
    updatedAt: Date | null
    wordId: string | null
  }

  ;export  type MeaningCountAggregateOutputType = {
    id: number
    term: number
    partOfSpeech: number
    meaning: number
    synonyms: number
    antonyms: number
    createdAt: number
    updatedAt: number
    wordId: number
    _all: number
  }


  ;export  type MeaningMinAggregateInputType = {
    id?: true
    term?: true
    partOfSpeech?: true
    meaning?: true
    createdAt?: true
    updatedAt?: true
    wordId?: true
  }

  ;export  type MeaningMaxAggregateInputType = {
    id?: true
    term?: true
    partOfSpeech?: true
    meaning?: true
    createdAt?: true
    updatedAt?: true
    wordId?: true
  }

  ;export  type MeaningCountAggregateInputType = {
    id?: true
    term?: true
    partOfSpeech?: true
    meaning?: true
    synonyms?: true
    antonyms?: true
    createdAt?: true
    updatedAt?: true
    wordId?: true
    _all?: true
  }

  ;export  type MeaningAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Meaning to aggregate.
     */
    where?: MeaningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meanings to fetch.
     */
    orderBy?: MeaningOrderByWithRelationInput | MeaningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MeaningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meanings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meanings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Meanings
    **/
    _count?: true | MeaningCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MeaningMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MeaningMaxAggregateInputType
  }

  ;export  type GetMeaningAggregateType<T extends MeaningAggregateArgs> = {
        [P in keyof T & keyof AggregateMeaning]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeaning[P]>
      : GetScalarType<T[P], AggregateMeaning[P]>
  }




  ;export  type MeaningGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeaningWhereInput
    orderBy?: MeaningOrderByWithAggregationInput | MeaningOrderByWithAggregationInput[]
    by: MeaningScalarFieldEnum[] | MeaningScalarFieldEnum
    having?: MeaningScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MeaningCountAggregateInputType | true
    _min?: MeaningMinAggregateInputType
    _max?: MeaningMaxAggregateInputType
  }

  ;export  type MeaningGroupByOutputType = {
    id: string
    term: string
    partOfSpeech: string
    meaning: string
    synonyms: string[]
    antonyms: string[]
    createdAt: Date
    updatedAt: Date
    wordId: string
    _count: MeaningCountAggregateOutputType | null
    _min: MeaningMinAggregateOutputType | null
    _max: MeaningMaxAggregateOutputType | null
  }

  type GetMeaningGroupByPayload<T extends MeaningGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MeaningGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MeaningGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MeaningGroupByOutputType[P]>
            : GetScalarType<T[P], MeaningGroupByOutputType[P]>
        }
      >
    >


  ;export  type MeaningSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    term?: boolean
    partOfSpeech?: boolean
    meaning?: boolean
    synonyms?: boolean
    antonyms?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    wordId?: boolean
    sentences?: boolean | Meaning$sentencesArgs<ExtArgs>
    Word?: boolean | WordDefaultArgs<ExtArgs>
    users?: boolean | Meaning$usersArgs<ExtArgs>
    _count?: boolean | MeaningCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meaning"]>

  ;export  type MeaningSelectScalar = {
    id?: boolean
    term?: boolean
    partOfSpeech?: boolean
    meaning?: boolean
    synonyms?: boolean
    antonyms?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    wordId?: boolean
  }

  ;export  type MeaningInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sentences?: boolean | Meaning$sentencesArgs<ExtArgs>
    Word?: boolean | WordDefaultArgs<ExtArgs>
    users?: boolean | Meaning$usersArgs<ExtArgs>
    _count?: boolean | MeaningCountOutputTypeDefaultArgs<ExtArgs>
  }


  ;export  type $MeaningPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Meaning"
    objects: {
      sentences: Prisma.$SentencePayload<ExtArgs>[]
      Word: Prisma.$WordPayload<ExtArgs>
      users: Prisma.$UsersOnMeaningsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      term: string
      partOfSpeech: string
      meaning: string
      synonyms: string[]
      antonyms: string[]
      createdAt: Date
      updatedAt: Date
      wordId: string
    }, ExtArgs["result"]["meaning"]>
    composites: {}
  }


  type MeaningGetPayload<S extends boolean | null | undefined | MeaningDefaultArgs> = $Result.GetResult<Prisma.$MeaningPayload, S>

  type MeaningCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MeaningFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MeaningCountAggregateInputType | true
    }

  ;export  interface MeaningDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Meaning'], meta: { name: 'Meaning' } }
    /**
     * Find zero or one Meaning that matches the filter.
     * @param {MeaningFindUniqueArgs} args - Arguments to find a Meaning
     * @example
     * // Get one Meaning
     * const meaning = await prisma.meaning.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MeaningFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MeaningFindUniqueArgs<ExtArgs>>
    ): Prisma__MeaningClient<$Result.GetResult<Prisma.$MeaningPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Meaning that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MeaningFindUniqueOrThrowArgs} args - Arguments to find a Meaning
     * @example
     * // Get one Meaning
     * const meaning = await prisma.meaning.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MeaningFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MeaningFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MeaningClient<$Result.GetResult<Prisma.$MeaningPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Meaning that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeaningFindFirstArgs} args - Arguments to find a Meaning
     * @example
     * // Get one Meaning
     * const meaning = await prisma.meaning.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MeaningFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MeaningFindFirstArgs<ExtArgs>>
    ): Prisma__MeaningClient<$Result.GetResult<Prisma.$MeaningPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Meaning that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeaningFindFirstOrThrowArgs} args - Arguments to find a Meaning
     * @example
     * // Get one Meaning
     * const meaning = await prisma.meaning.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MeaningFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MeaningFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MeaningClient<$Result.GetResult<Prisma.$MeaningPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Meanings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeaningFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Meanings
     * const meanings = await prisma.meaning.findMany()
     * 
     * // Get first 10 Meanings
     * const meanings = await prisma.meaning.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const meaningWithIdOnly = await prisma.meaning.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MeaningFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MeaningFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeaningPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Meaning.
     * @param {MeaningCreateArgs} args - Arguments to create a Meaning.
     * @example
     * // Create one Meaning
     * const Meaning = await prisma.meaning.create({
     *   data: {
     *     // ... data to create a Meaning
     *   }
     * })
     * 
    **/
    create<T extends MeaningCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MeaningCreateArgs<ExtArgs>>
    ): Prisma__MeaningClient<$Result.GetResult<Prisma.$MeaningPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Meanings.
     *     @param {MeaningCreateManyArgs} args - Arguments to create many Meanings.
     *     @example
     *     // Create many Meanings
     *     const meaning = await prisma.meaning.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MeaningCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MeaningCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Meaning.
     * @param {MeaningDeleteArgs} args - Arguments to delete one Meaning.
     * @example
     * // Delete one Meaning
     * const Meaning = await prisma.meaning.delete({
     *   where: {
     *     // ... filter to delete one Meaning
     *   }
     * })
     * 
    **/
    delete<T extends MeaningDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MeaningDeleteArgs<ExtArgs>>
    ): Prisma__MeaningClient<$Result.GetResult<Prisma.$MeaningPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Meaning.
     * @param {MeaningUpdateArgs} args - Arguments to update one Meaning.
     * @example
     * // Update one Meaning
     * const meaning = await prisma.meaning.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MeaningUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MeaningUpdateArgs<ExtArgs>>
    ): Prisma__MeaningClient<$Result.GetResult<Prisma.$MeaningPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Meanings.
     * @param {MeaningDeleteManyArgs} args - Arguments to filter Meanings to delete.
     * @example
     * // Delete a few Meanings
     * const { count } = await prisma.meaning.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MeaningDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MeaningDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Meanings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeaningUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Meanings
     * const meaning = await prisma.meaning.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MeaningUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MeaningUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Meaning.
     * @param {MeaningUpsertArgs} args - Arguments to update or create a Meaning.
     * @example
     * // Update or create a Meaning
     * const meaning = await prisma.meaning.upsert({
     *   create: {
     *     // ... data to create a Meaning
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Meaning we want to update
     *   }
     * })
    **/
    upsert<T extends MeaningUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MeaningUpsertArgs<ExtArgs>>
    ): Prisma__MeaningClient<$Result.GetResult<Prisma.$MeaningPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Meanings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeaningCountArgs} args - Arguments to filter Meanings to count.
     * @example
     * // Count the number of Meanings
     * const count = await prisma.meaning.count({
     *   where: {
     *     // ... the filter for the Meanings we want to count
     *   }
     * })
    **/
    count<T extends MeaningCountArgs>(
      args?: Subset<T, MeaningCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MeaningCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Meaning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeaningAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MeaningAggregateArgs>(args: Subset<T, MeaningAggregateArgs>): Prisma.PrismaPromise<GetMeaningAggregateType<T>>

    /**
     * Group by Meaning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeaningGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MeaningGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MeaningGroupByArgs['orderBy'] }
        : { orderBy?: MeaningGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MeaningGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeaningGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Meaning model
   */
  readonly fields: MeaningFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Meaning.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  ;export  interface Prisma__MeaningClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    sentences<T extends Meaning$sentencesArgs<ExtArgs> = {}>(args?: Subset<T, Meaning$sentencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SentencePayload<ExtArgs>, T, 'findMany'> | Null>;

    Word<T extends WordDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WordDefaultArgs<ExtArgs>>): Prisma__WordClient<$Result.GetResult<Prisma.$WordPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    users<T extends Meaning$usersArgs<ExtArgs> = {}>(args?: Subset<T, Meaning$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersOnMeaningsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Meaning model
   */ 
  interface MeaningFieldRefs {
    readonly id: FieldRef<"Meaning", 'String'>
    readonly term: FieldRef<"Meaning", 'String'>
    readonly partOfSpeech: FieldRef<"Meaning", 'String'>
    readonly meaning: FieldRef<"Meaning", 'String'>
    readonly synonyms: FieldRef<"Meaning", 'String[]'>
    readonly antonyms: FieldRef<"Meaning", 'String[]'>
    readonly createdAt: FieldRef<"Meaning", 'DateTime'>
    readonly updatedAt: FieldRef<"Meaning", 'DateTime'>
    readonly wordId: FieldRef<"Meaning", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Meaning findUnique
   */
  ;export  type MeaningFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meaning
     */
    select?: MeaningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MeaningInclude<ExtArgs> | null
    /**
     * Filter, which Meaning to fetch.
     */
    where: MeaningWhereUniqueInput
  }


  /**
   * Meaning findUniqueOrThrow
   */
  ;export  type MeaningFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meaning
     */
    select?: MeaningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MeaningInclude<ExtArgs> | null
    /**
     * Filter, which Meaning to fetch.
     */
    where: MeaningWhereUniqueInput
  }


  /**
   * Meaning findFirst
   */
  ;export  type MeaningFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meaning
     */
    select?: MeaningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MeaningInclude<ExtArgs> | null
    /**
     * Filter, which Meaning to fetch.
     */
    where?: MeaningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meanings to fetch.
     */
    orderBy?: MeaningOrderByWithRelationInput | MeaningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Meanings.
     */
    cursor?: MeaningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meanings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meanings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Meanings.
     */
    distinct?: MeaningScalarFieldEnum | MeaningScalarFieldEnum[]
  }


  /**
   * Meaning findFirstOrThrow
   */
  ;export  type MeaningFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meaning
     */
    select?: MeaningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MeaningInclude<ExtArgs> | null
    /**
     * Filter, which Meaning to fetch.
     */
    where?: MeaningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meanings to fetch.
     */
    orderBy?: MeaningOrderByWithRelationInput | MeaningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Meanings.
     */
    cursor?: MeaningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meanings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meanings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Meanings.
     */
    distinct?: MeaningScalarFieldEnum | MeaningScalarFieldEnum[]
  }


  /**
   * Meaning findMany
   */
  ;export  type MeaningFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meaning
     */
    select?: MeaningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MeaningInclude<ExtArgs> | null
    /**
     * Filter, which Meanings to fetch.
     */
    where?: MeaningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meanings to fetch.
     */
    orderBy?: MeaningOrderByWithRelationInput | MeaningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Meanings.
     */
    cursor?: MeaningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meanings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meanings.
     */
    skip?: number
    distinct?: MeaningScalarFieldEnum | MeaningScalarFieldEnum[]
  }


  /**
   * Meaning create
   */
  ;export  type MeaningCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meaning
     */
    select?: MeaningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MeaningInclude<ExtArgs> | null
    /**
     * The data needed to create a Meaning.
     */
    data: XOR<MeaningCreateInput, MeaningUncheckedCreateInput>
  }


  /**
   * Meaning createMany
   */
  ;export  type MeaningCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Meanings.
     */
    data: MeaningCreateManyInput | MeaningCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Meaning update
   */
  ;export  type MeaningUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meaning
     */
    select?: MeaningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MeaningInclude<ExtArgs> | null
    /**
     * The data needed to update a Meaning.
     */
    data: XOR<MeaningUpdateInput, MeaningUncheckedUpdateInput>
    /**
     * Choose, which Meaning to update.
     */
    where: MeaningWhereUniqueInput
  }


  /**
   * Meaning updateMany
   */
  ;export  type MeaningUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Meanings.
     */
    data: XOR<MeaningUpdateManyMutationInput, MeaningUncheckedUpdateManyInput>
    /**
     * Filter which Meanings to update
     */
    where?: MeaningWhereInput
  }


  /**
   * Meaning upsert
   */
  ;export  type MeaningUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meaning
     */
    select?: MeaningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MeaningInclude<ExtArgs> | null
    /**
     * The filter to search for the Meaning to update in case it exists.
     */
    where: MeaningWhereUniqueInput
    /**
     * In case the Meaning found by the `where` argument doesn't exist, create a new Meaning with this data.
     */
    create: XOR<MeaningCreateInput, MeaningUncheckedCreateInput>
    /**
     * In case the Meaning was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MeaningUpdateInput, MeaningUncheckedUpdateInput>
  }


  /**
   * Meaning delete
   */
  ;export  type MeaningDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meaning
     */
    select?: MeaningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MeaningInclude<ExtArgs> | null
    /**
     * Filter which Meaning to delete.
     */
    where: MeaningWhereUniqueInput
  }


  /**
   * Meaning deleteMany
   */
  ;export  type MeaningDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Meanings to delete
     */
    where?: MeaningWhereInput
  }


  /**
   * Meaning.sentences
   */
  ;export  type Meaning$sentencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sentence
     */
    select?: SentenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SentenceInclude<ExtArgs> | null
    where?: SentenceWhereInput
    orderBy?: SentenceOrderByWithRelationInput | SentenceOrderByWithRelationInput[]
    cursor?: SentenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SentenceScalarFieldEnum | SentenceScalarFieldEnum[]
  }


  /**
   * Meaning.users
   */
  ;export  type Meaning$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnMeanings
     */
    select?: UsersOnMeaningsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersOnMeaningsInclude<ExtArgs> | null
    where?: UsersOnMeaningsWhereInput
    orderBy?: UsersOnMeaningsOrderByWithRelationInput | UsersOnMeaningsOrderByWithRelationInput[]
    cursor?: UsersOnMeaningsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersOnMeaningsScalarFieldEnum | UsersOnMeaningsScalarFieldEnum[]
  }


  /**
   * Meaning without action
   */
  ;export  type MeaningDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meaning
     */
    select?: MeaningSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MeaningInclude<ExtArgs> | null
  }



  /**
   * Model Sentence
   */

  ;export  type AggregateSentence = {
    _count: SentenceCountAggregateOutputType | null
    _avg: SentenceAvgAggregateOutputType | null
    _sum: SentenceSumAggregateOutputType | null
    _min: SentenceMinAggregateOutputType | null
    _max: SentenceMaxAggregateOutputType | null
  }

  ;export  type SentenceAvgAggregateOutputType = {
    greatVotesCount: number | null
    fineVotesCount: number | null
    badVotesCount: number | null
  }

  ;export  type SentenceSumAggregateOutputType = {
    greatVotesCount: number | null
    fineVotesCount: number | null
    badVotesCount: number | null
  }

  ;export  type SentenceMinAggregateOutputType = {
    id: string | null
    fullText: string | null
    wordToLearn: string | null
    meaningId: string | null
    source: $Enums.SentenceSourceType | null
    greatVotesCount: number | null
    fineVotesCount: number | null
    badVotesCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  ;export  type SentenceMaxAggregateOutputType = {
    id: string | null
    fullText: string | null
    wordToLearn: string | null
    meaningId: string | null
    source: $Enums.SentenceSourceType | null
    greatVotesCount: number | null
    fineVotesCount: number | null
    badVotesCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  ;export  type SentenceCountAggregateOutputType = {
    id: number
    fullText: number
    wordToLearn: number
    options: number
    meaningId: number
    source: number
    greatVotesCount: number
    fineVotesCount: number
    badVotesCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  ;export  type SentenceAvgAggregateInputType = {
    greatVotesCount?: true
    fineVotesCount?: true
    badVotesCount?: true
  }

  ;export  type SentenceSumAggregateInputType = {
    greatVotesCount?: true
    fineVotesCount?: true
    badVotesCount?: true
  }

  ;export  type SentenceMinAggregateInputType = {
    id?: true
    fullText?: true
    wordToLearn?: true
    meaningId?: true
    source?: true
    greatVotesCount?: true
    fineVotesCount?: true
    badVotesCount?: true
    createdAt?: true
    updatedAt?: true
  }

  ;export  type SentenceMaxAggregateInputType = {
    id?: true
    fullText?: true
    wordToLearn?: true
    meaningId?: true
    source?: true
    greatVotesCount?: true
    fineVotesCount?: true
    badVotesCount?: true
    createdAt?: true
    updatedAt?: true
  }

  ;export  type SentenceCountAggregateInputType = {
    id?: true
    fullText?: true
    wordToLearn?: true
    options?: true
    meaningId?: true
    source?: true
    greatVotesCount?: true
    fineVotesCount?: true
    badVotesCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  ;export  type SentenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sentence to aggregate.
     */
    where?: SentenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sentences to fetch.
     */
    orderBy?: SentenceOrderByWithRelationInput | SentenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SentenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sentences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sentences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sentences
    **/
    _count?: true | SentenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SentenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SentenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SentenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SentenceMaxAggregateInputType
  }

  ;export  type GetSentenceAggregateType<T extends SentenceAggregateArgs> = {
        [P in keyof T & keyof AggregateSentence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSentence[P]>
      : GetScalarType<T[P], AggregateSentence[P]>
  }




  ;export  type SentenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SentenceWhereInput
    orderBy?: SentenceOrderByWithAggregationInput | SentenceOrderByWithAggregationInput[]
    by: SentenceScalarFieldEnum[] | SentenceScalarFieldEnum
    having?: SentenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SentenceCountAggregateInputType | true
    _avg?: SentenceAvgAggregateInputType
    _sum?: SentenceSumAggregateInputType
    _min?: SentenceMinAggregateInputType
    _max?: SentenceMaxAggregateInputType
  }

  ;export  type SentenceGroupByOutputType = {
    id: string
    fullText: string
    wordToLearn: string
    options: string[]
    meaningId: string
    source: $Enums.SentenceSourceType
    greatVotesCount: number
    fineVotesCount: number
    badVotesCount: number
    createdAt: Date
    updatedAt: Date
    _count: SentenceCountAggregateOutputType | null
    _avg: SentenceAvgAggregateOutputType | null
    _sum: SentenceSumAggregateOutputType | null
    _min: SentenceMinAggregateOutputType | null
    _max: SentenceMaxAggregateOutputType | null
  }

  type GetSentenceGroupByPayload<T extends SentenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SentenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SentenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SentenceGroupByOutputType[P]>
            : GetScalarType<T[P], SentenceGroupByOutputType[P]>
        }
      >
    >


  ;export  type SentenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullText?: boolean
    wordToLearn?: boolean
    options?: boolean
    meaningId?: boolean
    source?: boolean
    greatVotesCount?: boolean
    fineVotesCount?: boolean
    badVotesCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Meaning?: boolean | MeaningDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sentence"]>

  ;export  type SentenceSelectScalar = {
    id?: boolean
    fullText?: boolean
    wordToLearn?: boolean
    options?: boolean
    meaningId?: boolean
    source?: boolean
    greatVotesCount?: boolean
    fineVotesCount?: boolean
    badVotesCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  ;export  type SentenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Meaning?: boolean | MeaningDefaultArgs<ExtArgs>
  }


  ;export  type $SentencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sentence"
    objects: {
      Meaning: Prisma.$MeaningPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fullText: string
      wordToLearn: string
      options: string[]
      meaningId: string
      source: $Enums.SentenceSourceType
      greatVotesCount: number
      fineVotesCount: number
      badVotesCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sentence"]>
    composites: {}
  }


  type SentenceGetPayload<S extends boolean | null | undefined | SentenceDefaultArgs> = $Result.GetResult<Prisma.$SentencePayload, S>

  type SentenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SentenceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SentenceCountAggregateInputType | true
    }

  ;export  interface SentenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sentence'], meta: { name: 'Sentence' } }
    /**
     * Find zero or one Sentence that matches the filter.
     * @param {SentenceFindUniqueArgs} args - Arguments to find a Sentence
     * @example
     * // Get one Sentence
     * const sentence = await prisma.sentence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SentenceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SentenceFindUniqueArgs<ExtArgs>>
    ): Prisma__SentenceClient<$Result.GetResult<Prisma.$SentencePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Sentence that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SentenceFindUniqueOrThrowArgs} args - Arguments to find a Sentence
     * @example
     * // Get one Sentence
     * const sentence = await prisma.sentence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SentenceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SentenceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SentenceClient<$Result.GetResult<Prisma.$SentencePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Sentence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SentenceFindFirstArgs} args - Arguments to find a Sentence
     * @example
     * // Get one Sentence
     * const sentence = await prisma.sentence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SentenceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SentenceFindFirstArgs<ExtArgs>>
    ): Prisma__SentenceClient<$Result.GetResult<Prisma.$SentencePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Sentence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SentenceFindFirstOrThrowArgs} args - Arguments to find a Sentence
     * @example
     * // Get one Sentence
     * const sentence = await prisma.sentence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SentenceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SentenceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SentenceClient<$Result.GetResult<Prisma.$SentencePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Sentences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SentenceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sentences
     * const sentences = await prisma.sentence.findMany()
     * 
     * // Get first 10 Sentences
     * const sentences = await prisma.sentence.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sentenceWithIdOnly = await prisma.sentence.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SentenceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SentenceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SentencePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Sentence.
     * @param {SentenceCreateArgs} args - Arguments to create a Sentence.
     * @example
     * // Create one Sentence
     * const Sentence = await prisma.sentence.create({
     *   data: {
     *     // ... data to create a Sentence
     *   }
     * })
     * 
    **/
    create<T extends SentenceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SentenceCreateArgs<ExtArgs>>
    ): Prisma__SentenceClient<$Result.GetResult<Prisma.$SentencePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Sentences.
     *     @param {SentenceCreateManyArgs} args - Arguments to create many Sentences.
     *     @example
     *     // Create many Sentences
     *     const sentence = await prisma.sentence.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SentenceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SentenceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sentence.
     * @param {SentenceDeleteArgs} args - Arguments to delete one Sentence.
     * @example
     * // Delete one Sentence
     * const Sentence = await prisma.sentence.delete({
     *   where: {
     *     // ... filter to delete one Sentence
     *   }
     * })
     * 
    **/
    delete<T extends SentenceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SentenceDeleteArgs<ExtArgs>>
    ): Prisma__SentenceClient<$Result.GetResult<Prisma.$SentencePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Sentence.
     * @param {SentenceUpdateArgs} args - Arguments to update one Sentence.
     * @example
     * // Update one Sentence
     * const sentence = await prisma.sentence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SentenceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SentenceUpdateArgs<ExtArgs>>
    ): Prisma__SentenceClient<$Result.GetResult<Prisma.$SentencePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Sentences.
     * @param {SentenceDeleteManyArgs} args - Arguments to filter Sentences to delete.
     * @example
     * // Delete a few Sentences
     * const { count } = await prisma.sentence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SentenceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SentenceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sentences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SentenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sentences
     * const sentence = await prisma.sentence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SentenceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SentenceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sentence.
     * @param {SentenceUpsertArgs} args - Arguments to update or create a Sentence.
     * @example
     * // Update or create a Sentence
     * const sentence = await prisma.sentence.upsert({
     *   create: {
     *     // ... data to create a Sentence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sentence we want to update
     *   }
     * })
    **/
    upsert<T extends SentenceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SentenceUpsertArgs<ExtArgs>>
    ): Prisma__SentenceClient<$Result.GetResult<Prisma.$SentencePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Sentences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SentenceCountArgs} args - Arguments to filter Sentences to count.
     * @example
     * // Count the number of Sentences
     * const count = await prisma.sentence.count({
     *   where: {
     *     // ... the filter for the Sentences we want to count
     *   }
     * })
    **/
    count<T extends SentenceCountArgs>(
      args?: Subset<T, SentenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SentenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sentence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SentenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SentenceAggregateArgs>(args: Subset<T, SentenceAggregateArgs>): Prisma.PrismaPromise<GetSentenceAggregateType<T>>

    /**
     * Group by Sentence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SentenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SentenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SentenceGroupByArgs['orderBy'] }
        : { orderBy?: SentenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SentenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSentenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sentence model
   */
  readonly fields: SentenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sentence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  ;export  interface Prisma__SentenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Meaning<T extends MeaningDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MeaningDefaultArgs<ExtArgs>>): Prisma__MeaningClient<$Result.GetResult<Prisma.$MeaningPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Sentence model
   */ 
  interface SentenceFieldRefs {
    readonly id: FieldRef<"Sentence", 'String'>
    readonly fullText: FieldRef<"Sentence", 'String'>
    readonly wordToLearn: FieldRef<"Sentence", 'String'>
    readonly options: FieldRef<"Sentence", 'String[]'>
    readonly meaningId: FieldRef<"Sentence", 'String'>
    readonly source: FieldRef<"Sentence", 'SentenceSourceType'>
    readonly greatVotesCount: FieldRef<"Sentence", 'Int'>
    readonly fineVotesCount: FieldRef<"Sentence", 'Int'>
    readonly badVotesCount: FieldRef<"Sentence", 'Int'>
    readonly createdAt: FieldRef<"Sentence", 'DateTime'>
    readonly updatedAt: FieldRef<"Sentence", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Sentence findUnique
   */
  ;export  type SentenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sentence
     */
    select?: SentenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SentenceInclude<ExtArgs> | null
    /**
     * Filter, which Sentence to fetch.
     */
    where: SentenceWhereUniqueInput
  }


  /**
   * Sentence findUniqueOrThrow
   */
  ;export  type SentenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sentence
     */
    select?: SentenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SentenceInclude<ExtArgs> | null
    /**
     * Filter, which Sentence to fetch.
     */
    where: SentenceWhereUniqueInput
  }


  /**
   * Sentence findFirst
   */
  ;export  type SentenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sentence
     */
    select?: SentenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SentenceInclude<ExtArgs> | null
    /**
     * Filter, which Sentence to fetch.
     */
    where?: SentenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sentences to fetch.
     */
    orderBy?: SentenceOrderByWithRelationInput | SentenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sentences.
     */
    cursor?: SentenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sentences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sentences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sentences.
     */
    distinct?: SentenceScalarFieldEnum | SentenceScalarFieldEnum[]
  }


  /**
   * Sentence findFirstOrThrow
   */
  ;export  type SentenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sentence
     */
    select?: SentenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SentenceInclude<ExtArgs> | null
    /**
     * Filter, which Sentence to fetch.
     */
    where?: SentenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sentences to fetch.
     */
    orderBy?: SentenceOrderByWithRelationInput | SentenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sentences.
     */
    cursor?: SentenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sentences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sentences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sentences.
     */
    distinct?: SentenceScalarFieldEnum | SentenceScalarFieldEnum[]
  }


  /**
   * Sentence findMany
   */
  ;export  type SentenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sentence
     */
    select?: SentenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SentenceInclude<ExtArgs> | null
    /**
     * Filter, which Sentences to fetch.
     */
    where?: SentenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sentences to fetch.
     */
    orderBy?: SentenceOrderByWithRelationInput | SentenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sentences.
     */
    cursor?: SentenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sentences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sentences.
     */
    skip?: number
    distinct?: SentenceScalarFieldEnum | SentenceScalarFieldEnum[]
  }


  /**
   * Sentence create
   */
  ;export  type SentenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sentence
     */
    select?: SentenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SentenceInclude<ExtArgs> | null
    /**
     * The data needed to create a Sentence.
     */
    data: XOR<SentenceCreateInput, SentenceUncheckedCreateInput>
  }


  /**
   * Sentence createMany
   */
  ;export  type SentenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sentences.
     */
    data: SentenceCreateManyInput | SentenceCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Sentence update
   */
  ;export  type SentenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sentence
     */
    select?: SentenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SentenceInclude<ExtArgs> | null
    /**
     * The data needed to update a Sentence.
     */
    data: XOR<SentenceUpdateInput, SentenceUncheckedUpdateInput>
    /**
     * Choose, which Sentence to update.
     */
    where: SentenceWhereUniqueInput
  }


  /**
   * Sentence updateMany
   */
  ;export  type SentenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sentences.
     */
    data: XOR<SentenceUpdateManyMutationInput, SentenceUncheckedUpdateManyInput>
    /**
     * Filter which Sentences to update
     */
    where?: SentenceWhereInput
  }


  /**
   * Sentence upsert
   */
  ;export  type SentenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sentence
     */
    select?: SentenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SentenceInclude<ExtArgs> | null
    /**
     * The filter to search for the Sentence to update in case it exists.
     */
    where: SentenceWhereUniqueInput
    /**
     * In case the Sentence found by the `where` argument doesn't exist, create a new Sentence with this data.
     */
    create: XOR<SentenceCreateInput, SentenceUncheckedCreateInput>
    /**
     * In case the Sentence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SentenceUpdateInput, SentenceUncheckedUpdateInput>
  }


  /**
   * Sentence delete
   */
  ;export  type SentenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sentence
     */
    select?: SentenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SentenceInclude<ExtArgs> | null
    /**
     * Filter which Sentence to delete.
     */
    where: SentenceWhereUniqueInput
  }


  /**
   * Sentence deleteMany
   */
  ;export  type SentenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sentences to delete
     */
    where?: SentenceWhereInput
  }


  /**
   * Sentence without action
   */
  ;export  type SentenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sentence
     */
    select?: SentenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SentenceInclude<ExtArgs> | null
  }



  /**
   * Model User
   */

  ;export  type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  ;export  type UserMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  ;export  type UserMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  ;export  type UserCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  ;export  type UserMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  ;export  type UserMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  ;export  type UserCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  ;export  type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  ;export  type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  ;export  type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  ;export  type UserGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  ;export  type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    words?: boolean | User$wordsArgs<ExtArgs>
    meanings?: boolean | User$meaningsArgs<ExtArgs>
    UsersOnWordLists?: boolean | User$UsersOnWordListsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  ;export  type UserSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  ;export  type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    words?: boolean | User$wordsArgs<ExtArgs>
    meanings?: boolean | User$meaningsArgs<ExtArgs>
    UsersOnWordLists?: boolean | User$UsersOnWordListsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  ;export  type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      words: Prisma.$UsersOnWordsPayload<ExtArgs>[]
      meanings: Prisma.$UsersOnMeaningsPayload<ExtArgs>[]
      UsersOnWordLists: Prisma.$UsersOnWordListsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  ;export  interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  ;export  interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    words<T extends User$wordsArgs<ExtArgs> = {}>(args?: Subset<T, User$wordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersOnWordsPayload<ExtArgs>, T, 'findMany'> | Null>;

    meanings<T extends User$meaningsArgs<ExtArgs> = {}>(args?: Subset<T, User$meaningsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersOnMeaningsPayload<ExtArgs>, T, 'findMany'> | Null>;

    UsersOnWordLists<T extends User$UsersOnWordListsArgs<ExtArgs> = {}>(args?: Subset<T, User$UsersOnWordListsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersOnWordListsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  ;export  type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  ;export  type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  ;export  type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  ;export  type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  ;export  type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  ;export  type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  ;export  type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  ;export  type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  ;export  type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  ;export  type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  ;export  type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  ;export  type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.words
   */
  ;export  type User$wordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnWords
     */
    select?: UsersOnWordsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersOnWordsInclude<ExtArgs> | null
    where?: UsersOnWordsWhereInput
    orderBy?: UsersOnWordsOrderByWithRelationInput | UsersOnWordsOrderByWithRelationInput[]
    cursor?: UsersOnWordsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersOnWordsScalarFieldEnum | UsersOnWordsScalarFieldEnum[]
  }


  /**
   * User.meanings
   */
  ;export  type User$meaningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnMeanings
     */
    select?: UsersOnMeaningsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersOnMeaningsInclude<ExtArgs> | null
    where?: UsersOnMeaningsWhereInput
    orderBy?: UsersOnMeaningsOrderByWithRelationInput | UsersOnMeaningsOrderByWithRelationInput[]
    cursor?: UsersOnMeaningsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersOnMeaningsScalarFieldEnum | UsersOnMeaningsScalarFieldEnum[]
  }


  /**
   * User.UsersOnWordLists
   */
  ;export  type User$UsersOnWordListsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnWordLists
     */
    select?: UsersOnWordListsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersOnWordListsInclude<ExtArgs> | null
    where?: UsersOnWordListsWhereInput
    orderBy?: UsersOnWordListsOrderByWithRelationInput | UsersOnWordListsOrderByWithRelationInput[]
    cursor?: UsersOnWordListsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersOnWordListsScalarFieldEnum | UsersOnWordListsScalarFieldEnum[]
  }


  /**
   * User without action
   */
  ;export  type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model UsersOnWords
   */

  ;export  type AggregateUsersOnWords = {
    _count: UsersOnWordsCountAggregateOutputType | null
    _avg: UsersOnWordsAvgAggregateOutputType | null
    _sum: UsersOnWordsSumAggregateOutputType | null
    _min: UsersOnWordsMinAggregateOutputType | null
    _max: UsersOnWordsMaxAggregateOutputType | null
  }

  ;export  type UsersOnWordsAvgAggregateOutputType = {
    level: number | null
    timeQuotient: number | null
  }

  ;export  type UsersOnWordsSumAggregateOutputType = {
    level: number | null
    timeQuotient: number | null
  }

  ;export  type UsersOnWordsMinAggregateOutputType = {
    userId: string | null
    wordId: string | null
    level: number | null
    lastTimeRecalledCorrectly: Date | null
    timeQuotient: number | null
  }

  ;export  type UsersOnWordsMaxAggregateOutputType = {
    userId: string | null
    wordId: string | null
    level: number | null
    lastTimeRecalledCorrectly: Date | null
    timeQuotient: number | null
  }

  ;export  type UsersOnWordsCountAggregateOutputType = {
    userId: number
    wordId: number
    level: number
    lastTimeRecalledCorrectly: number
    timeQuotient: number
    _all: number
  }


  ;export  type UsersOnWordsAvgAggregateInputType = {
    level?: true
    timeQuotient?: true
  }

  ;export  type UsersOnWordsSumAggregateInputType = {
    level?: true
    timeQuotient?: true
  }

  ;export  type UsersOnWordsMinAggregateInputType = {
    userId?: true
    wordId?: true
    level?: true
    lastTimeRecalledCorrectly?: true
    timeQuotient?: true
  }

  ;export  type UsersOnWordsMaxAggregateInputType = {
    userId?: true
    wordId?: true
    level?: true
    lastTimeRecalledCorrectly?: true
    timeQuotient?: true
  }

  ;export  type UsersOnWordsCountAggregateInputType = {
    userId?: true
    wordId?: true
    level?: true
    lastTimeRecalledCorrectly?: true
    timeQuotient?: true
    _all?: true
  }

  ;export  type UsersOnWordsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsersOnWords to aggregate.
     */
    where?: UsersOnWordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersOnWords to fetch.
     */
    orderBy?: UsersOnWordsOrderByWithRelationInput | UsersOnWordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersOnWordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersOnWords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersOnWords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsersOnWords
    **/
    _count?: true | UsersOnWordsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersOnWordsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersOnWordsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersOnWordsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersOnWordsMaxAggregateInputType
  }

  ;export  type GetUsersOnWordsAggregateType<T extends UsersOnWordsAggregateArgs> = {
        [P in keyof T & keyof AggregateUsersOnWords]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsersOnWords[P]>
      : GetScalarType<T[P], AggregateUsersOnWords[P]>
  }




  ;export  type UsersOnWordsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersOnWordsWhereInput
    orderBy?: UsersOnWordsOrderByWithAggregationInput | UsersOnWordsOrderByWithAggregationInput[]
    by: UsersOnWordsScalarFieldEnum[] | UsersOnWordsScalarFieldEnum
    having?: UsersOnWordsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersOnWordsCountAggregateInputType | true
    _avg?: UsersOnWordsAvgAggregateInputType
    _sum?: UsersOnWordsSumAggregateInputType
    _min?: UsersOnWordsMinAggregateInputType
    _max?: UsersOnWordsMaxAggregateInputType
  }

  ;export  type UsersOnWordsGroupByOutputType = {
    userId: string
    wordId: string
    level: number
    lastTimeRecalledCorrectly: Date
    timeQuotient: number
    _count: UsersOnWordsCountAggregateOutputType | null
    _avg: UsersOnWordsAvgAggregateOutputType | null
    _sum: UsersOnWordsSumAggregateOutputType | null
    _min: UsersOnWordsMinAggregateOutputType | null
    _max: UsersOnWordsMaxAggregateOutputType | null
  }

  type GetUsersOnWordsGroupByPayload<T extends UsersOnWordsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersOnWordsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersOnWordsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersOnWordsGroupByOutputType[P]>
            : GetScalarType<T[P], UsersOnWordsGroupByOutputType[P]>
        }
      >
    >


  ;export  type UsersOnWordsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    wordId?: boolean
    level?: boolean
    lastTimeRecalledCorrectly?: boolean
    timeQuotient?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    word?: boolean | WordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usersOnWords"]>

  ;export  type UsersOnWordsSelectScalar = {
    userId?: boolean
    wordId?: boolean
    level?: boolean
    lastTimeRecalledCorrectly?: boolean
    timeQuotient?: boolean
  }

  ;export  type UsersOnWordsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    word?: boolean | WordDefaultArgs<ExtArgs>
  }


  ;export  type $UsersOnWordsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsersOnWords"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      word: Prisma.$WordPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      wordId: string
      level: number
      lastTimeRecalledCorrectly: Date
      timeQuotient: number
    }, ExtArgs["result"]["usersOnWords"]>
    composites: {}
  }


  type UsersOnWordsGetPayload<S extends boolean | null | undefined | UsersOnWordsDefaultArgs> = $Result.GetResult<Prisma.$UsersOnWordsPayload, S>

  type UsersOnWordsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsersOnWordsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersOnWordsCountAggregateInputType | true
    }

  ;export  interface UsersOnWordsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsersOnWords'], meta: { name: 'UsersOnWords' } }
    /**
     * Find zero or one UsersOnWords that matches the filter.
     * @param {UsersOnWordsFindUniqueArgs} args - Arguments to find a UsersOnWords
     * @example
     * // Get one UsersOnWords
     * const usersOnWords = await prisma.usersOnWords.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UsersOnWordsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UsersOnWordsFindUniqueArgs<ExtArgs>>
    ): Prisma__UsersOnWordsClient<$Result.GetResult<Prisma.$UsersOnWordsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UsersOnWords that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UsersOnWordsFindUniqueOrThrowArgs} args - Arguments to find a UsersOnWords
     * @example
     * // Get one UsersOnWords
     * const usersOnWords = await prisma.usersOnWords.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UsersOnWordsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersOnWordsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UsersOnWordsClient<$Result.GetResult<Prisma.$UsersOnWordsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UsersOnWords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersOnWordsFindFirstArgs} args - Arguments to find a UsersOnWords
     * @example
     * // Get one UsersOnWords
     * const usersOnWords = await prisma.usersOnWords.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UsersOnWordsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersOnWordsFindFirstArgs<ExtArgs>>
    ): Prisma__UsersOnWordsClient<$Result.GetResult<Prisma.$UsersOnWordsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UsersOnWords that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersOnWordsFindFirstOrThrowArgs} args - Arguments to find a UsersOnWords
     * @example
     * // Get one UsersOnWords
     * const usersOnWords = await prisma.usersOnWords.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UsersOnWordsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersOnWordsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UsersOnWordsClient<$Result.GetResult<Prisma.$UsersOnWordsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UsersOnWords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersOnWordsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsersOnWords
     * const usersOnWords = await prisma.usersOnWords.findMany()
     * 
     * // Get first 10 UsersOnWords
     * const usersOnWords = await prisma.usersOnWords.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const usersOnWordsWithUserIdOnly = await prisma.usersOnWords.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends UsersOnWordsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersOnWordsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersOnWordsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UsersOnWords.
     * @param {UsersOnWordsCreateArgs} args - Arguments to create a UsersOnWords.
     * @example
     * // Create one UsersOnWords
     * const UsersOnWords = await prisma.usersOnWords.create({
     *   data: {
     *     // ... data to create a UsersOnWords
     *   }
     * })
     * 
    **/
    create<T extends UsersOnWordsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UsersOnWordsCreateArgs<ExtArgs>>
    ): Prisma__UsersOnWordsClient<$Result.GetResult<Prisma.$UsersOnWordsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UsersOnWords.
     *     @param {UsersOnWordsCreateManyArgs} args - Arguments to create many UsersOnWords.
     *     @example
     *     // Create many UsersOnWords
     *     const usersOnWords = await prisma.usersOnWords.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UsersOnWordsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersOnWordsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UsersOnWords.
     * @param {UsersOnWordsDeleteArgs} args - Arguments to delete one UsersOnWords.
     * @example
     * // Delete one UsersOnWords
     * const UsersOnWords = await prisma.usersOnWords.delete({
     *   where: {
     *     // ... filter to delete one UsersOnWords
     *   }
     * })
     * 
    **/
    delete<T extends UsersOnWordsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UsersOnWordsDeleteArgs<ExtArgs>>
    ): Prisma__UsersOnWordsClient<$Result.GetResult<Prisma.$UsersOnWordsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UsersOnWords.
     * @param {UsersOnWordsUpdateArgs} args - Arguments to update one UsersOnWords.
     * @example
     * // Update one UsersOnWords
     * const usersOnWords = await prisma.usersOnWords.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UsersOnWordsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UsersOnWordsUpdateArgs<ExtArgs>>
    ): Prisma__UsersOnWordsClient<$Result.GetResult<Prisma.$UsersOnWordsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UsersOnWords.
     * @param {UsersOnWordsDeleteManyArgs} args - Arguments to filter UsersOnWords to delete.
     * @example
     * // Delete a few UsersOnWords
     * const { count } = await prisma.usersOnWords.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UsersOnWordsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersOnWordsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsersOnWords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersOnWordsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsersOnWords
     * const usersOnWords = await prisma.usersOnWords.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UsersOnWordsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UsersOnWordsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UsersOnWords.
     * @param {UsersOnWordsUpsertArgs} args - Arguments to update or create a UsersOnWords.
     * @example
     * // Update or create a UsersOnWords
     * const usersOnWords = await prisma.usersOnWords.upsert({
     *   create: {
     *     // ... data to create a UsersOnWords
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsersOnWords we want to update
     *   }
     * })
    **/
    upsert<T extends UsersOnWordsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UsersOnWordsUpsertArgs<ExtArgs>>
    ): Prisma__UsersOnWordsClient<$Result.GetResult<Prisma.$UsersOnWordsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UsersOnWords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersOnWordsCountArgs} args - Arguments to filter UsersOnWords to count.
     * @example
     * // Count the number of UsersOnWords
     * const count = await prisma.usersOnWords.count({
     *   where: {
     *     // ... the filter for the UsersOnWords we want to count
     *   }
     * })
    **/
    count<T extends UsersOnWordsCountArgs>(
      args?: Subset<T, UsersOnWordsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersOnWordsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsersOnWords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersOnWordsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersOnWordsAggregateArgs>(args: Subset<T, UsersOnWordsAggregateArgs>): Prisma.PrismaPromise<GetUsersOnWordsAggregateType<T>>

    /**
     * Group by UsersOnWords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersOnWordsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersOnWordsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersOnWordsGroupByArgs['orderBy'] }
        : { orderBy?: UsersOnWordsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersOnWordsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersOnWordsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsersOnWords model
   */
  readonly fields: UsersOnWordsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsersOnWords.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  ;export  interface Prisma__UsersOnWordsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    word<T extends WordDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WordDefaultArgs<ExtArgs>>): Prisma__WordClient<$Result.GetResult<Prisma.$WordPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the UsersOnWords model
   */ 
  interface UsersOnWordsFieldRefs {
    readonly userId: FieldRef<"UsersOnWords", 'String'>
    readonly wordId: FieldRef<"UsersOnWords", 'String'>
    readonly level: FieldRef<"UsersOnWords", 'Int'>
    readonly lastTimeRecalledCorrectly: FieldRef<"UsersOnWords", 'DateTime'>
    readonly timeQuotient: FieldRef<"UsersOnWords", 'Float'>
  }
    

  // Custom InputTypes

  /**
   * UsersOnWords findUnique
   */
  ;export  type UsersOnWordsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnWords
     */
    select?: UsersOnWordsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersOnWordsInclude<ExtArgs> | null
    /**
     * Filter, which UsersOnWords to fetch.
     */
    where: UsersOnWordsWhereUniqueInput
  }


  /**
   * UsersOnWords findUniqueOrThrow
   */
  ;export  type UsersOnWordsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnWords
     */
    select?: UsersOnWordsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersOnWordsInclude<ExtArgs> | null
    /**
     * Filter, which UsersOnWords to fetch.
     */
    where: UsersOnWordsWhereUniqueInput
  }


  /**
   * UsersOnWords findFirst
   */
  ;export  type UsersOnWordsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnWords
     */
    select?: UsersOnWordsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersOnWordsInclude<ExtArgs> | null
    /**
     * Filter, which UsersOnWords to fetch.
     */
    where?: UsersOnWordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersOnWords to fetch.
     */
    orderBy?: UsersOnWordsOrderByWithRelationInput | UsersOnWordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsersOnWords.
     */
    cursor?: UsersOnWordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersOnWords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersOnWords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsersOnWords.
     */
    distinct?: UsersOnWordsScalarFieldEnum | UsersOnWordsScalarFieldEnum[]
  }


  /**
   * UsersOnWords findFirstOrThrow
   */
  ;export  type UsersOnWordsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnWords
     */
    select?: UsersOnWordsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersOnWordsInclude<ExtArgs> | null
    /**
     * Filter, which UsersOnWords to fetch.
     */
    where?: UsersOnWordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersOnWords to fetch.
     */
    orderBy?: UsersOnWordsOrderByWithRelationInput | UsersOnWordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsersOnWords.
     */
    cursor?: UsersOnWordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersOnWords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersOnWords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsersOnWords.
     */
    distinct?: UsersOnWordsScalarFieldEnum | UsersOnWordsScalarFieldEnum[]
  }


  /**
   * UsersOnWords findMany
   */
  ;export  type UsersOnWordsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnWords
     */
    select?: UsersOnWordsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersOnWordsInclude<ExtArgs> | null
    /**
     * Filter, which UsersOnWords to fetch.
     */
    where?: UsersOnWordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersOnWords to fetch.
     */
    orderBy?: UsersOnWordsOrderByWithRelationInput | UsersOnWordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsersOnWords.
     */
    cursor?: UsersOnWordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersOnWords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersOnWords.
     */
    skip?: number
    distinct?: UsersOnWordsScalarFieldEnum | UsersOnWordsScalarFieldEnum[]
  }


  /**
   * UsersOnWords create
   */
  ;export  type UsersOnWordsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnWords
     */
    select?: UsersOnWordsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersOnWordsInclude<ExtArgs> | null
    /**
     * The data needed to create a UsersOnWords.
     */
    data: XOR<UsersOnWordsCreateInput, UsersOnWordsUncheckedCreateInput>
  }


  /**
   * UsersOnWords createMany
   */
  ;export  type UsersOnWordsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsersOnWords.
     */
    data: UsersOnWordsCreateManyInput | UsersOnWordsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * UsersOnWords update
   */
  ;export  type UsersOnWordsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnWords
     */
    select?: UsersOnWordsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersOnWordsInclude<ExtArgs> | null
    /**
     * The data needed to update a UsersOnWords.
     */
    data: XOR<UsersOnWordsUpdateInput, UsersOnWordsUncheckedUpdateInput>
    /**
     * Choose, which UsersOnWords to update.
     */
    where: UsersOnWordsWhereUniqueInput
  }


  /**
   * UsersOnWords updateMany
   */
  ;export  type UsersOnWordsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsersOnWords.
     */
    data: XOR<UsersOnWordsUpdateManyMutationInput, UsersOnWordsUncheckedUpdateManyInput>
    /**
     * Filter which UsersOnWords to update
     */
    where?: UsersOnWordsWhereInput
  }


  /**
   * UsersOnWords upsert
   */
  ;export  type UsersOnWordsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnWords
     */
    select?: UsersOnWordsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersOnWordsInclude<ExtArgs> | null
    /**
     * The filter to search for the UsersOnWords to update in case it exists.
     */
    where: UsersOnWordsWhereUniqueInput
    /**
     * In case the UsersOnWords found by the `where` argument doesn't exist, create a new UsersOnWords with this data.
     */
    create: XOR<UsersOnWordsCreateInput, UsersOnWordsUncheckedCreateInput>
    /**
     * In case the UsersOnWords was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersOnWordsUpdateInput, UsersOnWordsUncheckedUpdateInput>
  }


  /**
   * UsersOnWords delete
   */
  ;export  type UsersOnWordsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnWords
     */
    select?: UsersOnWordsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersOnWordsInclude<ExtArgs> | null
    /**
     * Filter which UsersOnWords to delete.
     */
    where: UsersOnWordsWhereUniqueInput
  }


  /**
   * UsersOnWords deleteMany
   */
  ;export  type UsersOnWordsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsersOnWords to delete
     */
    where?: UsersOnWordsWhereInput
  }


  /**
   * UsersOnWords without action
   */
  ;export  type UsersOnWordsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnWords
     */
    select?: UsersOnWordsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersOnWordsInclude<ExtArgs> | null
  }



  /**
   * Model UsersOnMeanings
   */

  ;export  type AggregateUsersOnMeanings = {
    _count: UsersOnMeaningsCountAggregateOutputType | null
    _min: UsersOnMeaningsMinAggregateOutputType | null
    _max: UsersOnMeaningsMaxAggregateOutputType | null
  }

  ;export  type UsersOnMeaningsMinAggregateOutputType = {
    userId: string | null
    meaningId: string | null
    relation: $Enums.UserMeaningRelation | null
  }

  ;export  type UsersOnMeaningsMaxAggregateOutputType = {
    userId: string | null
    meaningId: string | null
    relation: $Enums.UserMeaningRelation | null
  }

  ;export  type UsersOnMeaningsCountAggregateOutputType = {
    userId: number
    meaningId: number
    relation: number
    _all: number
  }


  ;export  type UsersOnMeaningsMinAggregateInputType = {
    userId?: true
    meaningId?: true
    relation?: true
  }

  ;export  type UsersOnMeaningsMaxAggregateInputType = {
    userId?: true
    meaningId?: true
    relation?: true
  }

  ;export  type UsersOnMeaningsCountAggregateInputType = {
    userId?: true
    meaningId?: true
    relation?: true
    _all?: true
  }

  ;export  type UsersOnMeaningsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsersOnMeanings to aggregate.
     */
    where?: UsersOnMeaningsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersOnMeanings to fetch.
     */
    orderBy?: UsersOnMeaningsOrderByWithRelationInput | UsersOnMeaningsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersOnMeaningsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersOnMeanings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersOnMeanings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsersOnMeanings
    **/
    _count?: true | UsersOnMeaningsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersOnMeaningsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersOnMeaningsMaxAggregateInputType
  }

  ;export  type GetUsersOnMeaningsAggregateType<T extends UsersOnMeaningsAggregateArgs> = {
        [P in keyof T & keyof AggregateUsersOnMeanings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsersOnMeanings[P]>
      : GetScalarType<T[P], AggregateUsersOnMeanings[P]>
  }




  ;export  type UsersOnMeaningsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersOnMeaningsWhereInput
    orderBy?: UsersOnMeaningsOrderByWithAggregationInput | UsersOnMeaningsOrderByWithAggregationInput[]
    by: UsersOnMeaningsScalarFieldEnum[] | UsersOnMeaningsScalarFieldEnum
    having?: UsersOnMeaningsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersOnMeaningsCountAggregateInputType | true
    _min?: UsersOnMeaningsMinAggregateInputType
    _max?: UsersOnMeaningsMaxAggregateInputType
  }

  ;export  type UsersOnMeaningsGroupByOutputType = {
    userId: string
    meaningId: string
    relation: $Enums.UserMeaningRelation
    _count: UsersOnMeaningsCountAggregateOutputType | null
    _min: UsersOnMeaningsMinAggregateOutputType | null
    _max: UsersOnMeaningsMaxAggregateOutputType | null
  }

  type GetUsersOnMeaningsGroupByPayload<T extends UsersOnMeaningsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersOnMeaningsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersOnMeaningsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersOnMeaningsGroupByOutputType[P]>
            : GetScalarType<T[P], UsersOnMeaningsGroupByOutputType[P]>
        }
      >
    >


  ;export  type UsersOnMeaningsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    meaningId?: boolean
    relation?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    meaning?: boolean | MeaningDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usersOnMeanings"]>

  ;export  type UsersOnMeaningsSelectScalar = {
    userId?: boolean
    meaningId?: boolean
    relation?: boolean
  }

  ;export  type UsersOnMeaningsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    meaning?: boolean | MeaningDefaultArgs<ExtArgs>
  }


  ;export  type $UsersOnMeaningsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsersOnMeanings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      meaning: Prisma.$MeaningPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      meaningId: string
      relation: $Enums.UserMeaningRelation
    }, ExtArgs["result"]["usersOnMeanings"]>
    composites: {}
  }


  type UsersOnMeaningsGetPayload<S extends boolean | null | undefined | UsersOnMeaningsDefaultArgs> = $Result.GetResult<Prisma.$UsersOnMeaningsPayload, S>

  type UsersOnMeaningsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsersOnMeaningsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersOnMeaningsCountAggregateInputType | true
    }

  ;export  interface UsersOnMeaningsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsersOnMeanings'], meta: { name: 'UsersOnMeanings' } }
    /**
     * Find zero or one UsersOnMeanings that matches the filter.
     * @param {UsersOnMeaningsFindUniqueArgs} args - Arguments to find a UsersOnMeanings
     * @example
     * // Get one UsersOnMeanings
     * const usersOnMeanings = await prisma.usersOnMeanings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UsersOnMeaningsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UsersOnMeaningsFindUniqueArgs<ExtArgs>>
    ): Prisma__UsersOnMeaningsClient<$Result.GetResult<Prisma.$UsersOnMeaningsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UsersOnMeanings that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UsersOnMeaningsFindUniqueOrThrowArgs} args - Arguments to find a UsersOnMeanings
     * @example
     * // Get one UsersOnMeanings
     * const usersOnMeanings = await prisma.usersOnMeanings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UsersOnMeaningsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersOnMeaningsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UsersOnMeaningsClient<$Result.GetResult<Prisma.$UsersOnMeaningsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UsersOnMeanings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersOnMeaningsFindFirstArgs} args - Arguments to find a UsersOnMeanings
     * @example
     * // Get one UsersOnMeanings
     * const usersOnMeanings = await prisma.usersOnMeanings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UsersOnMeaningsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersOnMeaningsFindFirstArgs<ExtArgs>>
    ): Prisma__UsersOnMeaningsClient<$Result.GetResult<Prisma.$UsersOnMeaningsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UsersOnMeanings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersOnMeaningsFindFirstOrThrowArgs} args - Arguments to find a UsersOnMeanings
     * @example
     * // Get one UsersOnMeanings
     * const usersOnMeanings = await prisma.usersOnMeanings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UsersOnMeaningsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersOnMeaningsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UsersOnMeaningsClient<$Result.GetResult<Prisma.$UsersOnMeaningsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UsersOnMeanings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersOnMeaningsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsersOnMeanings
     * const usersOnMeanings = await prisma.usersOnMeanings.findMany()
     * 
     * // Get first 10 UsersOnMeanings
     * const usersOnMeanings = await prisma.usersOnMeanings.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const usersOnMeaningsWithUserIdOnly = await prisma.usersOnMeanings.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends UsersOnMeaningsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersOnMeaningsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersOnMeaningsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UsersOnMeanings.
     * @param {UsersOnMeaningsCreateArgs} args - Arguments to create a UsersOnMeanings.
     * @example
     * // Create one UsersOnMeanings
     * const UsersOnMeanings = await prisma.usersOnMeanings.create({
     *   data: {
     *     // ... data to create a UsersOnMeanings
     *   }
     * })
     * 
    **/
    create<T extends UsersOnMeaningsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UsersOnMeaningsCreateArgs<ExtArgs>>
    ): Prisma__UsersOnMeaningsClient<$Result.GetResult<Prisma.$UsersOnMeaningsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UsersOnMeanings.
     *     @param {UsersOnMeaningsCreateManyArgs} args - Arguments to create many UsersOnMeanings.
     *     @example
     *     // Create many UsersOnMeanings
     *     const usersOnMeanings = await prisma.usersOnMeanings.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UsersOnMeaningsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersOnMeaningsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UsersOnMeanings.
     * @param {UsersOnMeaningsDeleteArgs} args - Arguments to delete one UsersOnMeanings.
     * @example
     * // Delete one UsersOnMeanings
     * const UsersOnMeanings = await prisma.usersOnMeanings.delete({
     *   where: {
     *     // ... filter to delete one UsersOnMeanings
     *   }
     * })
     * 
    **/
    delete<T extends UsersOnMeaningsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UsersOnMeaningsDeleteArgs<ExtArgs>>
    ): Prisma__UsersOnMeaningsClient<$Result.GetResult<Prisma.$UsersOnMeaningsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UsersOnMeanings.
     * @param {UsersOnMeaningsUpdateArgs} args - Arguments to update one UsersOnMeanings.
     * @example
     * // Update one UsersOnMeanings
     * const usersOnMeanings = await prisma.usersOnMeanings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UsersOnMeaningsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UsersOnMeaningsUpdateArgs<ExtArgs>>
    ): Prisma__UsersOnMeaningsClient<$Result.GetResult<Prisma.$UsersOnMeaningsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UsersOnMeanings.
     * @param {UsersOnMeaningsDeleteManyArgs} args - Arguments to filter UsersOnMeanings to delete.
     * @example
     * // Delete a few UsersOnMeanings
     * const { count } = await prisma.usersOnMeanings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UsersOnMeaningsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersOnMeaningsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsersOnMeanings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersOnMeaningsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsersOnMeanings
     * const usersOnMeanings = await prisma.usersOnMeanings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UsersOnMeaningsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UsersOnMeaningsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UsersOnMeanings.
     * @param {UsersOnMeaningsUpsertArgs} args - Arguments to update or create a UsersOnMeanings.
     * @example
     * // Update or create a UsersOnMeanings
     * const usersOnMeanings = await prisma.usersOnMeanings.upsert({
     *   create: {
     *     // ... data to create a UsersOnMeanings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsersOnMeanings we want to update
     *   }
     * })
    **/
    upsert<T extends UsersOnMeaningsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UsersOnMeaningsUpsertArgs<ExtArgs>>
    ): Prisma__UsersOnMeaningsClient<$Result.GetResult<Prisma.$UsersOnMeaningsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UsersOnMeanings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersOnMeaningsCountArgs} args - Arguments to filter UsersOnMeanings to count.
     * @example
     * // Count the number of UsersOnMeanings
     * const count = await prisma.usersOnMeanings.count({
     *   where: {
     *     // ... the filter for the UsersOnMeanings we want to count
     *   }
     * })
    **/
    count<T extends UsersOnMeaningsCountArgs>(
      args?: Subset<T, UsersOnMeaningsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersOnMeaningsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsersOnMeanings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersOnMeaningsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersOnMeaningsAggregateArgs>(args: Subset<T, UsersOnMeaningsAggregateArgs>): Prisma.PrismaPromise<GetUsersOnMeaningsAggregateType<T>>

    /**
     * Group by UsersOnMeanings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersOnMeaningsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersOnMeaningsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersOnMeaningsGroupByArgs['orderBy'] }
        : { orderBy?: UsersOnMeaningsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersOnMeaningsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersOnMeaningsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsersOnMeanings model
   */
  readonly fields: UsersOnMeaningsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsersOnMeanings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  ;export  interface Prisma__UsersOnMeaningsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    meaning<T extends MeaningDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MeaningDefaultArgs<ExtArgs>>): Prisma__MeaningClient<$Result.GetResult<Prisma.$MeaningPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the UsersOnMeanings model
   */ 
  interface UsersOnMeaningsFieldRefs {
    readonly userId: FieldRef<"UsersOnMeanings", 'String'>
    readonly meaningId: FieldRef<"UsersOnMeanings", 'String'>
    readonly relation: FieldRef<"UsersOnMeanings", 'UserMeaningRelation'>
  }
    

  // Custom InputTypes

  /**
   * UsersOnMeanings findUnique
   */
  ;export  type UsersOnMeaningsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnMeanings
     */
    select?: UsersOnMeaningsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersOnMeaningsInclude<ExtArgs> | null
    /**
     * Filter, which UsersOnMeanings to fetch.
     */
    where: UsersOnMeaningsWhereUniqueInput
  }


  /**
   * UsersOnMeanings findUniqueOrThrow
   */
  ;export  type UsersOnMeaningsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnMeanings
     */
    select?: UsersOnMeaningsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersOnMeaningsInclude<ExtArgs> | null
    /**
     * Filter, which UsersOnMeanings to fetch.
     */
    where: UsersOnMeaningsWhereUniqueInput
  }


  /**
   * UsersOnMeanings findFirst
   */
  ;export  type UsersOnMeaningsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnMeanings
     */
    select?: UsersOnMeaningsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersOnMeaningsInclude<ExtArgs> | null
    /**
     * Filter, which UsersOnMeanings to fetch.
     */
    where?: UsersOnMeaningsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersOnMeanings to fetch.
     */
    orderBy?: UsersOnMeaningsOrderByWithRelationInput | UsersOnMeaningsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsersOnMeanings.
     */
    cursor?: UsersOnMeaningsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersOnMeanings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersOnMeanings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsersOnMeanings.
     */
    distinct?: UsersOnMeaningsScalarFieldEnum | UsersOnMeaningsScalarFieldEnum[]
  }


  /**
   * UsersOnMeanings findFirstOrThrow
   */
  ;export  type UsersOnMeaningsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnMeanings
     */
    select?: UsersOnMeaningsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersOnMeaningsInclude<ExtArgs> | null
    /**
     * Filter, which UsersOnMeanings to fetch.
     */
    where?: UsersOnMeaningsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersOnMeanings to fetch.
     */
    orderBy?: UsersOnMeaningsOrderByWithRelationInput | UsersOnMeaningsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsersOnMeanings.
     */
    cursor?: UsersOnMeaningsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersOnMeanings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersOnMeanings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsersOnMeanings.
     */
    distinct?: UsersOnMeaningsScalarFieldEnum | UsersOnMeaningsScalarFieldEnum[]
  }


  /**
   * UsersOnMeanings findMany
   */
  ;export  type UsersOnMeaningsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnMeanings
     */
    select?: UsersOnMeaningsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersOnMeaningsInclude<ExtArgs> | null
    /**
     * Filter, which UsersOnMeanings to fetch.
     */
    where?: UsersOnMeaningsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersOnMeanings to fetch.
     */
    orderBy?: UsersOnMeaningsOrderByWithRelationInput | UsersOnMeaningsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsersOnMeanings.
     */
    cursor?: UsersOnMeaningsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersOnMeanings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersOnMeanings.
     */
    skip?: number
    distinct?: UsersOnMeaningsScalarFieldEnum | UsersOnMeaningsScalarFieldEnum[]
  }


  /**
   * UsersOnMeanings create
   */
  ;export  type UsersOnMeaningsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnMeanings
     */
    select?: UsersOnMeaningsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersOnMeaningsInclude<ExtArgs> | null
    /**
     * The data needed to create a UsersOnMeanings.
     */
    data: XOR<UsersOnMeaningsCreateInput, UsersOnMeaningsUncheckedCreateInput>
  }


  /**
   * UsersOnMeanings createMany
   */
  ;export  type UsersOnMeaningsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsersOnMeanings.
     */
    data: UsersOnMeaningsCreateManyInput | UsersOnMeaningsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * UsersOnMeanings update
   */
  ;export  type UsersOnMeaningsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnMeanings
     */
    select?: UsersOnMeaningsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersOnMeaningsInclude<ExtArgs> | null
    /**
     * The data needed to update a UsersOnMeanings.
     */
    data: XOR<UsersOnMeaningsUpdateInput, UsersOnMeaningsUncheckedUpdateInput>
    /**
     * Choose, which UsersOnMeanings to update.
     */
    where: UsersOnMeaningsWhereUniqueInput
  }


  /**
   * UsersOnMeanings updateMany
   */
  ;export  type UsersOnMeaningsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsersOnMeanings.
     */
    data: XOR<UsersOnMeaningsUpdateManyMutationInput, UsersOnMeaningsUncheckedUpdateManyInput>
    /**
     * Filter which UsersOnMeanings to update
     */
    where?: UsersOnMeaningsWhereInput
  }


  /**
   * UsersOnMeanings upsert
   */
  ;export  type UsersOnMeaningsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnMeanings
     */
    select?: UsersOnMeaningsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersOnMeaningsInclude<ExtArgs> | null
    /**
     * The filter to search for the UsersOnMeanings to update in case it exists.
     */
    where: UsersOnMeaningsWhereUniqueInput
    /**
     * In case the UsersOnMeanings found by the `where` argument doesn't exist, create a new UsersOnMeanings with this data.
     */
    create: XOR<UsersOnMeaningsCreateInput, UsersOnMeaningsUncheckedCreateInput>
    /**
     * In case the UsersOnMeanings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersOnMeaningsUpdateInput, UsersOnMeaningsUncheckedUpdateInput>
  }


  /**
   * UsersOnMeanings delete
   */
  ;export  type UsersOnMeaningsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnMeanings
     */
    select?: UsersOnMeaningsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersOnMeaningsInclude<ExtArgs> | null
    /**
     * Filter which UsersOnMeanings to delete.
     */
    where: UsersOnMeaningsWhereUniqueInput
  }


  /**
   * UsersOnMeanings deleteMany
   */
  ;export  type UsersOnMeaningsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsersOnMeanings to delete
     */
    where?: UsersOnMeaningsWhereInput
  }


  /**
   * UsersOnMeanings without action
   */
  ;export  type UsersOnMeaningsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnMeanings
     */
    select?: UsersOnMeaningsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersOnMeaningsInclude<ExtArgs> | null
  }



  /**
   * Model WordList
   */

  ;export  type AggregateWordList = {
    _count: WordListCountAggregateOutputType | null
    _min: WordListMinAggregateOutputType | null
    _max: WordListMaxAggregateOutputType | null
  }

  ;export  type WordListMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  ;export  type WordListMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  ;export  type WordListCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  ;export  type WordListMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  ;export  type WordListMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  ;export  type WordListCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  ;export  type WordListAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WordList to aggregate.
     */
    where?: WordListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WordLists to fetch.
     */
    orderBy?: WordListOrderByWithRelationInput | WordListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WordListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WordLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WordLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WordLists
    **/
    _count?: true | WordListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WordListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WordListMaxAggregateInputType
  }

  ;export  type GetWordListAggregateType<T extends WordListAggregateArgs> = {
        [P in keyof T & keyof AggregateWordList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWordList[P]>
      : GetScalarType<T[P], AggregateWordList[P]>
  }




  ;export  type WordListGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WordListWhereInput
    orderBy?: WordListOrderByWithAggregationInput | WordListOrderByWithAggregationInput[]
    by: WordListScalarFieldEnum[] | WordListScalarFieldEnum
    having?: WordListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WordListCountAggregateInputType | true
    _min?: WordListMinAggregateInputType
    _max?: WordListMaxAggregateInputType
  }

  ;export  type WordListGroupByOutputType = {
    id: string
    name: string
    description: string
    createdAt: Date
    updatedAt: Date
    _count: WordListCountAggregateOutputType | null
    _min: WordListMinAggregateOutputType | null
    _max: WordListMaxAggregateOutputType | null
  }

  type GetWordListGroupByPayload<T extends WordListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WordListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WordListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WordListGroupByOutputType[P]>
            : GetScalarType<T[P], WordListGroupByOutputType[P]>
        }
      >
    >


  ;export  type WordListSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    words?: boolean | WordList$wordsArgs<ExtArgs>
    users?: boolean | WordList$usersArgs<ExtArgs>
    _count?: boolean | WordListCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wordList"]>

  ;export  type WordListSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  ;export  type WordListInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    words?: boolean | WordList$wordsArgs<ExtArgs>
    users?: boolean | WordList$usersArgs<ExtArgs>
    _count?: boolean | WordListCountOutputTypeDefaultArgs<ExtArgs>
  }


  ;export  type $WordListPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WordList"
    objects: {
      words: Prisma.$WordsOnWordListsPayload<ExtArgs>[]
      users: Prisma.$UsersOnWordListsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["wordList"]>
    composites: {}
  }


  type WordListGetPayload<S extends boolean | null | undefined | WordListDefaultArgs> = $Result.GetResult<Prisma.$WordListPayload, S>

  type WordListCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WordListFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WordListCountAggregateInputType | true
    }

  ;export  interface WordListDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WordList'], meta: { name: 'WordList' } }
    /**
     * Find zero or one WordList that matches the filter.
     * @param {WordListFindUniqueArgs} args - Arguments to find a WordList
     * @example
     * // Get one WordList
     * const wordList = await prisma.wordList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WordListFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, WordListFindUniqueArgs<ExtArgs>>
    ): Prisma__WordListClient<$Result.GetResult<Prisma.$WordListPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one WordList that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WordListFindUniqueOrThrowArgs} args - Arguments to find a WordList
     * @example
     * // Get one WordList
     * const wordList = await prisma.wordList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WordListFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WordListFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WordListClient<$Result.GetResult<Prisma.$WordListPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first WordList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordListFindFirstArgs} args - Arguments to find a WordList
     * @example
     * // Get one WordList
     * const wordList = await prisma.wordList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WordListFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, WordListFindFirstArgs<ExtArgs>>
    ): Prisma__WordListClient<$Result.GetResult<Prisma.$WordListPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first WordList that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordListFindFirstOrThrowArgs} args - Arguments to find a WordList
     * @example
     * // Get one WordList
     * const wordList = await prisma.wordList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WordListFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WordListFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WordListClient<$Result.GetResult<Prisma.$WordListPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more WordLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordListFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WordLists
     * const wordLists = await prisma.wordList.findMany()
     * 
     * // Get first 10 WordLists
     * const wordLists = await prisma.wordList.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wordListWithIdOnly = await prisma.wordList.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WordListFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WordListFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WordListPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a WordList.
     * @param {WordListCreateArgs} args - Arguments to create a WordList.
     * @example
     * // Create one WordList
     * const WordList = await prisma.wordList.create({
     *   data: {
     *     // ... data to create a WordList
     *   }
     * })
     * 
    **/
    create<T extends WordListCreateArgs<ExtArgs>>(
      args: SelectSubset<T, WordListCreateArgs<ExtArgs>>
    ): Prisma__WordListClient<$Result.GetResult<Prisma.$WordListPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many WordLists.
     *     @param {WordListCreateManyArgs} args - Arguments to create many WordLists.
     *     @example
     *     // Create many WordLists
     *     const wordList = await prisma.wordList.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WordListCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WordListCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WordList.
     * @param {WordListDeleteArgs} args - Arguments to delete one WordList.
     * @example
     * // Delete one WordList
     * const WordList = await prisma.wordList.delete({
     *   where: {
     *     // ... filter to delete one WordList
     *   }
     * })
     * 
    **/
    delete<T extends WordListDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, WordListDeleteArgs<ExtArgs>>
    ): Prisma__WordListClient<$Result.GetResult<Prisma.$WordListPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one WordList.
     * @param {WordListUpdateArgs} args - Arguments to update one WordList.
     * @example
     * // Update one WordList
     * const wordList = await prisma.wordList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WordListUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, WordListUpdateArgs<ExtArgs>>
    ): Prisma__WordListClient<$Result.GetResult<Prisma.$WordListPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more WordLists.
     * @param {WordListDeleteManyArgs} args - Arguments to filter WordLists to delete.
     * @example
     * // Delete a few WordLists
     * const { count } = await prisma.wordList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WordListDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WordListDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WordLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WordLists
     * const wordList = await prisma.wordList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WordListUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, WordListUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WordList.
     * @param {WordListUpsertArgs} args - Arguments to update or create a WordList.
     * @example
     * // Update or create a WordList
     * const wordList = await prisma.wordList.upsert({
     *   create: {
     *     // ... data to create a WordList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WordList we want to update
     *   }
     * })
    **/
    upsert<T extends WordListUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, WordListUpsertArgs<ExtArgs>>
    ): Prisma__WordListClient<$Result.GetResult<Prisma.$WordListPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of WordLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordListCountArgs} args - Arguments to filter WordLists to count.
     * @example
     * // Count the number of WordLists
     * const count = await prisma.wordList.count({
     *   where: {
     *     // ... the filter for the WordLists we want to count
     *   }
     * })
    **/
    count<T extends WordListCountArgs>(
      args?: Subset<T, WordListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WordListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WordList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WordListAggregateArgs>(args: Subset<T, WordListAggregateArgs>): Prisma.PrismaPromise<GetWordListAggregateType<T>>

    /**
     * Group by WordList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WordListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WordListGroupByArgs['orderBy'] }
        : { orderBy?: WordListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WordListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWordListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WordList model
   */
  readonly fields: WordListFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WordList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  ;export  interface Prisma__WordListClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    words<T extends WordList$wordsArgs<ExtArgs> = {}>(args?: Subset<T, WordList$wordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WordsOnWordListsPayload<ExtArgs>, T, 'findMany'> | Null>;

    users<T extends WordList$usersArgs<ExtArgs> = {}>(args?: Subset<T, WordList$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersOnWordListsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the WordList model
   */ 
  interface WordListFieldRefs {
    readonly id: FieldRef<"WordList", 'String'>
    readonly name: FieldRef<"WordList", 'String'>
    readonly description: FieldRef<"WordList", 'String'>
    readonly createdAt: FieldRef<"WordList", 'DateTime'>
    readonly updatedAt: FieldRef<"WordList", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * WordList findUnique
   */
  ;export  type WordListFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordList
     */
    select?: WordListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordListInclude<ExtArgs> | null
    /**
     * Filter, which WordList to fetch.
     */
    where: WordListWhereUniqueInput
  }


  /**
   * WordList findUniqueOrThrow
   */
  ;export  type WordListFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordList
     */
    select?: WordListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordListInclude<ExtArgs> | null
    /**
     * Filter, which WordList to fetch.
     */
    where: WordListWhereUniqueInput
  }


  /**
   * WordList findFirst
   */
  ;export  type WordListFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordList
     */
    select?: WordListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordListInclude<ExtArgs> | null
    /**
     * Filter, which WordList to fetch.
     */
    where?: WordListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WordLists to fetch.
     */
    orderBy?: WordListOrderByWithRelationInput | WordListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WordLists.
     */
    cursor?: WordListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WordLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WordLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WordLists.
     */
    distinct?: WordListScalarFieldEnum | WordListScalarFieldEnum[]
  }


  /**
   * WordList findFirstOrThrow
   */
  ;export  type WordListFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordList
     */
    select?: WordListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordListInclude<ExtArgs> | null
    /**
     * Filter, which WordList to fetch.
     */
    where?: WordListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WordLists to fetch.
     */
    orderBy?: WordListOrderByWithRelationInput | WordListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WordLists.
     */
    cursor?: WordListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WordLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WordLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WordLists.
     */
    distinct?: WordListScalarFieldEnum | WordListScalarFieldEnum[]
  }


  /**
   * WordList findMany
   */
  ;export  type WordListFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordList
     */
    select?: WordListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordListInclude<ExtArgs> | null
    /**
     * Filter, which WordLists to fetch.
     */
    where?: WordListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WordLists to fetch.
     */
    orderBy?: WordListOrderByWithRelationInput | WordListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WordLists.
     */
    cursor?: WordListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WordLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WordLists.
     */
    skip?: number
    distinct?: WordListScalarFieldEnum | WordListScalarFieldEnum[]
  }


  /**
   * WordList create
   */
  ;export  type WordListCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordList
     */
    select?: WordListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordListInclude<ExtArgs> | null
    /**
     * The data needed to create a WordList.
     */
    data: XOR<WordListCreateInput, WordListUncheckedCreateInput>
  }


  /**
   * WordList createMany
   */
  ;export  type WordListCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WordLists.
     */
    data: WordListCreateManyInput | WordListCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * WordList update
   */
  ;export  type WordListUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordList
     */
    select?: WordListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordListInclude<ExtArgs> | null
    /**
     * The data needed to update a WordList.
     */
    data: XOR<WordListUpdateInput, WordListUncheckedUpdateInput>
    /**
     * Choose, which WordList to update.
     */
    where: WordListWhereUniqueInput
  }


  /**
   * WordList updateMany
   */
  ;export  type WordListUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WordLists.
     */
    data: XOR<WordListUpdateManyMutationInput, WordListUncheckedUpdateManyInput>
    /**
     * Filter which WordLists to update
     */
    where?: WordListWhereInput
  }


  /**
   * WordList upsert
   */
  ;export  type WordListUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordList
     */
    select?: WordListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordListInclude<ExtArgs> | null
    /**
     * The filter to search for the WordList to update in case it exists.
     */
    where: WordListWhereUniqueInput
    /**
     * In case the WordList found by the `where` argument doesn't exist, create a new WordList with this data.
     */
    create: XOR<WordListCreateInput, WordListUncheckedCreateInput>
    /**
     * In case the WordList was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WordListUpdateInput, WordListUncheckedUpdateInput>
  }


  /**
   * WordList delete
   */
  ;export  type WordListDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordList
     */
    select?: WordListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordListInclude<ExtArgs> | null
    /**
     * Filter which WordList to delete.
     */
    where: WordListWhereUniqueInput
  }


  /**
   * WordList deleteMany
   */
  ;export  type WordListDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WordLists to delete
     */
    where?: WordListWhereInput
  }


  /**
   * WordList.words
   */
  ;export  type WordList$wordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordsOnWordLists
     */
    select?: WordsOnWordListsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordsOnWordListsInclude<ExtArgs> | null
    where?: WordsOnWordListsWhereInput
    orderBy?: WordsOnWordListsOrderByWithRelationInput | WordsOnWordListsOrderByWithRelationInput[]
    cursor?: WordsOnWordListsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WordsOnWordListsScalarFieldEnum | WordsOnWordListsScalarFieldEnum[]
  }


  /**
   * WordList.users
   */
  ;export  type WordList$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnWordLists
     */
    select?: UsersOnWordListsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersOnWordListsInclude<ExtArgs> | null
    where?: UsersOnWordListsWhereInput
    orderBy?: UsersOnWordListsOrderByWithRelationInput | UsersOnWordListsOrderByWithRelationInput[]
    cursor?: UsersOnWordListsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersOnWordListsScalarFieldEnum | UsersOnWordListsScalarFieldEnum[]
  }


  /**
   * WordList without action
   */
  ;export  type WordListDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordList
     */
    select?: WordListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordListInclude<ExtArgs> | null
  }



  /**
   * Model WordsOnWordLists
   */

  ;export  type AggregateWordsOnWordLists = {
    _count: WordsOnWordListsCountAggregateOutputType | null
    _min: WordsOnWordListsMinAggregateOutputType | null
    _max: WordsOnWordListsMaxAggregateOutputType | null
  }

  ;export  type WordsOnWordListsMinAggregateOutputType = {
    wordId: string | null
    wordListId: string | null
  }

  ;export  type WordsOnWordListsMaxAggregateOutputType = {
    wordId: string | null
    wordListId: string | null
  }

  ;export  type WordsOnWordListsCountAggregateOutputType = {
    wordId: number
    wordListId: number
    _all: number
  }


  ;export  type WordsOnWordListsMinAggregateInputType = {
    wordId?: true
    wordListId?: true
  }

  ;export  type WordsOnWordListsMaxAggregateInputType = {
    wordId?: true
    wordListId?: true
  }

  ;export  type WordsOnWordListsCountAggregateInputType = {
    wordId?: true
    wordListId?: true
    _all?: true
  }

  ;export  type WordsOnWordListsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WordsOnWordLists to aggregate.
     */
    where?: WordsOnWordListsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WordsOnWordLists to fetch.
     */
    orderBy?: WordsOnWordListsOrderByWithRelationInput | WordsOnWordListsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WordsOnWordListsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WordsOnWordLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WordsOnWordLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WordsOnWordLists
    **/
    _count?: true | WordsOnWordListsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WordsOnWordListsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WordsOnWordListsMaxAggregateInputType
  }

  ;export  type GetWordsOnWordListsAggregateType<T extends WordsOnWordListsAggregateArgs> = {
        [P in keyof T & keyof AggregateWordsOnWordLists]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWordsOnWordLists[P]>
      : GetScalarType<T[P], AggregateWordsOnWordLists[P]>
  }




  ;export  type WordsOnWordListsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WordsOnWordListsWhereInput
    orderBy?: WordsOnWordListsOrderByWithAggregationInput | WordsOnWordListsOrderByWithAggregationInput[]
    by: WordsOnWordListsScalarFieldEnum[] | WordsOnWordListsScalarFieldEnum
    having?: WordsOnWordListsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WordsOnWordListsCountAggregateInputType | true
    _min?: WordsOnWordListsMinAggregateInputType
    _max?: WordsOnWordListsMaxAggregateInputType
  }

  ;export  type WordsOnWordListsGroupByOutputType = {
    wordId: string
    wordListId: string
    _count: WordsOnWordListsCountAggregateOutputType | null
    _min: WordsOnWordListsMinAggregateOutputType | null
    _max: WordsOnWordListsMaxAggregateOutputType | null
  }

  type GetWordsOnWordListsGroupByPayload<T extends WordsOnWordListsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WordsOnWordListsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WordsOnWordListsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WordsOnWordListsGroupByOutputType[P]>
            : GetScalarType<T[P], WordsOnWordListsGroupByOutputType[P]>
        }
      >
    >


  ;export  type WordsOnWordListsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    wordId?: boolean
    wordListId?: boolean
    word?: boolean | WordDefaultArgs<ExtArgs>
    wordList?: boolean | WordListDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wordsOnWordLists"]>

  ;export  type WordsOnWordListsSelectScalar = {
    wordId?: boolean
    wordListId?: boolean
  }

  ;export  type WordsOnWordListsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    word?: boolean | WordDefaultArgs<ExtArgs>
    wordList?: boolean | WordListDefaultArgs<ExtArgs>
  }


  ;export  type $WordsOnWordListsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WordsOnWordLists"
    objects: {
      word: Prisma.$WordPayload<ExtArgs>
      wordList: Prisma.$WordListPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      wordId: string
      wordListId: string
    }, ExtArgs["result"]["wordsOnWordLists"]>
    composites: {}
  }


  type WordsOnWordListsGetPayload<S extends boolean | null | undefined | WordsOnWordListsDefaultArgs> = $Result.GetResult<Prisma.$WordsOnWordListsPayload, S>

  type WordsOnWordListsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WordsOnWordListsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WordsOnWordListsCountAggregateInputType | true
    }

  ;export  interface WordsOnWordListsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WordsOnWordLists'], meta: { name: 'WordsOnWordLists' } }
    /**
     * Find zero or one WordsOnWordLists that matches the filter.
     * @param {WordsOnWordListsFindUniqueArgs} args - Arguments to find a WordsOnWordLists
     * @example
     * // Get one WordsOnWordLists
     * const wordsOnWordLists = await prisma.wordsOnWordLists.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WordsOnWordListsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, WordsOnWordListsFindUniqueArgs<ExtArgs>>
    ): Prisma__WordsOnWordListsClient<$Result.GetResult<Prisma.$WordsOnWordListsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one WordsOnWordLists that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WordsOnWordListsFindUniqueOrThrowArgs} args - Arguments to find a WordsOnWordLists
     * @example
     * // Get one WordsOnWordLists
     * const wordsOnWordLists = await prisma.wordsOnWordLists.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WordsOnWordListsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WordsOnWordListsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WordsOnWordListsClient<$Result.GetResult<Prisma.$WordsOnWordListsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first WordsOnWordLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordsOnWordListsFindFirstArgs} args - Arguments to find a WordsOnWordLists
     * @example
     * // Get one WordsOnWordLists
     * const wordsOnWordLists = await prisma.wordsOnWordLists.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WordsOnWordListsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, WordsOnWordListsFindFirstArgs<ExtArgs>>
    ): Prisma__WordsOnWordListsClient<$Result.GetResult<Prisma.$WordsOnWordListsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first WordsOnWordLists that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordsOnWordListsFindFirstOrThrowArgs} args - Arguments to find a WordsOnWordLists
     * @example
     * // Get one WordsOnWordLists
     * const wordsOnWordLists = await prisma.wordsOnWordLists.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WordsOnWordListsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WordsOnWordListsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WordsOnWordListsClient<$Result.GetResult<Prisma.$WordsOnWordListsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more WordsOnWordLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordsOnWordListsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WordsOnWordLists
     * const wordsOnWordLists = await prisma.wordsOnWordLists.findMany()
     * 
     * // Get first 10 WordsOnWordLists
     * const wordsOnWordLists = await prisma.wordsOnWordLists.findMany({ take: 10 })
     * 
     * // Only select the `wordId`
     * const wordsOnWordListsWithWordIdOnly = await prisma.wordsOnWordLists.findMany({ select: { wordId: true } })
     * 
    **/
    findMany<T extends WordsOnWordListsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WordsOnWordListsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WordsOnWordListsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a WordsOnWordLists.
     * @param {WordsOnWordListsCreateArgs} args - Arguments to create a WordsOnWordLists.
     * @example
     * // Create one WordsOnWordLists
     * const WordsOnWordLists = await prisma.wordsOnWordLists.create({
     *   data: {
     *     // ... data to create a WordsOnWordLists
     *   }
     * })
     * 
    **/
    create<T extends WordsOnWordListsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, WordsOnWordListsCreateArgs<ExtArgs>>
    ): Prisma__WordsOnWordListsClient<$Result.GetResult<Prisma.$WordsOnWordListsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many WordsOnWordLists.
     *     @param {WordsOnWordListsCreateManyArgs} args - Arguments to create many WordsOnWordLists.
     *     @example
     *     // Create many WordsOnWordLists
     *     const wordsOnWordLists = await prisma.wordsOnWordLists.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WordsOnWordListsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WordsOnWordListsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WordsOnWordLists.
     * @param {WordsOnWordListsDeleteArgs} args - Arguments to delete one WordsOnWordLists.
     * @example
     * // Delete one WordsOnWordLists
     * const WordsOnWordLists = await prisma.wordsOnWordLists.delete({
     *   where: {
     *     // ... filter to delete one WordsOnWordLists
     *   }
     * })
     * 
    **/
    delete<T extends WordsOnWordListsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, WordsOnWordListsDeleteArgs<ExtArgs>>
    ): Prisma__WordsOnWordListsClient<$Result.GetResult<Prisma.$WordsOnWordListsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one WordsOnWordLists.
     * @param {WordsOnWordListsUpdateArgs} args - Arguments to update one WordsOnWordLists.
     * @example
     * // Update one WordsOnWordLists
     * const wordsOnWordLists = await prisma.wordsOnWordLists.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WordsOnWordListsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, WordsOnWordListsUpdateArgs<ExtArgs>>
    ): Prisma__WordsOnWordListsClient<$Result.GetResult<Prisma.$WordsOnWordListsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more WordsOnWordLists.
     * @param {WordsOnWordListsDeleteManyArgs} args - Arguments to filter WordsOnWordLists to delete.
     * @example
     * // Delete a few WordsOnWordLists
     * const { count } = await prisma.wordsOnWordLists.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WordsOnWordListsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WordsOnWordListsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WordsOnWordLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordsOnWordListsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WordsOnWordLists
     * const wordsOnWordLists = await prisma.wordsOnWordLists.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WordsOnWordListsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, WordsOnWordListsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WordsOnWordLists.
     * @param {WordsOnWordListsUpsertArgs} args - Arguments to update or create a WordsOnWordLists.
     * @example
     * // Update or create a WordsOnWordLists
     * const wordsOnWordLists = await prisma.wordsOnWordLists.upsert({
     *   create: {
     *     // ... data to create a WordsOnWordLists
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WordsOnWordLists we want to update
     *   }
     * })
    **/
    upsert<T extends WordsOnWordListsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, WordsOnWordListsUpsertArgs<ExtArgs>>
    ): Prisma__WordsOnWordListsClient<$Result.GetResult<Prisma.$WordsOnWordListsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of WordsOnWordLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordsOnWordListsCountArgs} args - Arguments to filter WordsOnWordLists to count.
     * @example
     * // Count the number of WordsOnWordLists
     * const count = await prisma.wordsOnWordLists.count({
     *   where: {
     *     // ... the filter for the WordsOnWordLists we want to count
     *   }
     * })
    **/
    count<T extends WordsOnWordListsCountArgs>(
      args?: Subset<T, WordsOnWordListsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WordsOnWordListsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WordsOnWordLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordsOnWordListsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WordsOnWordListsAggregateArgs>(args: Subset<T, WordsOnWordListsAggregateArgs>): Prisma.PrismaPromise<GetWordsOnWordListsAggregateType<T>>

    /**
     * Group by WordsOnWordLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WordsOnWordListsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WordsOnWordListsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WordsOnWordListsGroupByArgs['orderBy'] }
        : { orderBy?: WordsOnWordListsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WordsOnWordListsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWordsOnWordListsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WordsOnWordLists model
   */
  readonly fields: WordsOnWordListsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WordsOnWordLists.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  ;export  interface Prisma__WordsOnWordListsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    word<T extends WordDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WordDefaultArgs<ExtArgs>>): Prisma__WordClient<$Result.GetResult<Prisma.$WordPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    wordList<T extends WordListDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WordListDefaultArgs<ExtArgs>>): Prisma__WordListClient<$Result.GetResult<Prisma.$WordListPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the WordsOnWordLists model
   */ 
  interface WordsOnWordListsFieldRefs {
    readonly wordId: FieldRef<"WordsOnWordLists", 'String'>
    readonly wordListId: FieldRef<"WordsOnWordLists", 'String'>
  }
    

  // Custom InputTypes

  /**
   * WordsOnWordLists findUnique
   */
  ;export  type WordsOnWordListsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordsOnWordLists
     */
    select?: WordsOnWordListsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordsOnWordListsInclude<ExtArgs> | null
    /**
     * Filter, which WordsOnWordLists to fetch.
     */
    where: WordsOnWordListsWhereUniqueInput
  }


  /**
   * WordsOnWordLists findUniqueOrThrow
   */
  ;export  type WordsOnWordListsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordsOnWordLists
     */
    select?: WordsOnWordListsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordsOnWordListsInclude<ExtArgs> | null
    /**
     * Filter, which WordsOnWordLists to fetch.
     */
    where: WordsOnWordListsWhereUniqueInput
  }


  /**
   * WordsOnWordLists findFirst
   */
  ;export  type WordsOnWordListsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordsOnWordLists
     */
    select?: WordsOnWordListsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordsOnWordListsInclude<ExtArgs> | null
    /**
     * Filter, which WordsOnWordLists to fetch.
     */
    where?: WordsOnWordListsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WordsOnWordLists to fetch.
     */
    orderBy?: WordsOnWordListsOrderByWithRelationInput | WordsOnWordListsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WordsOnWordLists.
     */
    cursor?: WordsOnWordListsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WordsOnWordLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WordsOnWordLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WordsOnWordLists.
     */
    distinct?: WordsOnWordListsScalarFieldEnum | WordsOnWordListsScalarFieldEnum[]
  }


  /**
   * WordsOnWordLists findFirstOrThrow
   */
  ;export  type WordsOnWordListsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordsOnWordLists
     */
    select?: WordsOnWordListsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordsOnWordListsInclude<ExtArgs> | null
    /**
     * Filter, which WordsOnWordLists to fetch.
     */
    where?: WordsOnWordListsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WordsOnWordLists to fetch.
     */
    orderBy?: WordsOnWordListsOrderByWithRelationInput | WordsOnWordListsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WordsOnWordLists.
     */
    cursor?: WordsOnWordListsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WordsOnWordLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WordsOnWordLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WordsOnWordLists.
     */
    distinct?: WordsOnWordListsScalarFieldEnum | WordsOnWordListsScalarFieldEnum[]
  }


  /**
   * WordsOnWordLists findMany
   */
  ;export  type WordsOnWordListsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordsOnWordLists
     */
    select?: WordsOnWordListsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordsOnWordListsInclude<ExtArgs> | null
    /**
     * Filter, which WordsOnWordLists to fetch.
     */
    where?: WordsOnWordListsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WordsOnWordLists to fetch.
     */
    orderBy?: WordsOnWordListsOrderByWithRelationInput | WordsOnWordListsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WordsOnWordLists.
     */
    cursor?: WordsOnWordListsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WordsOnWordLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WordsOnWordLists.
     */
    skip?: number
    distinct?: WordsOnWordListsScalarFieldEnum | WordsOnWordListsScalarFieldEnum[]
  }


  /**
   * WordsOnWordLists create
   */
  ;export  type WordsOnWordListsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordsOnWordLists
     */
    select?: WordsOnWordListsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordsOnWordListsInclude<ExtArgs> | null
    /**
     * The data needed to create a WordsOnWordLists.
     */
    data: XOR<WordsOnWordListsCreateInput, WordsOnWordListsUncheckedCreateInput>
  }


  /**
   * WordsOnWordLists createMany
   */
  ;export  type WordsOnWordListsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WordsOnWordLists.
     */
    data: WordsOnWordListsCreateManyInput | WordsOnWordListsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * WordsOnWordLists update
   */
  ;export  type WordsOnWordListsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordsOnWordLists
     */
    select?: WordsOnWordListsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordsOnWordListsInclude<ExtArgs> | null
    /**
     * The data needed to update a WordsOnWordLists.
     */
    data: XOR<WordsOnWordListsUpdateInput, WordsOnWordListsUncheckedUpdateInput>
    /**
     * Choose, which WordsOnWordLists to update.
     */
    where: WordsOnWordListsWhereUniqueInput
  }


  /**
   * WordsOnWordLists updateMany
   */
  ;export  type WordsOnWordListsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WordsOnWordLists.
     */
    data: XOR<WordsOnWordListsUpdateManyMutationInput, WordsOnWordListsUncheckedUpdateManyInput>
    /**
     * Filter which WordsOnWordLists to update
     */
    where?: WordsOnWordListsWhereInput
  }


  /**
   * WordsOnWordLists upsert
   */
  ;export  type WordsOnWordListsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordsOnWordLists
     */
    select?: WordsOnWordListsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordsOnWordListsInclude<ExtArgs> | null
    /**
     * The filter to search for the WordsOnWordLists to update in case it exists.
     */
    where: WordsOnWordListsWhereUniqueInput
    /**
     * In case the WordsOnWordLists found by the `where` argument doesn't exist, create a new WordsOnWordLists with this data.
     */
    create: XOR<WordsOnWordListsCreateInput, WordsOnWordListsUncheckedCreateInput>
    /**
     * In case the WordsOnWordLists was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WordsOnWordListsUpdateInput, WordsOnWordListsUncheckedUpdateInput>
  }


  /**
   * WordsOnWordLists delete
   */
  ;export  type WordsOnWordListsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordsOnWordLists
     */
    select?: WordsOnWordListsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordsOnWordListsInclude<ExtArgs> | null
    /**
     * Filter which WordsOnWordLists to delete.
     */
    where: WordsOnWordListsWhereUniqueInput
  }


  /**
   * WordsOnWordLists deleteMany
   */
  ;export  type WordsOnWordListsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WordsOnWordLists to delete
     */
    where?: WordsOnWordListsWhereInput
  }


  /**
   * WordsOnWordLists without action
   */
  ;export  type WordsOnWordListsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WordsOnWordLists
     */
    select?: WordsOnWordListsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WordsOnWordListsInclude<ExtArgs> | null
  }



  /**
   * Model UsersOnWordLists
   */

  ;export  type AggregateUsersOnWordLists = {
    _count: UsersOnWordListsCountAggregateOutputType | null
    _min: UsersOnWordListsMinAggregateOutputType | null
    _max: UsersOnWordListsMaxAggregateOutputType | null
  }

  ;export  type UsersOnWordListsMinAggregateOutputType = {
    userId: string | null
    wordListId: string | null
  }

  ;export  type UsersOnWordListsMaxAggregateOutputType = {
    userId: string | null
    wordListId: string | null
  }

  ;export  type UsersOnWordListsCountAggregateOutputType = {
    userId: number
    wordListId: number
    _all: number
  }


  ;export  type UsersOnWordListsMinAggregateInputType = {
    userId?: true
    wordListId?: true
  }

  ;export  type UsersOnWordListsMaxAggregateInputType = {
    userId?: true
    wordListId?: true
  }

  ;export  type UsersOnWordListsCountAggregateInputType = {
    userId?: true
    wordListId?: true
    _all?: true
  }

  ;export  type UsersOnWordListsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsersOnWordLists to aggregate.
     */
    where?: UsersOnWordListsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersOnWordLists to fetch.
     */
    orderBy?: UsersOnWordListsOrderByWithRelationInput | UsersOnWordListsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersOnWordListsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersOnWordLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersOnWordLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsersOnWordLists
    **/
    _count?: true | UsersOnWordListsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersOnWordListsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersOnWordListsMaxAggregateInputType
  }

  ;export  type GetUsersOnWordListsAggregateType<T extends UsersOnWordListsAggregateArgs> = {
        [P in keyof T & keyof AggregateUsersOnWordLists]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsersOnWordLists[P]>
      : GetScalarType<T[P], AggregateUsersOnWordLists[P]>
  }




  ;export  type UsersOnWordListsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersOnWordListsWhereInput
    orderBy?: UsersOnWordListsOrderByWithAggregationInput | UsersOnWordListsOrderByWithAggregationInput[]
    by: UsersOnWordListsScalarFieldEnum[] | UsersOnWordListsScalarFieldEnum
    having?: UsersOnWordListsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersOnWordListsCountAggregateInputType | true
    _min?: UsersOnWordListsMinAggregateInputType
    _max?: UsersOnWordListsMaxAggregateInputType
  }

  ;export  type UsersOnWordListsGroupByOutputType = {
    userId: string
    wordListId: string
    _count: UsersOnWordListsCountAggregateOutputType | null
    _min: UsersOnWordListsMinAggregateOutputType | null
    _max: UsersOnWordListsMaxAggregateOutputType | null
  }

  type GetUsersOnWordListsGroupByPayload<T extends UsersOnWordListsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersOnWordListsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersOnWordListsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersOnWordListsGroupByOutputType[P]>
            : GetScalarType<T[P], UsersOnWordListsGroupByOutputType[P]>
        }
      >
    >


  ;export  type UsersOnWordListsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    wordListId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    wordList?: boolean | WordListDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usersOnWordLists"]>

  ;export  type UsersOnWordListsSelectScalar = {
    userId?: boolean
    wordListId?: boolean
  }

  ;export  type UsersOnWordListsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    wordList?: boolean | WordListDefaultArgs<ExtArgs>
  }


  ;export  type $UsersOnWordListsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsersOnWordLists"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      wordList: Prisma.$WordListPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      wordListId: string
    }, ExtArgs["result"]["usersOnWordLists"]>
    composites: {}
  }


  type UsersOnWordListsGetPayload<S extends boolean | null | undefined | UsersOnWordListsDefaultArgs> = $Result.GetResult<Prisma.$UsersOnWordListsPayload, S>

  type UsersOnWordListsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsersOnWordListsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersOnWordListsCountAggregateInputType | true
    }

  ;export  interface UsersOnWordListsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsersOnWordLists'], meta: { name: 'UsersOnWordLists' } }
    /**
     * Find zero or one UsersOnWordLists that matches the filter.
     * @param {UsersOnWordListsFindUniqueArgs} args - Arguments to find a UsersOnWordLists
     * @example
     * // Get one UsersOnWordLists
     * const usersOnWordLists = await prisma.usersOnWordLists.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UsersOnWordListsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UsersOnWordListsFindUniqueArgs<ExtArgs>>
    ): Prisma__UsersOnWordListsClient<$Result.GetResult<Prisma.$UsersOnWordListsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UsersOnWordLists that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UsersOnWordListsFindUniqueOrThrowArgs} args - Arguments to find a UsersOnWordLists
     * @example
     * // Get one UsersOnWordLists
     * const usersOnWordLists = await prisma.usersOnWordLists.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UsersOnWordListsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersOnWordListsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UsersOnWordListsClient<$Result.GetResult<Prisma.$UsersOnWordListsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UsersOnWordLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersOnWordListsFindFirstArgs} args - Arguments to find a UsersOnWordLists
     * @example
     * // Get one UsersOnWordLists
     * const usersOnWordLists = await prisma.usersOnWordLists.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UsersOnWordListsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersOnWordListsFindFirstArgs<ExtArgs>>
    ): Prisma__UsersOnWordListsClient<$Result.GetResult<Prisma.$UsersOnWordListsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UsersOnWordLists that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersOnWordListsFindFirstOrThrowArgs} args - Arguments to find a UsersOnWordLists
     * @example
     * // Get one UsersOnWordLists
     * const usersOnWordLists = await prisma.usersOnWordLists.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UsersOnWordListsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersOnWordListsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UsersOnWordListsClient<$Result.GetResult<Prisma.$UsersOnWordListsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UsersOnWordLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersOnWordListsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsersOnWordLists
     * const usersOnWordLists = await prisma.usersOnWordLists.findMany()
     * 
     * // Get first 10 UsersOnWordLists
     * const usersOnWordLists = await prisma.usersOnWordLists.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const usersOnWordListsWithUserIdOnly = await prisma.usersOnWordLists.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends UsersOnWordListsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersOnWordListsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersOnWordListsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UsersOnWordLists.
     * @param {UsersOnWordListsCreateArgs} args - Arguments to create a UsersOnWordLists.
     * @example
     * // Create one UsersOnWordLists
     * const UsersOnWordLists = await prisma.usersOnWordLists.create({
     *   data: {
     *     // ... data to create a UsersOnWordLists
     *   }
     * })
     * 
    **/
    create<T extends UsersOnWordListsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UsersOnWordListsCreateArgs<ExtArgs>>
    ): Prisma__UsersOnWordListsClient<$Result.GetResult<Prisma.$UsersOnWordListsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UsersOnWordLists.
     *     @param {UsersOnWordListsCreateManyArgs} args - Arguments to create many UsersOnWordLists.
     *     @example
     *     // Create many UsersOnWordLists
     *     const usersOnWordLists = await prisma.usersOnWordLists.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UsersOnWordListsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersOnWordListsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UsersOnWordLists.
     * @param {UsersOnWordListsDeleteArgs} args - Arguments to delete one UsersOnWordLists.
     * @example
     * // Delete one UsersOnWordLists
     * const UsersOnWordLists = await prisma.usersOnWordLists.delete({
     *   where: {
     *     // ... filter to delete one UsersOnWordLists
     *   }
     * })
     * 
    **/
    delete<T extends UsersOnWordListsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UsersOnWordListsDeleteArgs<ExtArgs>>
    ): Prisma__UsersOnWordListsClient<$Result.GetResult<Prisma.$UsersOnWordListsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UsersOnWordLists.
     * @param {UsersOnWordListsUpdateArgs} args - Arguments to update one UsersOnWordLists.
     * @example
     * // Update one UsersOnWordLists
     * const usersOnWordLists = await prisma.usersOnWordLists.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UsersOnWordListsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UsersOnWordListsUpdateArgs<ExtArgs>>
    ): Prisma__UsersOnWordListsClient<$Result.GetResult<Prisma.$UsersOnWordListsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UsersOnWordLists.
     * @param {UsersOnWordListsDeleteManyArgs} args - Arguments to filter UsersOnWordLists to delete.
     * @example
     * // Delete a few UsersOnWordLists
     * const { count } = await prisma.usersOnWordLists.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UsersOnWordListsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsersOnWordListsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsersOnWordLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersOnWordListsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsersOnWordLists
     * const usersOnWordLists = await prisma.usersOnWordLists.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UsersOnWordListsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UsersOnWordListsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UsersOnWordLists.
     * @param {UsersOnWordListsUpsertArgs} args - Arguments to update or create a UsersOnWordLists.
     * @example
     * // Update or create a UsersOnWordLists
     * const usersOnWordLists = await prisma.usersOnWordLists.upsert({
     *   create: {
     *     // ... data to create a UsersOnWordLists
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsersOnWordLists we want to update
     *   }
     * })
    **/
    upsert<T extends UsersOnWordListsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UsersOnWordListsUpsertArgs<ExtArgs>>
    ): Prisma__UsersOnWordListsClient<$Result.GetResult<Prisma.$UsersOnWordListsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UsersOnWordLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersOnWordListsCountArgs} args - Arguments to filter UsersOnWordLists to count.
     * @example
     * // Count the number of UsersOnWordLists
     * const count = await prisma.usersOnWordLists.count({
     *   where: {
     *     // ... the filter for the UsersOnWordLists we want to count
     *   }
     * })
    **/
    count<T extends UsersOnWordListsCountArgs>(
      args?: Subset<T, UsersOnWordListsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersOnWordListsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsersOnWordLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersOnWordListsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersOnWordListsAggregateArgs>(args: Subset<T, UsersOnWordListsAggregateArgs>): Prisma.PrismaPromise<GetUsersOnWordListsAggregateType<T>>

    /**
     * Group by UsersOnWordLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersOnWordListsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersOnWordListsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersOnWordListsGroupByArgs['orderBy'] }
        : { orderBy?: UsersOnWordListsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersOnWordListsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersOnWordListsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsersOnWordLists model
   */
  readonly fields: UsersOnWordListsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsersOnWordLists.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  ;export  interface Prisma__UsersOnWordListsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    wordList<T extends WordListDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WordListDefaultArgs<ExtArgs>>): Prisma__WordListClient<$Result.GetResult<Prisma.$WordListPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the UsersOnWordLists model
   */ 
  interface UsersOnWordListsFieldRefs {
    readonly userId: FieldRef<"UsersOnWordLists", 'String'>
    readonly wordListId: FieldRef<"UsersOnWordLists", 'String'>
  }
    

  // Custom InputTypes

  /**
   * UsersOnWordLists findUnique
   */
  ;export  type UsersOnWordListsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnWordLists
     */
    select?: UsersOnWordListsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersOnWordListsInclude<ExtArgs> | null
    /**
     * Filter, which UsersOnWordLists to fetch.
     */
    where: UsersOnWordListsWhereUniqueInput
  }


  /**
   * UsersOnWordLists findUniqueOrThrow
   */
  ;export  type UsersOnWordListsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnWordLists
     */
    select?: UsersOnWordListsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersOnWordListsInclude<ExtArgs> | null
    /**
     * Filter, which UsersOnWordLists to fetch.
     */
    where: UsersOnWordListsWhereUniqueInput
  }


  /**
   * UsersOnWordLists findFirst
   */
  ;export  type UsersOnWordListsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnWordLists
     */
    select?: UsersOnWordListsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersOnWordListsInclude<ExtArgs> | null
    /**
     * Filter, which UsersOnWordLists to fetch.
     */
    where?: UsersOnWordListsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersOnWordLists to fetch.
     */
    orderBy?: UsersOnWordListsOrderByWithRelationInput | UsersOnWordListsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsersOnWordLists.
     */
    cursor?: UsersOnWordListsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersOnWordLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersOnWordLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsersOnWordLists.
     */
    distinct?: UsersOnWordListsScalarFieldEnum | UsersOnWordListsScalarFieldEnum[]
  }


  /**
   * UsersOnWordLists findFirstOrThrow
   */
  ;export  type UsersOnWordListsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnWordLists
     */
    select?: UsersOnWordListsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersOnWordListsInclude<ExtArgs> | null
    /**
     * Filter, which UsersOnWordLists to fetch.
     */
    where?: UsersOnWordListsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersOnWordLists to fetch.
     */
    orderBy?: UsersOnWordListsOrderByWithRelationInput | UsersOnWordListsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsersOnWordLists.
     */
    cursor?: UsersOnWordListsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersOnWordLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersOnWordLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsersOnWordLists.
     */
    distinct?: UsersOnWordListsScalarFieldEnum | UsersOnWordListsScalarFieldEnum[]
  }


  /**
   * UsersOnWordLists findMany
   */
  ;export  type UsersOnWordListsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnWordLists
     */
    select?: UsersOnWordListsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersOnWordListsInclude<ExtArgs> | null
    /**
     * Filter, which UsersOnWordLists to fetch.
     */
    where?: UsersOnWordListsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersOnWordLists to fetch.
     */
    orderBy?: UsersOnWordListsOrderByWithRelationInput | UsersOnWordListsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsersOnWordLists.
     */
    cursor?: UsersOnWordListsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersOnWordLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersOnWordLists.
     */
    skip?: number
    distinct?: UsersOnWordListsScalarFieldEnum | UsersOnWordListsScalarFieldEnum[]
  }


  /**
   * UsersOnWordLists create
   */
  ;export  type UsersOnWordListsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnWordLists
     */
    select?: UsersOnWordListsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersOnWordListsInclude<ExtArgs> | null
    /**
     * The data needed to create a UsersOnWordLists.
     */
    data: XOR<UsersOnWordListsCreateInput, UsersOnWordListsUncheckedCreateInput>
  }


  /**
   * UsersOnWordLists createMany
   */
  ;export  type UsersOnWordListsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsersOnWordLists.
     */
    data: UsersOnWordListsCreateManyInput | UsersOnWordListsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * UsersOnWordLists update
   */
  ;export  type UsersOnWordListsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnWordLists
     */
    select?: UsersOnWordListsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersOnWordListsInclude<ExtArgs> | null
    /**
     * The data needed to update a UsersOnWordLists.
     */
    data: XOR<UsersOnWordListsUpdateInput, UsersOnWordListsUncheckedUpdateInput>
    /**
     * Choose, which UsersOnWordLists to update.
     */
    where: UsersOnWordListsWhereUniqueInput
  }


  /**
   * UsersOnWordLists updateMany
   */
  ;export  type UsersOnWordListsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsersOnWordLists.
     */
    data: XOR<UsersOnWordListsUpdateManyMutationInput, UsersOnWordListsUncheckedUpdateManyInput>
    /**
     * Filter which UsersOnWordLists to update
     */
    where?: UsersOnWordListsWhereInput
  }


  /**
   * UsersOnWordLists upsert
   */
  ;export  type UsersOnWordListsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnWordLists
     */
    select?: UsersOnWordListsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersOnWordListsInclude<ExtArgs> | null
    /**
     * The filter to search for the UsersOnWordLists to update in case it exists.
     */
    where: UsersOnWordListsWhereUniqueInput
    /**
     * In case the UsersOnWordLists found by the `where` argument doesn't exist, create a new UsersOnWordLists with this data.
     */
    create: XOR<UsersOnWordListsCreateInput, UsersOnWordListsUncheckedCreateInput>
    /**
     * In case the UsersOnWordLists was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersOnWordListsUpdateInput, UsersOnWordListsUncheckedUpdateInput>
  }


  /**
   * UsersOnWordLists delete
   */
  ;export  type UsersOnWordListsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnWordLists
     */
    select?: UsersOnWordListsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersOnWordListsInclude<ExtArgs> | null
    /**
     * Filter which UsersOnWordLists to delete.
     */
    where: UsersOnWordListsWhereUniqueInput
  }


  /**
   * UsersOnWordLists deleteMany
   */
  ;export  type UsersOnWordListsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsersOnWordLists to delete
     */
    where?: UsersOnWordListsWhereInput
  }


  /**
   * UsersOnWordLists without action
   */
  ;export  type UsersOnWordListsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersOnWordLists
     */
    select?: UsersOnWordListsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UsersOnWordListsInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  ;export  const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  ;export  type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  ;export  const WordScalarFieldEnum: {
    id: 'id',
    word: 'word',
    transcription: 'transcription',
    audio: 'audio',
    source: 'source',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  ;export  type WordScalarFieldEnum = (typeof WordScalarFieldEnum)[keyof typeof WordScalarFieldEnum]


  ;export  const MeaningScalarFieldEnum: {
    id: 'id',
    term: 'term',
    partOfSpeech: 'partOfSpeech',
    meaning: 'meaning',
    synonyms: 'synonyms',
    antonyms: 'antonyms',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    wordId: 'wordId'
  };

  ;export  type MeaningScalarFieldEnum = (typeof MeaningScalarFieldEnum)[keyof typeof MeaningScalarFieldEnum]


  ;export  const SentenceScalarFieldEnum: {
    id: 'id',
    fullText: 'fullText',
    wordToLearn: 'wordToLearn',
    options: 'options',
    meaningId: 'meaningId',
    source: 'source',
    greatVotesCount: 'greatVotesCount',
    fineVotesCount: 'fineVotesCount',
    badVotesCount: 'badVotesCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  ;export  type SentenceScalarFieldEnum = (typeof SentenceScalarFieldEnum)[keyof typeof SentenceScalarFieldEnum]


  ;export  const UserScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  ;export  type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  ;export  const UsersOnWordsScalarFieldEnum: {
    userId: 'userId',
    wordId: 'wordId',
    level: 'level',
    lastTimeRecalledCorrectly: 'lastTimeRecalledCorrectly',
    timeQuotient: 'timeQuotient'
  };

  ;export  type UsersOnWordsScalarFieldEnum = (typeof UsersOnWordsScalarFieldEnum)[keyof typeof UsersOnWordsScalarFieldEnum]


  ;export  const UsersOnMeaningsScalarFieldEnum: {
    userId: 'userId',
    meaningId: 'meaningId',
    relation: 'relation'
  };

  ;export  type UsersOnMeaningsScalarFieldEnum = (typeof UsersOnMeaningsScalarFieldEnum)[keyof typeof UsersOnMeaningsScalarFieldEnum]


  ;export  const WordListScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  ;export  type WordListScalarFieldEnum = (typeof WordListScalarFieldEnum)[keyof typeof WordListScalarFieldEnum]


  ;export  const WordsOnWordListsScalarFieldEnum: {
    wordId: 'wordId',
    wordListId: 'wordListId'
  };

  ;export  type WordsOnWordListsScalarFieldEnum = (typeof WordsOnWordListsScalarFieldEnum)[keyof typeof WordsOnWordListsScalarFieldEnum]


  ;export  const UsersOnWordListsScalarFieldEnum: {
    userId: 'userId',
    wordListId: 'wordListId'
  };

  ;export  type UsersOnWordListsScalarFieldEnum = (typeof UsersOnWordListsScalarFieldEnum)[keyof typeof UsersOnWordListsScalarFieldEnum]


  ;export  const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  ;export  type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  ;export  const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  ;export  type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  ;export  const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  ;export  type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  ;export  type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  ;export  type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'WordDefinitionSourceType'
   */
  ;export  type EnumWordDefinitionSourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WordDefinitionSourceType'>
    


  /**
   * Reference to a field of type 'WordDefinitionSourceType[]'
   */
  ;export  type ListEnumWordDefinitionSourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WordDefinitionSourceType[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  ;export  type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  ;export  type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'SentenceSourceType'
   */
  ;export  type EnumSentenceSourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SentenceSourceType'>
    


  /**
   * Reference to a field of type 'SentenceSourceType[]'
   */
  ;export  type ListEnumSentenceSourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SentenceSourceType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  ;export  type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  ;export  type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  ;export  type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  ;export  type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'UserMeaningRelation'
   */
  ;export  type EnumUserMeaningRelationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserMeaningRelation'>
    


  /**
   * Reference to a field of type 'UserMeaningRelation[]'
   */
  ;export  type ListEnumUserMeaningRelationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserMeaningRelation[]'>
    
  /**
   * Deep Input Types
   */


  ;export  type WordWhereInput = {
    AND?: WordWhereInput | WordWhereInput[]
    OR?: WordWhereInput[]
    NOT?: WordWhereInput | WordWhereInput[]
    id?: UuidFilter<"Word"> | string
    word?: StringFilter<"Word"> | string
    transcription?: StringFilter<"Word"> | string
    audio?: StringNullableFilter<"Word"> | string | null
    source?: EnumWordDefinitionSourceTypeFilter<"Word"> | $Enums.WordDefinitionSourceType
    createdAt?: DateTimeFilter<"Word"> | Date | string
    updatedAt?: DateTimeFilter<"Word"> | Date | string
    meanings?: MeaningListRelationFilter
    users?: UsersOnWordsListRelationFilter
    WordsOnWordLists?: WordsOnWordListsListRelationFilter
  }

  ;export  type WordOrderByWithRelationInput = {
    id?: SortOrder
    word?: SortOrder
    transcription?: SortOrder
    audio?: SortOrderInput | SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    meanings?: MeaningOrderByRelationAggregateInput
    users?: UsersOnWordsOrderByRelationAggregateInput
    WordsOnWordLists?: WordsOnWordListsOrderByRelationAggregateInput
  }

  ;export  type WordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    word?: string
    AND?: WordWhereInput | WordWhereInput[]
    OR?: WordWhereInput[]
    NOT?: WordWhereInput | WordWhereInput[]
    transcription?: StringFilter<"Word"> | string
    audio?: StringNullableFilter<"Word"> | string | null
    source?: EnumWordDefinitionSourceTypeFilter<"Word"> | $Enums.WordDefinitionSourceType
    createdAt?: DateTimeFilter<"Word"> | Date | string
    updatedAt?: DateTimeFilter<"Word"> | Date | string
    meanings?: MeaningListRelationFilter
    users?: UsersOnWordsListRelationFilter
    WordsOnWordLists?: WordsOnWordListsListRelationFilter
  }, "id" | "word">

  ;export  type WordOrderByWithAggregationInput = {
    id?: SortOrder
    word?: SortOrder
    transcription?: SortOrder
    audio?: SortOrderInput | SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WordCountOrderByAggregateInput
    _max?: WordMaxOrderByAggregateInput
    _min?: WordMinOrderByAggregateInput
  }

  ;export  type WordScalarWhereWithAggregatesInput = {
    AND?: WordScalarWhereWithAggregatesInput | WordScalarWhereWithAggregatesInput[]
    OR?: WordScalarWhereWithAggregatesInput[]
    NOT?: WordScalarWhereWithAggregatesInput | WordScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Word"> | string
    word?: StringWithAggregatesFilter<"Word"> | string
    transcription?: StringWithAggregatesFilter<"Word"> | string
    audio?: StringNullableWithAggregatesFilter<"Word"> | string | null
    source?: EnumWordDefinitionSourceTypeWithAggregatesFilter<"Word"> | $Enums.WordDefinitionSourceType
    createdAt?: DateTimeWithAggregatesFilter<"Word"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Word"> | Date | string
  }

  ;export  type MeaningWhereInput = {
    AND?: MeaningWhereInput | MeaningWhereInput[]
    OR?: MeaningWhereInput[]
    NOT?: MeaningWhereInput | MeaningWhereInput[]
    id?: UuidFilter<"Meaning"> | string
    term?: StringFilter<"Meaning"> | string
    partOfSpeech?: StringFilter<"Meaning"> | string
    meaning?: StringFilter<"Meaning"> | string
    synonyms?: StringNullableListFilter<"Meaning">
    antonyms?: StringNullableListFilter<"Meaning">
    createdAt?: DateTimeFilter<"Meaning"> | Date | string
    updatedAt?: DateTimeFilter<"Meaning"> | Date | string
    wordId?: UuidFilter<"Meaning"> | string
    sentences?: SentenceListRelationFilter
    Word?: XOR<WordRelationFilter, WordWhereInput>
    users?: UsersOnMeaningsListRelationFilter
  }

  ;export  type MeaningOrderByWithRelationInput = {
    id?: SortOrder
    term?: SortOrder
    partOfSpeech?: SortOrder
    meaning?: SortOrder
    synonyms?: SortOrder
    antonyms?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    wordId?: SortOrder
    sentences?: SentenceOrderByRelationAggregateInput
    Word?: WordOrderByWithRelationInput
    users?: UsersOnMeaningsOrderByRelationAggregateInput
  }

  ;export  type MeaningWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MeaningWhereInput | MeaningWhereInput[]
    OR?: MeaningWhereInput[]
    NOT?: MeaningWhereInput | MeaningWhereInput[]
    term?: StringFilter<"Meaning"> | string
    partOfSpeech?: StringFilter<"Meaning"> | string
    meaning?: StringFilter<"Meaning"> | string
    synonyms?: StringNullableListFilter<"Meaning">
    antonyms?: StringNullableListFilter<"Meaning">
    createdAt?: DateTimeFilter<"Meaning"> | Date | string
    updatedAt?: DateTimeFilter<"Meaning"> | Date | string
    wordId?: UuidFilter<"Meaning"> | string
    sentences?: SentenceListRelationFilter
    Word?: XOR<WordRelationFilter, WordWhereInput>
    users?: UsersOnMeaningsListRelationFilter
  }, "id">

  ;export  type MeaningOrderByWithAggregationInput = {
    id?: SortOrder
    term?: SortOrder
    partOfSpeech?: SortOrder
    meaning?: SortOrder
    synonyms?: SortOrder
    antonyms?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    wordId?: SortOrder
    _count?: MeaningCountOrderByAggregateInput
    _max?: MeaningMaxOrderByAggregateInput
    _min?: MeaningMinOrderByAggregateInput
  }

  ;export  type MeaningScalarWhereWithAggregatesInput = {
    AND?: MeaningScalarWhereWithAggregatesInput | MeaningScalarWhereWithAggregatesInput[]
    OR?: MeaningScalarWhereWithAggregatesInput[]
    NOT?: MeaningScalarWhereWithAggregatesInput | MeaningScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Meaning"> | string
    term?: StringWithAggregatesFilter<"Meaning"> | string
    partOfSpeech?: StringWithAggregatesFilter<"Meaning"> | string
    meaning?: StringWithAggregatesFilter<"Meaning"> | string
    synonyms?: StringNullableListFilter<"Meaning">
    antonyms?: StringNullableListFilter<"Meaning">
    createdAt?: DateTimeWithAggregatesFilter<"Meaning"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Meaning"> | Date | string
    wordId?: UuidWithAggregatesFilter<"Meaning"> | string
  }

  ;export  type SentenceWhereInput = {
    AND?: SentenceWhereInput | SentenceWhereInput[]
    OR?: SentenceWhereInput[]
    NOT?: SentenceWhereInput | SentenceWhereInput[]
    id?: UuidFilter<"Sentence"> | string
    fullText?: StringFilter<"Sentence"> | string
    wordToLearn?: StringFilter<"Sentence"> | string
    options?: StringNullableListFilter<"Sentence">
    meaningId?: UuidFilter<"Sentence"> | string
    source?: EnumSentenceSourceTypeFilter<"Sentence"> | $Enums.SentenceSourceType
    greatVotesCount?: IntFilter<"Sentence"> | number
    fineVotesCount?: IntFilter<"Sentence"> | number
    badVotesCount?: IntFilter<"Sentence"> | number
    createdAt?: DateTimeFilter<"Sentence"> | Date | string
    updatedAt?: DateTimeFilter<"Sentence"> | Date | string
    Meaning?: XOR<MeaningRelationFilter, MeaningWhereInput>
  }

  ;export  type SentenceOrderByWithRelationInput = {
    id?: SortOrder
    fullText?: SortOrder
    wordToLearn?: SortOrder
    options?: SortOrder
    meaningId?: SortOrder
    source?: SortOrder
    greatVotesCount?: SortOrder
    fineVotesCount?: SortOrder
    badVotesCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Meaning?: MeaningOrderByWithRelationInput
  }

  ;export  type SentenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SentenceWhereInput | SentenceWhereInput[]
    OR?: SentenceWhereInput[]
    NOT?: SentenceWhereInput | SentenceWhereInput[]
    fullText?: StringFilter<"Sentence"> | string
    wordToLearn?: StringFilter<"Sentence"> | string
    options?: StringNullableListFilter<"Sentence">
    meaningId?: UuidFilter<"Sentence"> | string
    source?: EnumSentenceSourceTypeFilter<"Sentence"> | $Enums.SentenceSourceType
    greatVotesCount?: IntFilter<"Sentence"> | number
    fineVotesCount?: IntFilter<"Sentence"> | number
    badVotesCount?: IntFilter<"Sentence"> | number
    createdAt?: DateTimeFilter<"Sentence"> | Date | string
    updatedAt?: DateTimeFilter<"Sentence"> | Date | string
    Meaning?: XOR<MeaningRelationFilter, MeaningWhereInput>
  }, "id">

  ;export  type SentenceOrderByWithAggregationInput = {
    id?: SortOrder
    fullText?: SortOrder
    wordToLearn?: SortOrder
    options?: SortOrder
    meaningId?: SortOrder
    source?: SortOrder
    greatVotesCount?: SortOrder
    fineVotesCount?: SortOrder
    badVotesCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SentenceCountOrderByAggregateInput
    _avg?: SentenceAvgOrderByAggregateInput
    _max?: SentenceMaxOrderByAggregateInput
    _min?: SentenceMinOrderByAggregateInput
    _sum?: SentenceSumOrderByAggregateInput
  }

  ;export  type SentenceScalarWhereWithAggregatesInput = {
    AND?: SentenceScalarWhereWithAggregatesInput | SentenceScalarWhereWithAggregatesInput[]
    OR?: SentenceScalarWhereWithAggregatesInput[]
    NOT?: SentenceScalarWhereWithAggregatesInput | SentenceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Sentence"> | string
    fullText?: StringWithAggregatesFilter<"Sentence"> | string
    wordToLearn?: StringWithAggregatesFilter<"Sentence"> | string
    options?: StringNullableListFilter<"Sentence">
    meaningId?: UuidWithAggregatesFilter<"Sentence"> | string
    source?: EnumSentenceSourceTypeWithAggregatesFilter<"Sentence"> | $Enums.SentenceSourceType
    greatVotesCount?: IntWithAggregatesFilter<"Sentence"> | number
    fineVotesCount?: IntWithAggregatesFilter<"Sentence"> | number
    badVotesCount?: IntWithAggregatesFilter<"Sentence"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Sentence"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Sentence"> | Date | string
  }

  ;export  type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: UuidFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    words?: UsersOnWordsListRelationFilter
    meanings?: UsersOnMeaningsListRelationFilter
    UsersOnWordLists?: UsersOnWordListsListRelationFilter
  }

  ;export  type UserOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    words?: UsersOnWordsOrderByRelationAggregateInput
    meanings?: UsersOnMeaningsOrderByRelationAggregateInput
    UsersOnWordLists?: UsersOnWordListsOrderByRelationAggregateInput
  }

  ;export  type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    words?: UsersOnWordsListRelationFilter
    meanings?: UsersOnMeaningsListRelationFilter
    UsersOnWordLists?: UsersOnWordListsListRelationFilter
  }, "id">

  ;export  type UserOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  ;export  type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  ;export  type UsersOnWordsWhereInput = {
    AND?: UsersOnWordsWhereInput | UsersOnWordsWhereInput[]
    OR?: UsersOnWordsWhereInput[]
    NOT?: UsersOnWordsWhereInput | UsersOnWordsWhereInput[]
    userId?: UuidFilter<"UsersOnWords"> | string
    wordId?: UuidFilter<"UsersOnWords"> | string
    level?: IntFilter<"UsersOnWords"> | number
    lastTimeRecalledCorrectly?: DateTimeFilter<"UsersOnWords"> | Date | string
    timeQuotient?: FloatFilter<"UsersOnWords"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    word?: XOR<WordRelationFilter, WordWhereInput>
  }

  ;export  type UsersOnWordsOrderByWithRelationInput = {
    userId?: SortOrder
    wordId?: SortOrder
    level?: SortOrder
    lastTimeRecalledCorrectly?: SortOrder
    timeQuotient?: SortOrder
    user?: UserOrderByWithRelationInput
    word?: WordOrderByWithRelationInput
  }

  ;export  type UsersOnWordsWhereUniqueInput = Prisma.AtLeast<{
    userId_wordId?: UsersOnWordsUserIdWordIdCompoundUniqueInput
    AND?: UsersOnWordsWhereInput | UsersOnWordsWhereInput[]
    OR?: UsersOnWordsWhereInput[]
    NOT?: UsersOnWordsWhereInput | UsersOnWordsWhereInput[]
    userId?: UuidFilter<"UsersOnWords"> | string
    wordId?: UuidFilter<"UsersOnWords"> | string
    level?: IntFilter<"UsersOnWords"> | number
    lastTimeRecalledCorrectly?: DateTimeFilter<"UsersOnWords"> | Date | string
    timeQuotient?: FloatFilter<"UsersOnWords"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    word?: XOR<WordRelationFilter, WordWhereInput>
  }, "userId_wordId">

  ;export  type UsersOnWordsOrderByWithAggregationInput = {
    userId?: SortOrder
    wordId?: SortOrder
    level?: SortOrder
    lastTimeRecalledCorrectly?: SortOrder
    timeQuotient?: SortOrder
    _count?: UsersOnWordsCountOrderByAggregateInput
    _avg?: UsersOnWordsAvgOrderByAggregateInput
    _max?: UsersOnWordsMaxOrderByAggregateInput
    _min?: UsersOnWordsMinOrderByAggregateInput
    _sum?: UsersOnWordsSumOrderByAggregateInput
  }

  ;export  type UsersOnWordsScalarWhereWithAggregatesInput = {
    AND?: UsersOnWordsScalarWhereWithAggregatesInput | UsersOnWordsScalarWhereWithAggregatesInput[]
    OR?: UsersOnWordsScalarWhereWithAggregatesInput[]
    NOT?: UsersOnWordsScalarWhereWithAggregatesInput | UsersOnWordsScalarWhereWithAggregatesInput[]
    userId?: UuidWithAggregatesFilter<"UsersOnWords"> | string
    wordId?: UuidWithAggregatesFilter<"UsersOnWords"> | string
    level?: IntWithAggregatesFilter<"UsersOnWords"> | number
    lastTimeRecalledCorrectly?: DateTimeWithAggregatesFilter<"UsersOnWords"> | Date | string
    timeQuotient?: FloatWithAggregatesFilter<"UsersOnWords"> | number
  }

  ;export  type UsersOnMeaningsWhereInput = {
    AND?: UsersOnMeaningsWhereInput | UsersOnMeaningsWhereInput[]
    OR?: UsersOnMeaningsWhereInput[]
    NOT?: UsersOnMeaningsWhereInput | UsersOnMeaningsWhereInput[]
    userId?: UuidFilter<"UsersOnMeanings"> | string
    meaningId?: UuidFilter<"UsersOnMeanings"> | string
    relation?: EnumUserMeaningRelationFilter<"UsersOnMeanings"> | $Enums.UserMeaningRelation
    user?: XOR<UserRelationFilter, UserWhereInput>
    meaning?: XOR<MeaningRelationFilter, MeaningWhereInput>
  }

  ;export  type UsersOnMeaningsOrderByWithRelationInput = {
    userId?: SortOrder
    meaningId?: SortOrder
    relation?: SortOrder
    user?: UserOrderByWithRelationInput
    meaning?: MeaningOrderByWithRelationInput
  }

  ;export  type UsersOnMeaningsWhereUniqueInput = Prisma.AtLeast<{
    userId_meaningId?: UsersOnMeaningsUserIdMeaningIdCompoundUniqueInput
    AND?: UsersOnMeaningsWhereInput | UsersOnMeaningsWhereInput[]
    OR?: UsersOnMeaningsWhereInput[]
    NOT?: UsersOnMeaningsWhereInput | UsersOnMeaningsWhereInput[]
    userId?: UuidFilter<"UsersOnMeanings"> | string
    meaningId?: UuidFilter<"UsersOnMeanings"> | string
    relation?: EnumUserMeaningRelationFilter<"UsersOnMeanings"> | $Enums.UserMeaningRelation
    user?: XOR<UserRelationFilter, UserWhereInput>
    meaning?: XOR<MeaningRelationFilter, MeaningWhereInput>
  }, "userId_meaningId">

  ;export  type UsersOnMeaningsOrderByWithAggregationInput = {
    userId?: SortOrder
    meaningId?: SortOrder
    relation?: SortOrder
    _count?: UsersOnMeaningsCountOrderByAggregateInput
    _max?: UsersOnMeaningsMaxOrderByAggregateInput
    _min?: UsersOnMeaningsMinOrderByAggregateInput
  }

  ;export  type UsersOnMeaningsScalarWhereWithAggregatesInput = {
    AND?: UsersOnMeaningsScalarWhereWithAggregatesInput | UsersOnMeaningsScalarWhereWithAggregatesInput[]
    OR?: UsersOnMeaningsScalarWhereWithAggregatesInput[]
    NOT?: UsersOnMeaningsScalarWhereWithAggregatesInput | UsersOnMeaningsScalarWhereWithAggregatesInput[]
    userId?: UuidWithAggregatesFilter<"UsersOnMeanings"> | string
    meaningId?: UuidWithAggregatesFilter<"UsersOnMeanings"> | string
    relation?: EnumUserMeaningRelationWithAggregatesFilter<"UsersOnMeanings"> | $Enums.UserMeaningRelation
  }

  ;export  type WordListWhereInput = {
    AND?: WordListWhereInput | WordListWhereInput[]
    OR?: WordListWhereInput[]
    NOT?: WordListWhereInput | WordListWhereInput[]
    id?: UuidFilter<"WordList"> | string
    name?: StringFilter<"WordList"> | string
    description?: StringFilter<"WordList"> | string
    createdAt?: DateTimeFilter<"WordList"> | Date | string
    updatedAt?: DateTimeFilter<"WordList"> | Date | string
    words?: WordsOnWordListsListRelationFilter
    users?: UsersOnWordListsListRelationFilter
  }

  ;export  type WordListOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    words?: WordsOnWordListsOrderByRelationAggregateInput
    users?: UsersOnWordListsOrderByRelationAggregateInput
  }

  ;export  type WordListWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: WordListWhereInput | WordListWhereInput[]
    OR?: WordListWhereInput[]
    NOT?: WordListWhereInput | WordListWhereInput[]
    description?: StringFilter<"WordList"> | string
    createdAt?: DateTimeFilter<"WordList"> | Date | string
    updatedAt?: DateTimeFilter<"WordList"> | Date | string
    words?: WordsOnWordListsListRelationFilter
    users?: UsersOnWordListsListRelationFilter
  }, "id" | "name">

  ;export  type WordListOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WordListCountOrderByAggregateInput
    _max?: WordListMaxOrderByAggregateInput
    _min?: WordListMinOrderByAggregateInput
  }

  ;export  type WordListScalarWhereWithAggregatesInput = {
    AND?: WordListScalarWhereWithAggregatesInput | WordListScalarWhereWithAggregatesInput[]
    OR?: WordListScalarWhereWithAggregatesInput[]
    NOT?: WordListScalarWhereWithAggregatesInput | WordListScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"WordList"> | string
    name?: StringWithAggregatesFilter<"WordList"> | string
    description?: StringWithAggregatesFilter<"WordList"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WordList"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WordList"> | Date | string
  }

  ;export  type WordsOnWordListsWhereInput = {
    AND?: WordsOnWordListsWhereInput | WordsOnWordListsWhereInput[]
    OR?: WordsOnWordListsWhereInput[]
    NOT?: WordsOnWordListsWhereInput | WordsOnWordListsWhereInput[]
    wordId?: UuidFilter<"WordsOnWordLists"> | string
    wordListId?: UuidFilter<"WordsOnWordLists"> | string
    word?: XOR<WordRelationFilter, WordWhereInput>
    wordList?: XOR<WordListRelationFilter, WordListWhereInput>
  }

  ;export  type WordsOnWordListsOrderByWithRelationInput = {
    wordId?: SortOrder
    wordListId?: SortOrder
    word?: WordOrderByWithRelationInput
    wordList?: WordListOrderByWithRelationInput
  }

  ;export  type WordsOnWordListsWhereUniqueInput = Prisma.AtLeast<{
    wordId_wordListId?: WordsOnWordListsWordIdWordListIdCompoundUniqueInput
    AND?: WordsOnWordListsWhereInput | WordsOnWordListsWhereInput[]
    OR?: WordsOnWordListsWhereInput[]
    NOT?: WordsOnWordListsWhereInput | WordsOnWordListsWhereInput[]
    wordId?: UuidFilter<"WordsOnWordLists"> | string
    wordListId?: UuidFilter<"WordsOnWordLists"> | string
    word?: XOR<WordRelationFilter, WordWhereInput>
    wordList?: XOR<WordListRelationFilter, WordListWhereInput>
  }, "wordId_wordListId">

  ;export  type WordsOnWordListsOrderByWithAggregationInput = {
    wordId?: SortOrder
    wordListId?: SortOrder
    _count?: WordsOnWordListsCountOrderByAggregateInput
    _max?: WordsOnWordListsMaxOrderByAggregateInput
    _min?: WordsOnWordListsMinOrderByAggregateInput
  }

  ;export  type WordsOnWordListsScalarWhereWithAggregatesInput = {
    AND?: WordsOnWordListsScalarWhereWithAggregatesInput | WordsOnWordListsScalarWhereWithAggregatesInput[]
    OR?: WordsOnWordListsScalarWhereWithAggregatesInput[]
    NOT?: WordsOnWordListsScalarWhereWithAggregatesInput | WordsOnWordListsScalarWhereWithAggregatesInput[]
    wordId?: UuidWithAggregatesFilter<"WordsOnWordLists"> | string
    wordListId?: UuidWithAggregatesFilter<"WordsOnWordLists"> | string
  }

  ;export  type UsersOnWordListsWhereInput = {
    AND?: UsersOnWordListsWhereInput | UsersOnWordListsWhereInput[]
    OR?: UsersOnWordListsWhereInput[]
    NOT?: UsersOnWordListsWhereInput | UsersOnWordListsWhereInput[]
    userId?: UuidFilter<"UsersOnWordLists"> | string
    wordListId?: UuidFilter<"UsersOnWordLists"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    wordList?: XOR<WordListRelationFilter, WordListWhereInput>
  }

  ;export  type UsersOnWordListsOrderByWithRelationInput = {
    userId?: SortOrder
    wordListId?: SortOrder
    user?: UserOrderByWithRelationInput
    wordList?: WordListOrderByWithRelationInput
  }

  ;export  type UsersOnWordListsWhereUniqueInput = Prisma.AtLeast<{
    userId_wordListId?: UsersOnWordListsUserIdWordListIdCompoundUniqueInput
    AND?: UsersOnWordListsWhereInput | UsersOnWordListsWhereInput[]
    OR?: UsersOnWordListsWhereInput[]
    NOT?: UsersOnWordListsWhereInput | UsersOnWordListsWhereInput[]
    userId?: UuidFilter<"UsersOnWordLists"> | string
    wordListId?: UuidFilter<"UsersOnWordLists"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    wordList?: XOR<WordListRelationFilter, WordListWhereInput>
  }, "userId_wordListId">

  ;export  type UsersOnWordListsOrderByWithAggregationInput = {
    userId?: SortOrder
    wordListId?: SortOrder
    _count?: UsersOnWordListsCountOrderByAggregateInput
    _max?: UsersOnWordListsMaxOrderByAggregateInput
    _min?: UsersOnWordListsMinOrderByAggregateInput
  }

  ;export  type UsersOnWordListsScalarWhereWithAggregatesInput = {
    AND?: UsersOnWordListsScalarWhereWithAggregatesInput | UsersOnWordListsScalarWhereWithAggregatesInput[]
    OR?: UsersOnWordListsScalarWhereWithAggregatesInput[]
    NOT?: UsersOnWordListsScalarWhereWithAggregatesInput | UsersOnWordListsScalarWhereWithAggregatesInput[]
    userId?: UuidWithAggregatesFilter<"UsersOnWordLists"> | string
    wordListId?: UuidWithAggregatesFilter<"UsersOnWordLists"> | string
  }

  ;export  type WordCreateInput = {
    id?: string
    word: string
    transcription: string
    audio?: string | null
    source: $Enums.WordDefinitionSourceType
    createdAt?: Date | string
    updatedAt?: Date | string
    meanings?: MeaningCreateNestedManyWithoutWordInput
    users?: UsersOnWordsCreateNestedManyWithoutWordInput
    WordsOnWordLists?: WordsOnWordListsCreateNestedManyWithoutWordInput
  }

  ;export  type WordUncheckedCreateInput = {
    id?: string
    word: string
    transcription: string
    audio?: string | null
    source: $Enums.WordDefinitionSourceType
    createdAt?: Date | string
    updatedAt?: Date | string
    meanings?: MeaningUncheckedCreateNestedManyWithoutWordInput
    users?: UsersOnWordsUncheckedCreateNestedManyWithoutWordInput
    WordsOnWordLists?: WordsOnWordListsUncheckedCreateNestedManyWithoutWordInput
  }

  ;export  type WordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    word?: StringFieldUpdateOperationsInput | string
    transcription?: StringFieldUpdateOperationsInput | string
    audio?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumWordDefinitionSourceTypeFieldUpdateOperationsInput | $Enums.WordDefinitionSourceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meanings?: MeaningUpdateManyWithoutWordNestedInput
    users?: UsersOnWordsUpdateManyWithoutWordNestedInput
    WordsOnWordLists?: WordsOnWordListsUpdateManyWithoutWordNestedInput
  }

  ;export  type WordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    word?: StringFieldUpdateOperationsInput | string
    transcription?: StringFieldUpdateOperationsInput | string
    audio?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumWordDefinitionSourceTypeFieldUpdateOperationsInput | $Enums.WordDefinitionSourceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meanings?: MeaningUncheckedUpdateManyWithoutWordNestedInput
    users?: UsersOnWordsUncheckedUpdateManyWithoutWordNestedInput
    WordsOnWordLists?: WordsOnWordListsUncheckedUpdateManyWithoutWordNestedInput
  }

  ;export  type WordCreateManyInput = {
    id?: string
    word: string
    transcription: string
    audio?: string | null
    source: $Enums.WordDefinitionSourceType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  ;export  type WordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    word?: StringFieldUpdateOperationsInput | string
    transcription?: StringFieldUpdateOperationsInput | string
    audio?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumWordDefinitionSourceTypeFieldUpdateOperationsInput | $Enums.WordDefinitionSourceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  ;export  type WordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    word?: StringFieldUpdateOperationsInput | string
    transcription?: StringFieldUpdateOperationsInput | string
    audio?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumWordDefinitionSourceTypeFieldUpdateOperationsInput | $Enums.WordDefinitionSourceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  ;export  type MeaningCreateInput = {
    id?: string
    term: string
    partOfSpeech: string
    meaning: string
    synonyms?: MeaningCreatesynonymsInput | string[]
    antonyms?: MeaningCreateantonymsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    sentences?: SentenceCreateNestedManyWithoutMeaningInput
    Word: WordCreateNestedOneWithoutMeaningsInput
    users?: UsersOnMeaningsCreateNestedManyWithoutMeaningInput
  }

  ;export  type MeaningUncheckedCreateInput = {
    id?: string
    term: string
    partOfSpeech: string
    meaning: string
    synonyms?: MeaningCreatesynonymsInput | string[]
    antonyms?: MeaningCreateantonymsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    wordId: string
    sentences?: SentenceUncheckedCreateNestedManyWithoutMeaningInput
    users?: UsersOnMeaningsUncheckedCreateNestedManyWithoutMeaningInput
  }

  ;export  type MeaningUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    partOfSpeech?: StringFieldUpdateOperationsInput | string
    meaning?: StringFieldUpdateOperationsInput | string
    synonyms?: MeaningUpdatesynonymsInput | string[]
    antonyms?: MeaningUpdateantonymsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentences?: SentenceUpdateManyWithoutMeaningNestedInput
    Word?: WordUpdateOneRequiredWithoutMeaningsNestedInput
    users?: UsersOnMeaningsUpdateManyWithoutMeaningNestedInput
  }

  ;export  type MeaningUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    partOfSpeech?: StringFieldUpdateOperationsInput | string
    meaning?: StringFieldUpdateOperationsInput | string
    synonyms?: MeaningUpdatesynonymsInput | string[]
    antonyms?: MeaningUpdateantonymsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wordId?: StringFieldUpdateOperationsInput | string
    sentences?: SentenceUncheckedUpdateManyWithoutMeaningNestedInput
    users?: UsersOnMeaningsUncheckedUpdateManyWithoutMeaningNestedInput
  }

  ;export  type MeaningCreateManyInput = {
    id?: string
    term: string
    partOfSpeech: string
    meaning: string
    synonyms?: MeaningCreatesynonymsInput | string[]
    antonyms?: MeaningCreateantonymsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    wordId: string
  }

  ;export  type MeaningUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    partOfSpeech?: StringFieldUpdateOperationsInput | string
    meaning?: StringFieldUpdateOperationsInput | string
    synonyms?: MeaningUpdatesynonymsInput | string[]
    antonyms?: MeaningUpdateantonymsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  ;export  type MeaningUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    partOfSpeech?: StringFieldUpdateOperationsInput | string
    meaning?: StringFieldUpdateOperationsInput | string
    synonyms?: MeaningUpdatesynonymsInput | string[]
    antonyms?: MeaningUpdateantonymsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wordId?: StringFieldUpdateOperationsInput | string
  }

  ;export  type SentenceCreateInput = {
    id?: string
    fullText: string
    wordToLearn: string
    options?: SentenceCreateoptionsInput | string[]
    source: $Enums.SentenceSourceType
    greatVotesCount?: number
    fineVotesCount?: number
    badVotesCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Meaning: MeaningCreateNestedOneWithoutSentencesInput
  }

  ;export  type SentenceUncheckedCreateInput = {
    id?: string
    fullText: string
    wordToLearn: string
    options?: SentenceCreateoptionsInput | string[]
    meaningId: string
    source: $Enums.SentenceSourceType
    greatVotesCount?: number
    fineVotesCount?: number
    badVotesCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  ;export  type SentenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullText?: StringFieldUpdateOperationsInput | string
    wordToLearn?: StringFieldUpdateOperationsInput | string
    options?: SentenceUpdateoptionsInput | string[]
    source?: EnumSentenceSourceTypeFieldUpdateOperationsInput | $Enums.SentenceSourceType
    greatVotesCount?: IntFieldUpdateOperationsInput | number
    fineVotesCount?: IntFieldUpdateOperationsInput | number
    badVotesCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Meaning?: MeaningUpdateOneRequiredWithoutSentencesNestedInput
  }

  ;export  type SentenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullText?: StringFieldUpdateOperationsInput | string
    wordToLearn?: StringFieldUpdateOperationsInput | string
    options?: SentenceUpdateoptionsInput | string[]
    meaningId?: StringFieldUpdateOperationsInput | string
    source?: EnumSentenceSourceTypeFieldUpdateOperationsInput | $Enums.SentenceSourceType
    greatVotesCount?: IntFieldUpdateOperationsInput | number
    fineVotesCount?: IntFieldUpdateOperationsInput | number
    badVotesCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  ;export  type SentenceCreateManyInput = {
    id?: string
    fullText: string
    wordToLearn: string
    options?: SentenceCreateoptionsInput | string[]
    meaningId: string
    source: $Enums.SentenceSourceType
    greatVotesCount?: number
    fineVotesCount?: number
    badVotesCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  ;export  type SentenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullText?: StringFieldUpdateOperationsInput | string
    wordToLearn?: StringFieldUpdateOperationsInput | string
    options?: SentenceUpdateoptionsInput | string[]
    source?: EnumSentenceSourceTypeFieldUpdateOperationsInput | $Enums.SentenceSourceType
    greatVotesCount?: IntFieldUpdateOperationsInput | number
    fineVotesCount?: IntFieldUpdateOperationsInput | number
    badVotesCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  ;export  type SentenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullText?: StringFieldUpdateOperationsInput | string
    wordToLearn?: StringFieldUpdateOperationsInput | string
    options?: SentenceUpdateoptionsInput | string[]
    meaningId?: StringFieldUpdateOperationsInput | string
    source?: EnumSentenceSourceTypeFieldUpdateOperationsInput | $Enums.SentenceSourceType
    greatVotesCount?: IntFieldUpdateOperationsInput | number
    fineVotesCount?: IntFieldUpdateOperationsInput | number
    badVotesCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  ;export  type UserCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    words?: UsersOnWordsCreateNestedManyWithoutUserInput
    meanings?: UsersOnMeaningsCreateNestedManyWithoutUserInput
    UsersOnWordLists?: UsersOnWordListsCreateNestedManyWithoutUserInput
  }

  ;export  type UserUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    words?: UsersOnWordsUncheckedCreateNestedManyWithoutUserInput
    meanings?: UsersOnMeaningsUncheckedCreateNestedManyWithoutUserInput
    UsersOnWordLists?: UsersOnWordListsUncheckedCreateNestedManyWithoutUserInput
  }

  ;export  type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    words?: UsersOnWordsUpdateManyWithoutUserNestedInput
    meanings?: UsersOnMeaningsUpdateManyWithoutUserNestedInput
    UsersOnWordLists?: UsersOnWordListsUpdateManyWithoutUserNestedInput
  }

  ;export  type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    words?: UsersOnWordsUncheckedUpdateManyWithoutUserNestedInput
    meanings?: UsersOnMeaningsUncheckedUpdateManyWithoutUserNestedInput
    UsersOnWordLists?: UsersOnWordListsUncheckedUpdateManyWithoutUserNestedInput
  }

  ;export  type UserCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  ;export  type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  ;export  type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  ;export  type UsersOnWordsCreateInput = {
    level?: number
    lastTimeRecalledCorrectly: Date | string
    timeQuotient?: number
    user: UserCreateNestedOneWithoutWordsInput
    word: WordCreateNestedOneWithoutUsersInput
  }

  ;export  type UsersOnWordsUncheckedCreateInput = {
    userId: string
    wordId: string
    level?: number
    lastTimeRecalledCorrectly: Date | string
    timeQuotient?: number
  }

  ;export  type UsersOnWordsUpdateInput = {
    level?: IntFieldUpdateOperationsInput | number
    lastTimeRecalledCorrectly?: DateTimeFieldUpdateOperationsInput | Date | string
    timeQuotient?: FloatFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutWordsNestedInput
    word?: WordUpdateOneRequiredWithoutUsersNestedInput
  }

  ;export  type UsersOnWordsUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    wordId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    lastTimeRecalledCorrectly?: DateTimeFieldUpdateOperationsInput | Date | string
    timeQuotient?: FloatFieldUpdateOperationsInput | number
  }

  ;export  type UsersOnWordsCreateManyInput = {
    userId: string
    wordId: string
    level?: number
    lastTimeRecalledCorrectly: Date | string
    timeQuotient?: number
  }

  ;export  type UsersOnWordsUpdateManyMutationInput = {
    level?: IntFieldUpdateOperationsInput | number
    lastTimeRecalledCorrectly?: DateTimeFieldUpdateOperationsInput | Date | string
    timeQuotient?: FloatFieldUpdateOperationsInput | number
  }

  ;export  type UsersOnWordsUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    wordId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    lastTimeRecalledCorrectly?: DateTimeFieldUpdateOperationsInput | Date | string
    timeQuotient?: FloatFieldUpdateOperationsInput | number
  }

  ;export  type UsersOnMeaningsCreateInput = {
    relation?: $Enums.UserMeaningRelation
    user: UserCreateNestedOneWithoutMeaningsInput
    meaning: MeaningCreateNestedOneWithoutUsersInput
  }

  ;export  type UsersOnMeaningsUncheckedCreateInput = {
    userId: string
    meaningId: string
    relation?: $Enums.UserMeaningRelation
  }

  ;export  type UsersOnMeaningsUpdateInput = {
    relation?: EnumUserMeaningRelationFieldUpdateOperationsInput | $Enums.UserMeaningRelation
    user?: UserUpdateOneRequiredWithoutMeaningsNestedInput
    meaning?: MeaningUpdateOneRequiredWithoutUsersNestedInput
  }

  ;export  type UsersOnMeaningsUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    meaningId?: StringFieldUpdateOperationsInput | string
    relation?: EnumUserMeaningRelationFieldUpdateOperationsInput | $Enums.UserMeaningRelation
  }

  ;export  type UsersOnMeaningsCreateManyInput = {
    userId: string
    meaningId: string
    relation?: $Enums.UserMeaningRelation
  }

  ;export  type UsersOnMeaningsUpdateManyMutationInput = {
    relation?: EnumUserMeaningRelationFieldUpdateOperationsInput | $Enums.UserMeaningRelation
  }

  ;export  type UsersOnMeaningsUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    meaningId?: StringFieldUpdateOperationsInput | string
    relation?: EnumUserMeaningRelationFieldUpdateOperationsInput | $Enums.UserMeaningRelation
  }

  ;export  type WordListCreateInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    words?: WordsOnWordListsCreateNestedManyWithoutWordListInput
    users?: UsersOnWordListsCreateNestedManyWithoutWordListInput
  }

  ;export  type WordListUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    words?: WordsOnWordListsUncheckedCreateNestedManyWithoutWordListInput
    users?: UsersOnWordListsUncheckedCreateNestedManyWithoutWordListInput
  }

  ;export  type WordListUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    words?: WordsOnWordListsUpdateManyWithoutWordListNestedInput
    users?: UsersOnWordListsUpdateManyWithoutWordListNestedInput
  }

  ;export  type WordListUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    words?: WordsOnWordListsUncheckedUpdateManyWithoutWordListNestedInput
    users?: UsersOnWordListsUncheckedUpdateManyWithoutWordListNestedInput
  }

  ;export  type WordListCreateManyInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  ;export  type WordListUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  ;export  type WordListUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  ;export  type WordsOnWordListsCreateInput = {
    word: WordCreateNestedOneWithoutWordsOnWordListsInput
    wordList: WordListCreateNestedOneWithoutWordsInput
  }

  ;export  type WordsOnWordListsUncheckedCreateInput = {
    wordId: string
    wordListId: string
  }

  ;export  type WordsOnWordListsUpdateInput = {
    word?: WordUpdateOneRequiredWithoutWordsOnWordListsNestedInput
    wordList?: WordListUpdateOneRequiredWithoutWordsNestedInput
  }

  ;export  type WordsOnWordListsUncheckedUpdateInput = {
    wordId?: StringFieldUpdateOperationsInput | string
    wordListId?: StringFieldUpdateOperationsInput | string
  }

  ;export  type WordsOnWordListsCreateManyInput = {
    wordId: string
    wordListId: string
  }

  ;export  type WordsOnWordListsUpdateManyMutationInput = {

  }

  ;export  type WordsOnWordListsUncheckedUpdateManyInput = {
    wordId?: StringFieldUpdateOperationsInput | string
    wordListId?: StringFieldUpdateOperationsInput | string
  }

  ;export  type UsersOnWordListsCreateInput = {
    user: UserCreateNestedOneWithoutUsersOnWordListsInput
    wordList: WordListCreateNestedOneWithoutUsersInput
  }

  ;export  type UsersOnWordListsUncheckedCreateInput = {
    userId: string
    wordListId: string
  }

  ;export  type UsersOnWordListsUpdateInput = {
    user?: UserUpdateOneRequiredWithoutUsersOnWordListsNestedInput
    wordList?: WordListUpdateOneRequiredWithoutUsersNestedInput
  }

  ;export  type UsersOnWordListsUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    wordListId?: StringFieldUpdateOperationsInput | string
  }

  ;export  type UsersOnWordListsCreateManyInput = {
    userId: string
    wordListId: string
  }

  ;export  type UsersOnWordListsUpdateManyMutationInput = {

  }

  ;export  type UsersOnWordListsUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    wordListId?: StringFieldUpdateOperationsInput | string
  }

  ;export  type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  ;export  type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  ;export  type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  ;export  type EnumWordDefinitionSourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WordDefinitionSourceType | EnumWordDefinitionSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WordDefinitionSourceType[] | ListEnumWordDefinitionSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WordDefinitionSourceType[] | ListEnumWordDefinitionSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWordDefinitionSourceTypeFilter<$PrismaModel> | $Enums.WordDefinitionSourceType
  }

  ;export  type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  ;export  type MeaningListRelationFilter = {
    every?: MeaningWhereInput
    some?: MeaningWhereInput
    none?: MeaningWhereInput
  }

  ;export  type UsersOnWordsListRelationFilter = {
    every?: UsersOnWordsWhereInput
    some?: UsersOnWordsWhereInput
    none?: UsersOnWordsWhereInput
  }

  ;export  type WordsOnWordListsListRelationFilter = {
    every?: WordsOnWordListsWhereInput
    some?: WordsOnWordListsWhereInput
    none?: WordsOnWordListsWhereInput
  }

  ;export  type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  ;export  type MeaningOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  ;export  type UsersOnWordsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  ;export  type WordsOnWordListsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  ;export  type WordCountOrderByAggregateInput = {
    id?: SortOrder
    word?: SortOrder
    transcription?: SortOrder
    audio?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  ;export  type WordMaxOrderByAggregateInput = {
    id?: SortOrder
    word?: SortOrder
    transcription?: SortOrder
    audio?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  ;export  type WordMinOrderByAggregateInput = {
    id?: SortOrder
    word?: SortOrder
    transcription?: SortOrder
    audio?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  ;export  type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  ;export  type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  ;export  type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  ;export  type EnumWordDefinitionSourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WordDefinitionSourceType | EnumWordDefinitionSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WordDefinitionSourceType[] | ListEnumWordDefinitionSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WordDefinitionSourceType[] | ListEnumWordDefinitionSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWordDefinitionSourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.WordDefinitionSourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWordDefinitionSourceTypeFilter<$PrismaModel>
    _max?: NestedEnumWordDefinitionSourceTypeFilter<$PrismaModel>
  }

  ;export  type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  ;export  type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  ;export  type SentenceListRelationFilter = {
    every?: SentenceWhereInput
    some?: SentenceWhereInput
    none?: SentenceWhereInput
  }

  ;export  type WordRelationFilter = {
    is?: WordWhereInput
    isNot?: WordWhereInput
  }

  ;export  type UsersOnMeaningsListRelationFilter = {
    every?: UsersOnMeaningsWhereInput
    some?: UsersOnMeaningsWhereInput
    none?: UsersOnMeaningsWhereInput
  }

  ;export  type SentenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  ;export  type UsersOnMeaningsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  ;export  type MeaningCountOrderByAggregateInput = {
    id?: SortOrder
    term?: SortOrder
    partOfSpeech?: SortOrder
    meaning?: SortOrder
    synonyms?: SortOrder
    antonyms?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    wordId?: SortOrder
  }

  ;export  type MeaningMaxOrderByAggregateInput = {
    id?: SortOrder
    term?: SortOrder
    partOfSpeech?: SortOrder
    meaning?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    wordId?: SortOrder
  }

  ;export  type MeaningMinOrderByAggregateInput = {
    id?: SortOrder
    term?: SortOrder
    partOfSpeech?: SortOrder
    meaning?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    wordId?: SortOrder
  }

  ;export  type EnumSentenceSourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SentenceSourceType | EnumSentenceSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SentenceSourceType[] | ListEnumSentenceSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SentenceSourceType[] | ListEnumSentenceSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSentenceSourceTypeFilter<$PrismaModel> | $Enums.SentenceSourceType
  }

  ;export  type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  ;export  type MeaningRelationFilter = {
    is?: MeaningWhereInput
    isNot?: MeaningWhereInput
  }

  ;export  type SentenceCountOrderByAggregateInput = {
    id?: SortOrder
    fullText?: SortOrder
    wordToLearn?: SortOrder
    options?: SortOrder
    meaningId?: SortOrder
    source?: SortOrder
    greatVotesCount?: SortOrder
    fineVotesCount?: SortOrder
    badVotesCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  ;export  type SentenceAvgOrderByAggregateInput = {
    greatVotesCount?: SortOrder
    fineVotesCount?: SortOrder
    badVotesCount?: SortOrder
  }

  ;export  type SentenceMaxOrderByAggregateInput = {
    id?: SortOrder
    fullText?: SortOrder
    wordToLearn?: SortOrder
    meaningId?: SortOrder
    source?: SortOrder
    greatVotesCount?: SortOrder
    fineVotesCount?: SortOrder
    badVotesCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  ;export  type SentenceMinOrderByAggregateInput = {
    id?: SortOrder
    fullText?: SortOrder
    wordToLearn?: SortOrder
    meaningId?: SortOrder
    source?: SortOrder
    greatVotesCount?: SortOrder
    fineVotesCount?: SortOrder
    badVotesCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  ;export  type SentenceSumOrderByAggregateInput = {
    greatVotesCount?: SortOrder
    fineVotesCount?: SortOrder
    badVotesCount?: SortOrder
  }

  ;export  type EnumSentenceSourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SentenceSourceType | EnumSentenceSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SentenceSourceType[] | ListEnumSentenceSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SentenceSourceType[] | ListEnumSentenceSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSentenceSourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.SentenceSourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSentenceSourceTypeFilter<$PrismaModel>
    _max?: NestedEnumSentenceSourceTypeFilter<$PrismaModel>
  }

  ;export  type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  ;export  type UsersOnWordListsListRelationFilter = {
    every?: UsersOnWordListsWhereInput
    some?: UsersOnWordListsWhereInput
    none?: UsersOnWordListsWhereInput
  }

  ;export  type UsersOnWordListsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  ;export  type UserCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  ;export  type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  ;export  type UserMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  ;export  type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  ;export  type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  ;export  type UsersOnWordsUserIdWordIdCompoundUniqueInput = {
    userId: string
    wordId: string
  }

  ;export  type UsersOnWordsCountOrderByAggregateInput = {
    userId?: SortOrder
    wordId?: SortOrder
    level?: SortOrder
    lastTimeRecalledCorrectly?: SortOrder
    timeQuotient?: SortOrder
  }

  ;export  type UsersOnWordsAvgOrderByAggregateInput = {
    level?: SortOrder
    timeQuotient?: SortOrder
  }

  ;export  type UsersOnWordsMaxOrderByAggregateInput = {
    userId?: SortOrder
    wordId?: SortOrder
    level?: SortOrder
    lastTimeRecalledCorrectly?: SortOrder
    timeQuotient?: SortOrder
  }

  ;export  type UsersOnWordsMinOrderByAggregateInput = {
    userId?: SortOrder
    wordId?: SortOrder
    level?: SortOrder
    lastTimeRecalledCorrectly?: SortOrder
    timeQuotient?: SortOrder
  }

  ;export  type UsersOnWordsSumOrderByAggregateInput = {
    level?: SortOrder
    timeQuotient?: SortOrder
  }

  ;export  type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  ;export  type EnumUserMeaningRelationFilter<$PrismaModel = never> = {
    equals?: $Enums.UserMeaningRelation | EnumUserMeaningRelationFieldRefInput<$PrismaModel>
    in?: $Enums.UserMeaningRelation[] | ListEnumUserMeaningRelationFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserMeaningRelation[] | ListEnumUserMeaningRelationFieldRefInput<$PrismaModel>
    not?: NestedEnumUserMeaningRelationFilter<$PrismaModel> | $Enums.UserMeaningRelation
  }

  ;export  type UsersOnMeaningsUserIdMeaningIdCompoundUniqueInput = {
    userId: string
    meaningId: string
  }

  ;export  type UsersOnMeaningsCountOrderByAggregateInput = {
    userId?: SortOrder
    meaningId?: SortOrder
    relation?: SortOrder
  }

  ;export  type UsersOnMeaningsMaxOrderByAggregateInput = {
    userId?: SortOrder
    meaningId?: SortOrder
    relation?: SortOrder
  }

  ;export  type UsersOnMeaningsMinOrderByAggregateInput = {
    userId?: SortOrder
    meaningId?: SortOrder
    relation?: SortOrder
  }

  ;export  type EnumUserMeaningRelationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserMeaningRelation | EnumUserMeaningRelationFieldRefInput<$PrismaModel>
    in?: $Enums.UserMeaningRelation[] | ListEnumUserMeaningRelationFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserMeaningRelation[] | ListEnumUserMeaningRelationFieldRefInput<$PrismaModel>
    not?: NestedEnumUserMeaningRelationWithAggregatesFilter<$PrismaModel> | $Enums.UserMeaningRelation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserMeaningRelationFilter<$PrismaModel>
    _max?: NestedEnumUserMeaningRelationFilter<$PrismaModel>
  }

  ;export  type WordListCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  ;export  type WordListMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  ;export  type WordListMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  ;export  type WordListRelationFilter = {
    is?: WordListWhereInput
    isNot?: WordListWhereInput
  }

  ;export  type WordsOnWordListsWordIdWordListIdCompoundUniqueInput = {
    wordId: string
    wordListId: string
  }

  ;export  type WordsOnWordListsCountOrderByAggregateInput = {
    wordId?: SortOrder
    wordListId?: SortOrder
  }

  ;export  type WordsOnWordListsMaxOrderByAggregateInput = {
    wordId?: SortOrder
    wordListId?: SortOrder
  }

  ;export  type WordsOnWordListsMinOrderByAggregateInput = {
    wordId?: SortOrder
    wordListId?: SortOrder
  }

  ;export  type UsersOnWordListsUserIdWordListIdCompoundUniqueInput = {
    userId: string
    wordListId: string
  }

  ;export  type UsersOnWordListsCountOrderByAggregateInput = {
    userId?: SortOrder
    wordListId?: SortOrder
  }

  ;export  type UsersOnWordListsMaxOrderByAggregateInput = {
    userId?: SortOrder
    wordListId?: SortOrder
  }

  ;export  type UsersOnWordListsMinOrderByAggregateInput = {
    userId?: SortOrder
    wordListId?: SortOrder
  }

  ;export  type MeaningCreateNestedManyWithoutWordInput = {
    create?: XOR<MeaningCreateWithoutWordInput, MeaningUncheckedCreateWithoutWordInput> | MeaningCreateWithoutWordInput[] | MeaningUncheckedCreateWithoutWordInput[]
    connectOrCreate?: MeaningCreateOrConnectWithoutWordInput | MeaningCreateOrConnectWithoutWordInput[]
    createMany?: MeaningCreateManyWordInputEnvelope
    connect?: MeaningWhereUniqueInput | MeaningWhereUniqueInput[]
  }

  ;export  type UsersOnWordsCreateNestedManyWithoutWordInput = {
    create?: XOR<UsersOnWordsCreateWithoutWordInput, UsersOnWordsUncheckedCreateWithoutWordInput> | UsersOnWordsCreateWithoutWordInput[] | UsersOnWordsUncheckedCreateWithoutWordInput[]
    connectOrCreate?: UsersOnWordsCreateOrConnectWithoutWordInput | UsersOnWordsCreateOrConnectWithoutWordInput[]
    createMany?: UsersOnWordsCreateManyWordInputEnvelope
    connect?: UsersOnWordsWhereUniqueInput | UsersOnWordsWhereUniqueInput[]
  }

  ;export  type WordsOnWordListsCreateNestedManyWithoutWordInput = {
    create?: XOR<WordsOnWordListsCreateWithoutWordInput, WordsOnWordListsUncheckedCreateWithoutWordInput> | WordsOnWordListsCreateWithoutWordInput[] | WordsOnWordListsUncheckedCreateWithoutWordInput[]
    connectOrCreate?: WordsOnWordListsCreateOrConnectWithoutWordInput | WordsOnWordListsCreateOrConnectWithoutWordInput[]
    createMany?: WordsOnWordListsCreateManyWordInputEnvelope
    connect?: WordsOnWordListsWhereUniqueInput | WordsOnWordListsWhereUniqueInput[]
  }

  ;export  type MeaningUncheckedCreateNestedManyWithoutWordInput = {
    create?: XOR<MeaningCreateWithoutWordInput, MeaningUncheckedCreateWithoutWordInput> | MeaningCreateWithoutWordInput[] | MeaningUncheckedCreateWithoutWordInput[]
    connectOrCreate?: MeaningCreateOrConnectWithoutWordInput | MeaningCreateOrConnectWithoutWordInput[]
    createMany?: MeaningCreateManyWordInputEnvelope
    connect?: MeaningWhereUniqueInput | MeaningWhereUniqueInput[]
  }

  ;export  type UsersOnWordsUncheckedCreateNestedManyWithoutWordInput = {
    create?: XOR<UsersOnWordsCreateWithoutWordInput, UsersOnWordsUncheckedCreateWithoutWordInput> | UsersOnWordsCreateWithoutWordInput[] | UsersOnWordsUncheckedCreateWithoutWordInput[]
    connectOrCreate?: UsersOnWordsCreateOrConnectWithoutWordInput | UsersOnWordsCreateOrConnectWithoutWordInput[]
    createMany?: UsersOnWordsCreateManyWordInputEnvelope
    connect?: UsersOnWordsWhereUniqueInput | UsersOnWordsWhereUniqueInput[]
  }

  ;export  type WordsOnWordListsUncheckedCreateNestedManyWithoutWordInput = {
    create?: XOR<WordsOnWordListsCreateWithoutWordInput, WordsOnWordListsUncheckedCreateWithoutWordInput> | WordsOnWordListsCreateWithoutWordInput[] | WordsOnWordListsUncheckedCreateWithoutWordInput[]
    connectOrCreate?: WordsOnWordListsCreateOrConnectWithoutWordInput | WordsOnWordListsCreateOrConnectWithoutWordInput[]
    createMany?: WordsOnWordListsCreateManyWordInputEnvelope
    connect?: WordsOnWordListsWhereUniqueInput | WordsOnWordListsWhereUniqueInput[]
  }

  ;export  type StringFieldUpdateOperationsInput = {
    set?: string
  }

  ;export  type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  ;export  type EnumWordDefinitionSourceTypeFieldUpdateOperationsInput = {
    set?: $Enums.WordDefinitionSourceType
  }

  ;export  type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  ;export  type MeaningUpdateManyWithoutWordNestedInput = {
    create?: XOR<MeaningCreateWithoutWordInput, MeaningUncheckedCreateWithoutWordInput> | MeaningCreateWithoutWordInput[] | MeaningUncheckedCreateWithoutWordInput[]
    connectOrCreate?: MeaningCreateOrConnectWithoutWordInput | MeaningCreateOrConnectWithoutWordInput[]
    upsert?: MeaningUpsertWithWhereUniqueWithoutWordInput | MeaningUpsertWithWhereUniqueWithoutWordInput[]
    createMany?: MeaningCreateManyWordInputEnvelope
    set?: MeaningWhereUniqueInput | MeaningWhereUniqueInput[]
    disconnect?: MeaningWhereUniqueInput | MeaningWhereUniqueInput[]
    delete?: MeaningWhereUniqueInput | MeaningWhereUniqueInput[]
    connect?: MeaningWhereUniqueInput | MeaningWhereUniqueInput[]
    update?: MeaningUpdateWithWhereUniqueWithoutWordInput | MeaningUpdateWithWhereUniqueWithoutWordInput[]
    updateMany?: MeaningUpdateManyWithWhereWithoutWordInput | MeaningUpdateManyWithWhereWithoutWordInput[]
    deleteMany?: MeaningScalarWhereInput | MeaningScalarWhereInput[]
  }

  ;export  type UsersOnWordsUpdateManyWithoutWordNestedInput = {
    create?: XOR<UsersOnWordsCreateWithoutWordInput, UsersOnWordsUncheckedCreateWithoutWordInput> | UsersOnWordsCreateWithoutWordInput[] | UsersOnWordsUncheckedCreateWithoutWordInput[]
    connectOrCreate?: UsersOnWordsCreateOrConnectWithoutWordInput | UsersOnWordsCreateOrConnectWithoutWordInput[]
    upsert?: UsersOnWordsUpsertWithWhereUniqueWithoutWordInput | UsersOnWordsUpsertWithWhereUniqueWithoutWordInput[]
    createMany?: UsersOnWordsCreateManyWordInputEnvelope
    set?: UsersOnWordsWhereUniqueInput | UsersOnWordsWhereUniqueInput[]
    disconnect?: UsersOnWordsWhereUniqueInput | UsersOnWordsWhereUniqueInput[]
    delete?: UsersOnWordsWhereUniqueInput | UsersOnWordsWhereUniqueInput[]
    connect?: UsersOnWordsWhereUniqueInput | UsersOnWordsWhereUniqueInput[]
    update?: UsersOnWordsUpdateWithWhereUniqueWithoutWordInput | UsersOnWordsUpdateWithWhereUniqueWithoutWordInput[]
    updateMany?: UsersOnWordsUpdateManyWithWhereWithoutWordInput | UsersOnWordsUpdateManyWithWhereWithoutWordInput[]
    deleteMany?: UsersOnWordsScalarWhereInput | UsersOnWordsScalarWhereInput[]
  }

  ;export  type WordsOnWordListsUpdateManyWithoutWordNestedInput = {
    create?: XOR<WordsOnWordListsCreateWithoutWordInput, WordsOnWordListsUncheckedCreateWithoutWordInput> | WordsOnWordListsCreateWithoutWordInput[] | WordsOnWordListsUncheckedCreateWithoutWordInput[]
    connectOrCreate?: WordsOnWordListsCreateOrConnectWithoutWordInput | WordsOnWordListsCreateOrConnectWithoutWordInput[]
    upsert?: WordsOnWordListsUpsertWithWhereUniqueWithoutWordInput | WordsOnWordListsUpsertWithWhereUniqueWithoutWordInput[]
    createMany?: WordsOnWordListsCreateManyWordInputEnvelope
    set?: WordsOnWordListsWhereUniqueInput | WordsOnWordListsWhereUniqueInput[]
    disconnect?: WordsOnWordListsWhereUniqueInput | WordsOnWordListsWhereUniqueInput[]
    delete?: WordsOnWordListsWhereUniqueInput | WordsOnWordListsWhereUniqueInput[]
    connect?: WordsOnWordListsWhereUniqueInput | WordsOnWordListsWhereUniqueInput[]
    update?: WordsOnWordListsUpdateWithWhereUniqueWithoutWordInput | WordsOnWordListsUpdateWithWhereUniqueWithoutWordInput[]
    updateMany?: WordsOnWordListsUpdateManyWithWhereWithoutWordInput | WordsOnWordListsUpdateManyWithWhereWithoutWordInput[]
    deleteMany?: WordsOnWordListsScalarWhereInput | WordsOnWordListsScalarWhereInput[]
  }

  ;export  type MeaningUncheckedUpdateManyWithoutWordNestedInput = {
    create?: XOR<MeaningCreateWithoutWordInput, MeaningUncheckedCreateWithoutWordInput> | MeaningCreateWithoutWordInput[] | MeaningUncheckedCreateWithoutWordInput[]
    connectOrCreate?: MeaningCreateOrConnectWithoutWordInput | MeaningCreateOrConnectWithoutWordInput[]
    upsert?: MeaningUpsertWithWhereUniqueWithoutWordInput | MeaningUpsertWithWhereUniqueWithoutWordInput[]
    createMany?: MeaningCreateManyWordInputEnvelope
    set?: MeaningWhereUniqueInput | MeaningWhereUniqueInput[]
    disconnect?: MeaningWhereUniqueInput | MeaningWhereUniqueInput[]
    delete?: MeaningWhereUniqueInput | MeaningWhereUniqueInput[]
    connect?: MeaningWhereUniqueInput | MeaningWhereUniqueInput[]
    update?: MeaningUpdateWithWhereUniqueWithoutWordInput | MeaningUpdateWithWhereUniqueWithoutWordInput[]
    updateMany?: MeaningUpdateManyWithWhereWithoutWordInput | MeaningUpdateManyWithWhereWithoutWordInput[]
    deleteMany?: MeaningScalarWhereInput | MeaningScalarWhereInput[]
  }

  ;export  type UsersOnWordsUncheckedUpdateManyWithoutWordNestedInput = {
    create?: XOR<UsersOnWordsCreateWithoutWordInput, UsersOnWordsUncheckedCreateWithoutWordInput> | UsersOnWordsCreateWithoutWordInput[] | UsersOnWordsUncheckedCreateWithoutWordInput[]
    connectOrCreate?: UsersOnWordsCreateOrConnectWithoutWordInput | UsersOnWordsCreateOrConnectWithoutWordInput[]
    upsert?: UsersOnWordsUpsertWithWhereUniqueWithoutWordInput | UsersOnWordsUpsertWithWhereUniqueWithoutWordInput[]
    createMany?: UsersOnWordsCreateManyWordInputEnvelope
    set?: UsersOnWordsWhereUniqueInput | UsersOnWordsWhereUniqueInput[]
    disconnect?: UsersOnWordsWhereUniqueInput | UsersOnWordsWhereUniqueInput[]
    delete?: UsersOnWordsWhereUniqueInput | UsersOnWordsWhereUniqueInput[]
    connect?: UsersOnWordsWhereUniqueInput | UsersOnWordsWhereUniqueInput[]
    update?: UsersOnWordsUpdateWithWhereUniqueWithoutWordInput | UsersOnWordsUpdateWithWhereUniqueWithoutWordInput[]
    updateMany?: UsersOnWordsUpdateManyWithWhereWithoutWordInput | UsersOnWordsUpdateManyWithWhereWithoutWordInput[]
    deleteMany?: UsersOnWordsScalarWhereInput | UsersOnWordsScalarWhereInput[]
  }

  ;export  type WordsOnWordListsUncheckedUpdateManyWithoutWordNestedInput = {
    create?: XOR<WordsOnWordListsCreateWithoutWordInput, WordsOnWordListsUncheckedCreateWithoutWordInput> | WordsOnWordListsCreateWithoutWordInput[] | WordsOnWordListsUncheckedCreateWithoutWordInput[]
    connectOrCreate?: WordsOnWordListsCreateOrConnectWithoutWordInput | WordsOnWordListsCreateOrConnectWithoutWordInput[]
    upsert?: WordsOnWordListsUpsertWithWhereUniqueWithoutWordInput | WordsOnWordListsUpsertWithWhereUniqueWithoutWordInput[]
    createMany?: WordsOnWordListsCreateManyWordInputEnvelope
    set?: WordsOnWordListsWhereUniqueInput | WordsOnWordListsWhereUniqueInput[]
    disconnect?: WordsOnWordListsWhereUniqueInput | WordsOnWordListsWhereUniqueInput[]
    delete?: WordsOnWordListsWhereUniqueInput | WordsOnWordListsWhereUniqueInput[]
    connect?: WordsOnWordListsWhereUniqueInput | WordsOnWordListsWhereUniqueInput[]
    update?: WordsOnWordListsUpdateWithWhereUniqueWithoutWordInput | WordsOnWordListsUpdateWithWhereUniqueWithoutWordInput[]
    updateMany?: WordsOnWordListsUpdateManyWithWhereWithoutWordInput | WordsOnWordListsUpdateManyWithWhereWithoutWordInput[]
    deleteMany?: WordsOnWordListsScalarWhereInput | WordsOnWordListsScalarWhereInput[]
  }

  ;export  type MeaningCreatesynonymsInput = {
    set: string[]
  }

  ;export  type MeaningCreateantonymsInput = {
    set: string[]
  }

  ;export  type SentenceCreateNestedManyWithoutMeaningInput = {
    create?: XOR<SentenceCreateWithoutMeaningInput, SentenceUncheckedCreateWithoutMeaningInput> | SentenceCreateWithoutMeaningInput[] | SentenceUncheckedCreateWithoutMeaningInput[]
    connectOrCreate?: SentenceCreateOrConnectWithoutMeaningInput | SentenceCreateOrConnectWithoutMeaningInput[]
    createMany?: SentenceCreateManyMeaningInputEnvelope
    connect?: SentenceWhereUniqueInput | SentenceWhereUniqueInput[]
  }

  ;export  type WordCreateNestedOneWithoutMeaningsInput = {
    create?: XOR<WordCreateWithoutMeaningsInput, WordUncheckedCreateWithoutMeaningsInput>
    connectOrCreate?: WordCreateOrConnectWithoutMeaningsInput
    connect?: WordWhereUniqueInput
  }

  ;export  type UsersOnMeaningsCreateNestedManyWithoutMeaningInput = {
    create?: XOR<UsersOnMeaningsCreateWithoutMeaningInput, UsersOnMeaningsUncheckedCreateWithoutMeaningInput> | UsersOnMeaningsCreateWithoutMeaningInput[] | UsersOnMeaningsUncheckedCreateWithoutMeaningInput[]
    connectOrCreate?: UsersOnMeaningsCreateOrConnectWithoutMeaningInput | UsersOnMeaningsCreateOrConnectWithoutMeaningInput[]
    createMany?: UsersOnMeaningsCreateManyMeaningInputEnvelope
    connect?: UsersOnMeaningsWhereUniqueInput | UsersOnMeaningsWhereUniqueInput[]
  }

  ;export  type SentenceUncheckedCreateNestedManyWithoutMeaningInput = {
    create?: XOR<SentenceCreateWithoutMeaningInput, SentenceUncheckedCreateWithoutMeaningInput> | SentenceCreateWithoutMeaningInput[] | SentenceUncheckedCreateWithoutMeaningInput[]
    connectOrCreate?: SentenceCreateOrConnectWithoutMeaningInput | SentenceCreateOrConnectWithoutMeaningInput[]
    createMany?: SentenceCreateManyMeaningInputEnvelope
    connect?: SentenceWhereUniqueInput | SentenceWhereUniqueInput[]
  }

  ;export  type UsersOnMeaningsUncheckedCreateNestedManyWithoutMeaningInput = {
    create?: XOR<UsersOnMeaningsCreateWithoutMeaningInput, UsersOnMeaningsUncheckedCreateWithoutMeaningInput> | UsersOnMeaningsCreateWithoutMeaningInput[] | UsersOnMeaningsUncheckedCreateWithoutMeaningInput[]
    connectOrCreate?: UsersOnMeaningsCreateOrConnectWithoutMeaningInput | UsersOnMeaningsCreateOrConnectWithoutMeaningInput[]
    createMany?: UsersOnMeaningsCreateManyMeaningInputEnvelope
    connect?: UsersOnMeaningsWhereUniqueInput | UsersOnMeaningsWhereUniqueInput[]
  }

  ;export  type MeaningUpdatesynonymsInput = {
    set?: string[]
    push?: string | string[]
  }

  ;export  type MeaningUpdateantonymsInput = {
    set?: string[]
    push?: string | string[]
  }

  ;export  type SentenceUpdateManyWithoutMeaningNestedInput = {
    create?: XOR<SentenceCreateWithoutMeaningInput, SentenceUncheckedCreateWithoutMeaningInput> | SentenceCreateWithoutMeaningInput[] | SentenceUncheckedCreateWithoutMeaningInput[]
    connectOrCreate?: SentenceCreateOrConnectWithoutMeaningInput | SentenceCreateOrConnectWithoutMeaningInput[]
    upsert?: SentenceUpsertWithWhereUniqueWithoutMeaningInput | SentenceUpsertWithWhereUniqueWithoutMeaningInput[]
    createMany?: SentenceCreateManyMeaningInputEnvelope
    set?: SentenceWhereUniqueInput | SentenceWhereUniqueInput[]
    disconnect?: SentenceWhereUniqueInput | SentenceWhereUniqueInput[]
    delete?: SentenceWhereUniqueInput | SentenceWhereUniqueInput[]
    connect?: SentenceWhereUniqueInput | SentenceWhereUniqueInput[]
    update?: SentenceUpdateWithWhereUniqueWithoutMeaningInput | SentenceUpdateWithWhereUniqueWithoutMeaningInput[]
    updateMany?: SentenceUpdateManyWithWhereWithoutMeaningInput | SentenceUpdateManyWithWhereWithoutMeaningInput[]
    deleteMany?: SentenceScalarWhereInput | SentenceScalarWhereInput[]
  }

  ;export  type WordUpdateOneRequiredWithoutMeaningsNestedInput = {
    create?: XOR<WordCreateWithoutMeaningsInput, WordUncheckedCreateWithoutMeaningsInput>
    connectOrCreate?: WordCreateOrConnectWithoutMeaningsInput
    upsert?: WordUpsertWithoutMeaningsInput
    connect?: WordWhereUniqueInput
    update?: XOR<XOR<WordUpdateToOneWithWhereWithoutMeaningsInput, WordUpdateWithoutMeaningsInput>, WordUncheckedUpdateWithoutMeaningsInput>
  }

  ;export  type UsersOnMeaningsUpdateManyWithoutMeaningNestedInput = {
    create?: XOR<UsersOnMeaningsCreateWithoutMeaningInput, UsersOnMeaningsUncheckedCreateWithoutMeaningInput> | UsersOnMeaningsCreateWithoutMeaningInput[] | UsersOnMeaningsUncheckedCreateWithoutMeaningInput[]
    connectOrCreate?: UsersOnMeaningsCreateOrConnectWithoutMeaningInput | UsersOnMeaningsCreateOrConnectWithoutMeaningInput[]
    upsert?: UsersOnMeaningsUpsertWithWhereUniqueWithoutMeaningInput | UsersOnMeaningsUpsertWithWhereUniqueWithoutMeaningInput[]
    createMany?: UsersOnMeaningsCreateManyMeaningInputEnvelope
    set?: UsersOnMeaningsWhereUniqueInput | UsersOnMeaningsWhereUniqueInput[]
    disconnect?: UsersOnMeaningsWhereUniqueInput | UsersOnMeaningsWhereUniqueInput[]
    delete?: UsersOnMeaningsWhereUniqueInput | UsersOnMeaningsWhereUniqueInput[]
    connect?: UsersOnMeaningsWhereUniqueInput | UsersOnMeaningsWhereUniqueInput[]
    update?: UsersOnMeaningsUpdateWithWhereUniqueWithoutMeaningInput | UsersOnMeaningsUpdateWithWhereUniqueWithoutMeaningInput[]
    updateMany?: UsersOnMeaningsUpdateManyWithWhereWithoutMeaningInput | UsersOnMeaningsUpdateManyWithWhereWithoutMeaningInput[]
    deleteMany?: UsersOnMeaningsScalarWhereInput | UsersOnMeaningsScalarWhereInput[]
  }

  ;export  type SentenceUncheckedUpdateManyWithoutMeaningNestedInput = {
    create?: XOR<SentenceCreateWithoutMeaningInput, SentenceUncheckedCreateWithoutMeaningInput> | SentenceCreateWithoutMeaningInput[] | SentenceUncheckedCreateWithoutMeaningInput[]
    connectOrCreate?: SentenceCreateOrConnectWithoutMeaningInput | SentenceCreateOrConnectWithoutMeaningInput[]
    upsert?: SentenceUpsertWithWhereUniqueWithoutMeaningInput | SentenceUpsertWithWhereUniqueWithoutMeaningInput[]
    createMany?: SentenceCreateManyMeaningInputEnvelope
    set?: SentenceWhereUniqueInput | SentenceWhereUniqueInput[]
    disconnect?: SentenceWhereUniqueInput | SentenceWhereUniqueInput[]
    delete?: SentenceWhereUniqueInput | SentenceWhereUniqueInput[]
    connect?: SentenceWhereUniqueInput | SentenceWhereUniqueInput[]
    update?: SentenceUpdateWithWhereUniqueWithoutMeaningInput | SentenceUpdateWithWhereUniqueWithoutMeaningInput[]
    updateMany?: SentenceUpdateManyWithWhereWithoutMeaningInput | SentenceUpdateManyWithWhereWithoutMeaningInput[]
    deleteMany?: SentenceScalarWhereInput | SentenceScalarWhereInput[]
  }

  ;export  type UsersOnMeaningsUncheckedUpdateManyWithoutMeaningNestedInput = {
    create?: XOR<UsersOnMeaningsCreateWithoutMeaningInput, UsersOnMeaningsUncheckedCreateWithoutMeaningInput> | UsersOnMeaningsCreateWithoutMeaningInput[] | UsersOnMeaningsUncheckedCreateWithoutMeaningInput[]
    connectOrCreate?: UsersOnMeaningsCreateOrConnectWithoutMeaningInput | UsersOnMeaningsCreateOrConnectWithoutMeaningInput[]
    upsert?: UsersOnMeaningsUpsertWithWhereUniqueWithoutMeaningInput | UsersOnMeaningsUpsertWithWhereUniqueWithoutMeaningInput[]
    createMany?: UsersOnMeaningsCreateManyMeaningInputEnvelope
    set?: UsersOnMeaningsWhereUniqueInput | UsersOnMeaningsWhereUniqueInput[]
    disconnect?: UsersOnMeaningsWhereUniqueInput | UsersOnMeaningsWhereUniqueInput[]
    delete?: UsersOnMeaningsWhereUniqueInput | UsersOnMeaningsWhereUniqueInput[]
    connect?: UsersOnMeaningsWhereUniqueInput | UsersOnMeaningsWhereUniqueInput[]
    update?: UsersOnMeaningsUpdateWithWhereUniqueWithoutMeaningInput | UsersOnMeaningsUpdateWithWhereUniqueWithoutMeaningInput[]
    updateMany?: UsersOnMeaningsUpdateManyWithWhereWithoutMeaningInput | UsersOnMeaningsUpdateManyWithWhereWithoutMeaningInput[]
    deleteMany?: UsersOnMeaningsScalarWhereInput | UsersOnMeaningsScalarWhereInput[]
  }

  ;export  type SentenceCreateoptionsInput = {
    set: string[]
  }

  ;export  type MeaningCreateNestedOneWithoutSentencesInput = {
    create?: XOR<MeaningCreateWithoutSentencesInput, MeaningUncheckedCreateWithoutSentencesInput>
    connectOrCreate?: MeaningCreateOrConnectWithoutSentencesInput
    connect?: MeaningWhereUniqueInput
  }

  ;export  type SentenceUpdateoptionsInput = {
    set?: string[]
    push?: string | string[]
  }

  ;export  type EnumSentenceSourceTypeFieldUpdateOperationsInput = {
    set?: $Enums.SentenceSourceType
  }

  ;export  type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  ;export  type MeaningUpdateOneRequiredWithoutSentencesNestedInput = {
    create?: XOR<MeaningCreateWithoutSentencesInput, MeaningUncheckedCreateWithoutSentencesInput>
    connectOrCreate?: MeaningCreateOrConnectWithoutSentencesInput
    upsert?: MeaningUpsertWithoutSentencesInput
    connect?: MeaningWhereUniqueInput
    update?: XOR<XOR<MeaningUpdateToOneWithWhereWithoutSentencesInput, MeaningUpdateWithoutSentencesInput>, MeaningUncheckedUpdateWithoutSentencesInput>
  }

  ;export  type UsersOnWordsCreateNestedManyWithoutUserInput = {
    create?: XOR<UsersOnWordsCreateWithoutUserInput, UsersOnWordsUncheckedCreateWithoutUserInput> | UsersOnWordsCreateWithoutUserInput[] | UsersOnWordsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsersOnWordsCreateOrConnectWithoutUserInput | UsersOnWordsCreateOrConnectWithoutUserInput[]
    createMany?: UsersOnWordsCreateManyUserInputEnvelope
    connect?: UsersOnWordsWhereUniqueInput | UsersOnWordsWhereUniqueInput[]
  }

  ;export  type UsersOnMeaningsCreateNestedManyWithoutUserInput = {
    create?: XOR<UsersOnMeaningsCreateWithoutUserInput, UsersOnMeaningsUncheckedCreateWithoutUserInput> | UsersOnMeaningsCreateWithoutUserInput[] | UsersOnMeaningsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsersOnMeaningsCreateOrConnectWithoutUserInput | UsersOnMeaningsCreateOrConnectWithoutUserInput[]
    createMany?: UsersOnMeaningsCreateManyUserInputEnvelope
    connect?: UsersOnMeaningsWhereUniqueInput | UsersOnMeaningsWhereUniqueInput[]
  }

  ;export  type UsersOnWordListsCreateNestedManyWithoutUserInput = {
    create?: XOR<UsersOnWordListsCreateWithoutUserInput, UsersOnWordListsUncheckedCreateWithoutUserInput> | UsersOnWordListsCreateWithoutUserInput[] | UsersOnWordListsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsersOnWordListsCreateOrConnectWithoutUserInput | UsersOnWordListsCreateOrConnectWithoutUserInput[]
    createMany?: UsersOnWordListsCreateManyUserInputEnvelope
    connect?: UsersOnWordListsWhereUniqueInput | UsersOnWordListsWhereUniqueInput[]
  }

  ;export  type UsersOnWordsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UsersOnWordsCreateWithoutUserInput, UsersOnWordsUncheckedCreateWithoutUserInput> | UsersOnWordsCreateWithoutUserInput[] | UsersOnWordsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsersOnWordsCreateOrConnectWithoutUserInput | UsersOnWordsCreateOrConnectWithoutUserInput[]
    createMany?: UsersOnWordsCreateManyUserInputEnvelope
    connect?: UsersOnWordsWhereUniqueInput | UsersOnWordsWhereUniqueInput[]
  }

  ;export  type UsersOnMeaningsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UsersOnMeaningsCreateWithoutUserInput, UsersOnMeaningsUncheckedCreateWithoutUserInput> | UsersOnMeaningsCreateWithoutUserInput[] | UsersOnMeaningsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsersOnMeaningsCreateOrConnectWithoutUserInput | UsersOnMeaningsCreateOrConnectWithoutUserInput[]
    createMany?: UsersOnMeaningsCreateManyUserInputEnvelope
    connect?: UsersOnMeaningsWhereUniqueInput | UsersOnMeaningsWhereUniqueInput[]
  }

  ;export  type UsersOnWordListsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UsersOnWordListsCreateWithoutUserInput, UsersOnWordListsUncheckedCreateWithoutUserInput> | UsersOnWordListsCreateWithoutUserInput[] | UsersOnWordListsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsersOnWordListsCreateOrConnectWithoutUserInput | UsersOnWordListsCreateOrConnectWithoutUserInput[]
    createMany?: UsersOnWordListsCreateManyUserInputEnvelope
    connect?: UsersOnWordListsWhereUniqueInput | UsersOnWordListsWhereUniqueInput[]
  }

  ;export  type UsersOnWordsUpdateManyWithoutUserNestedInput = {
    create?: XOR<UsersOnWordsCreateWithoutUserInput, UsersOnWordsUncheckedCreateWithoutUserInput> | UsersOnWordsCreateWithoutUserInput[] | UsersOnWordsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsersOnWordsCreateOrConnectWithoutUserInput | UsersOnWordsCreateOrConnectWithoutUserInput[]
    upsert?: UsersOnWordsUpsertWithWhereUniqueWithoutUserInput | UsersOnWordsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UsersOnWordsCreateManyUserInputEnvelope
    set?: UsersOnWordsWhereUniqueInput | UsersOnWordsWhereUniqueInput[]
    disconnect?: UsersOnWordsWhereUniqueInput | UsersOnWordsWhereUniqueInput[]
    delete?: UsersOnWordsWhereUniqueInput | UsersOnWordsWhereUniqueInput[]
    connect?: UsersOnWordsWhereUniqueInput | UsersOnWordsWhereUniqueInput[]
    update?: UsersOnWordsUpdateWithWhereUniqueWithoutUserInput | UsersOnWordsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UsersOnWordsUpdateManyWithWhereWithoutUserInput | UsersOnWordsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UsersOnWordsScalarWhereInput | UsersOnWordsScalarWhereInput[]
  }

  ;export  type UsersOnMeaningsUpdateManyWithoutUserNestedInput = {
    create?: XOR<UsersOnMeaningsCreateWithoutUserInput, UsersOnMeaningsUncheckedCreateWithoutUserInput> | UsersOnMeaningsCreateWithoutUserInput[] | UsersOnMeaningsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsersOnMeaningsCreateOrConnectWithoutUserInput | UsersOnMeaningsCreateOrConnectWithoutUserInput[]
    upsert?: UsersOnMeaningsUpsertWithWhereUniqueWithoutUserInput | UsersOnMeaningsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UsersOnMeaningsCreateManyUserInputEnvelope
    set?: UsersOnMeaningsWhereUniqueInput | UsersOnMeaningsWhereUniqueInput[]
    disconnect?: UsersOnMeaningsWhereUniqueInput | UsersOnMeaningsWhereUniqueInput[]
    delete?: UsersOnMeaningsWhereUniqueInput | UsersOnMeaningsWhereUniqueInput[]
    connect?: UsersOnMeaningsWhereUniqueInput | UsersOnMeaningsWhereUniqueInput[]
    update?: UsersOnMeaningsUpdateWithWhereUniqueWithoutUserInput | UsersOnMeaningsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UsersOnMeaningsUpdateManyWithWhereWithoutUserInput | UsersOnMeaningsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UsersOnMeaningsScalarWhereInput | UsersOnMeaningsScalarWhereInput[]
  }

  ;export  type UsersOnWordListsUpdateManyWithoutUserNestedInput = {
    create?: XOR<UsersOnWordListsCreateWithoutUserInput, UsersOnWordListsUncheckedCreateWithoutUserInput> | UsersOnWordListsCreateWithoutUserInput[] | UsersOnWordListsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsersOnWordListsCreateOrConnectWithoutUserInput | UsersOnWordListsCreateOrConnectWithoutUserInput[]
    upsert?: UsersOnWordListsUpsertWithWhereUniqueWithoutUserInput | UsersOnWordListsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UsersOnWordListsCreateManyUserInputEnvelope
    set?: UsersOnWordListsWhereUniqueInput | UsersOnWordListsWhereUniqueInput[]
    disconnect?: UsersOnWordListsWhereUniqueInput | UsersOnWordListsWhereUniqueInput[]
    delete?: UsersOnWordListsWhereUniqueInput | UsersOnWordListsWhereUniqueInput[]
    connect?: UsersOnWordListsWhereUniqueInput | UsersOnWordListsWhereUniqueInput[]
    update?: UsersOnWordListsUpdateWithWhereUniqueWithoutUserInput | UsersOnWordListsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UsersOnWordListsUpdateManyWithWhereWithoutUserInput | UsersOnWordListsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UsersOnWordListsScalarWhereInput | UsersOnWordListsScalarWhereInput[]
  }

  ;export  type UsersOnWordsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UsersOnWordsCreateWithoutUserInput, UsersOnWordsUncheckedCreateWithoutUserInput> | UsersOnWordsCreateWithoutUserInput[] | UsersOnWordsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsersOnWordsCreateOrConnectWithoutUserInput | UsersOnWordsCreateOrConnectWithoutUserInput[]
    upsert?: UsersOnWordsUpsertWithWhereUniqueWithoutUserInput | UsersOnWordsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UsersOnWordsCreateManyUserInputEnvelope
    set?: UsersOnWordsWhereUniqueInput | UsersOnWordsWhereUniqueInput[]
    disconnect?: UsersOnWordsWhereUniqueInput | UsersOnWordsWhereUniqueInput[]
    delete?: UsersOnWordsWhereUniqueInput | UsersOnWordsWhereUniqueInput[]
    connect?: UsersOnWordsWhereUniqueInput | UsersOnWordsWhereUniqueInput[]
    update?: UsersOnWordsUpdateWithWhereUniqueWithoutUserInput | UsersOnWordsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UsersOnWordsUpdateManyWithWhereWithoutUserInput | UsersOnWordsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UsersOnWordsScalarWhereInput | UsersOnWordsScalarWhereInput[]
  }

  ;export  type UsersOnMeaningsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UsersOnMeaningsCreateWithoutUserInput, UsersOnMeaningsUncheckedCreateWithoutUserInput> | UsersOnMeaningsCreateWithoutUserInput[] | UsersOnMeaningsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsersOnMeaningsCreateOrConnectWithoutUserInput | UsersOnMeaningsCreateOrConnectWithoutUserInput[]
    upsert?: UsersOnMeaningsUpsertWithWhereUniqueWithoutUserInput | UsersOnMeaningsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UsersOnMeaningsCreateManyUserInputEnvelope
    set?: UsersOnMeaningsWhereUniqueInput | UsersOnMeaningsWhereUniqueInput[]
    disconnect?: UsersOnMeaningsWhereUniqueInput | UsersOnMeaningsWhereUniqueInput[]
    delete?: UsersOnMeaningsWhereUniqueInput | UsersOnMeaningsWhereUniqueInput[]
    connect?: UsersOnMeaningsWhereUniqueInput | UsersOnMeaningsWhereUniqueInput[]
    update?: UsersOnMeaningsUpdateWithWhereUniqueWithoutUserInput | UsersOnMeaningsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UsersOnMeaningsUpdateManyWithWhereWithoutUserInput | UsersOnMeaningsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UsersOnMeaningsScalarWhereInput | UsersOnMeaningsScalarWhereInput[]
  }

  ;export  type UsersOnWordListsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UsersOnWordListsCreateWithoutUserInput, UsersOnWordListsUncheckedCreateWithoutUserInput> | UsersOnWordListsCreateWithoutUserInput[] | UsersOnWordListsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsersOnWordListsCreateOrConnectWithoutUserInput | UsersOnWordListsCreateOrConnectWithoutUserInput[]
    upsert?: UsersOnWordListsUpsertWithWhereUniqueWithoutUserInput | UsersOnWordListsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UsersOnWordListsCreateManyUserInputEnvelope
    set?: UsersOnWordListsWhereUniqueInput | UsersOnWordListsWhereUniqueInput[]
    disconnect?: UsersOnWordListsWhereUniqueInput | UsersOnWordListsWhereUniqueInput[]
    delete?: UsersOnWordListsWhereUniqueInput | UsersOnWordListsWhereUniqueInput[]
    connect?: UsersOnWordListsWhereUniqueInput | UsersOnWordListsWhereUniqueInput[]
    update?: UsersOnWordListsUpdateWithWhereUniqueWithoutUserInput | UsersOnWordListsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UsersOnWordListsUpdateManyWithWhereWithoutUserInput | UsersOnWordListsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UsersOnWordListsScalarWhereInput | UsersOnWordListsScalarWhereInput[]
  }

  ;export  type UserCreateNestedOneWithoutWordsInput = {
    create?: XOR<UserCreateWithoutWordsInput, UserUncheckedCreateWithoutWordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWordsInput
    connect?: UserWhereUniqueInput
  }

  ;export  type WordCreateNestedOneWithoutUsersInput = {
    create?: XOR<WordCreateWithoutUsersInput, WordUncheckedCreateWithoutUsersInput>
    connectOrCreate?: WordCreateOrConnectWithoutUsersInput
    connect?: WordWhereUniqueInput
  }

  ;export  type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  ;export  type UserUpdateOneRequiredWithoutWordsNestedInput = {
    create?: XOR<UserCreateWithoutWordsInput, UserUncheckedCreateWithoutWordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWordsInput
    upsert?: UserUpsertWithoutWordsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWordsInput, UserUpdateWithoutWordsInput>, UserUncheckedUpdateWithoutWordsInput>
  }

  ;export  type WordUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<WordCreateWithoutUsersInput, WordUncheckedCreateWithoutUsersInput>
    connectOrCreate?: WordCreateOrConnectWithoutUsersInput
    upsert?: WordUpsertWithoutUsersInput
    connect?: WordWhereUniqueInput
    update?: XOR<XOR<WordUpdateToOneWithWhereWithoutUsersInput, WordUpdateWithoutUsersInput>, WordUncheckedUpdateWithoutUsersInput>
  }

  ;export  type UserCreateNestedOneWithoutMeaningsInput = {
    create?: XOR<UserCreateWithoutMeaningsInput, UserUncheckedCreateWithoutMeaningsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMeaningsInput
    connect?: UserWhereUniqueInput
  }

  ;export  type MeaningCreateNestedOneWithoutUsersInput = {
    create?: XOR<MeaningCreateWithoutUsersInput, MeaningUncheckedCreateWithoutUsersInput>
    connectOrCreate?: MeaningCreateOrConnectWithoutUsersInput
    connect?: MeaningWhereUniqueInput
  }

  ;export  type EnumUserMeaningRelationFieldUpdateOperationsInput = {
    set?: $Enums.UserMeaningRelation
  }

  ;export  type UserUpdateOneRequiredWithoutMeaningsNestedInput = {
    create?: XOR<UserCreateWithoutMeaningsInput, UserUncheckedCreateWithoutMeaningsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMeaningsInput
    upsert?: UserUpsertWithoutMeaningsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMeaningsInput, UserUpdateWithoutMeaningsInput>, UserUncheckedUpdateWithoutMeaningsInput>
  }

  ;export  type MeaningUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<MeaningCreateWithoutUsersInput, MeaningUncheckedCreateWithoutUsersInput>
    connectOrCreate?: MeaningCreateOrConnectWithoutUsersInput
    upsert?: MeaningUpsertWithoutUsersInput
    connect?: MeaningWhereUniqueInput
    update?: XOR<XOR<MeaningUpdateToOneWithWhereWithoutUsersInput, MeaningUpdateWithoutUsersInput>, MeaningUncheckedUpdateWithoutUsersInput>
  }

  ;export  type WordsOnWordListsCreateNestedManyWithoutWordListInput = {
    create?: XOR<WordsOnWordListsCreateWithoutWordListInput, WordsOnWordListsUncheckedCreateWithoutWordListInput> | WordsOnWordListsCreateWithoutWordListInput[] | WordsOnWordListsUncheckedCreateWithoutWordListInput[]
    connectOrCreate?: WordsOnWordListsCreateOrConnectWithoutWordListInput | WordsOnWordListsCreateOrConnectWithoutWordListInput[]
    createMany?: WordsOnWordListsCreateManyWordListInputEnvelope
    connect?: WordsOnWordListsWhereUniqueInput | WordsOnWordListsWhereUniqueInput[]
  }

  ;export  type UsersOnWordListsCreateNestedManyWithoutWordListInput = {
    create?: XOR<UsersOnWordListsCreateWithoutWordListInput, UsersOnWordListsUncheckedCreateWithoutWordListInput> | UsersOnWordListsCreateWithoutWordListInput[] | UsersOnWordListsUncheckedCreateWithoutWordListInput[]
    connectOrCreate?: UsersOnWordListsCreateOrConnectWithoutWordListInput | UsersOnWordListsCreateOrConnectWithoutWordListInput[]
    createMany?: UsersOnWordListsCreateManyWordListInputEnvelope
    connect?: UsersOnWordListsWhereUniqueInput | UsersOnWordListsWhereUniqueInput[]
  }

  ;export  type WordsOnWordListsUncheckedCreateNestedManyWithoutWordListInput = {
    create?: XOR<WordsOnWordListsCreateWithoutWordListInput, WordsOnWordListsUncheckedCreateWithoutWordListInput> | WordsOnWordListsCreateWithoutWordListInput[] | WordsOnWordListsUncheckedCreateWithoutWordListInput[]
    connectOrCreate?: WordsOnWordListsCreateOrConnectWithoutWordListInput | WordsOnWordListsCreateOrConnectWithoutWordListInput[]
    createMany?: WordsOnWordListsCreateManyWordListInputEnvelope
    connect?: WordsOnWordListsWhereUniqueInput | WordsOnWordListsWhereUniqueInput[]
  }

  ;export  type UsersOnWordListsUncheckedCreateNestedManyWithoutWordListInput = {
    create?: XOR<UsersOnWordListsCreateWithoutWordListInput, UsersOnWordListsUncheckedCreateWithoutWordListInput> | UsersOnWordListsCreateWithoutWordListInput[] | UsersOnWordListsUncheckedCreateWithoutWordListInput[]
    connectOrCreate?: UsersOnWordListsCreateOrConnectWithoutWordListInput | UsersOnWordListsCreateOrConnectWithoutWordListInput[]
    createMany?: UsersOnWordListsCreateManyWordListInputEnvelope
    connect?: UsersOnWordListsWhereUniqueInput | UsersOnWordListsWhereUniqueInput[]
  }

  ;export  type WordsOnWordListsUpdateManyWithoutWordListNestedInput = {
    create?: XOR<WordsOnWordListsCreateWithoutWordListInput, WordsOnWordListsUncheckedCreateWithoutWordListInput> | WordsOnWordListsCreateWithoutWordListInput[] | WordsOnWordListsUncheckedCreateWithoutWordListInput[]
    connectOrCreate?: WordsOnWordListsCreateOrConnectWithoutWordListInput | WordsOnWordListsCreateOrConnectWithoutWordListInput[]
    upsert?: WordsOnWordListsUpsertWithWhereUniqueWithoutWordListInput | WordsOnWordListsUpsertWithWhereUniqueWithoutWordListInput[]
    createMany?: WordsOnWordListsCreateManyWordListInputEnvelope
    set?: WordsOnWordListsWhereUniqueInput | WordsOnWordListsWhereUniqueInput[]
    disconnect?: WordsOnWordListsWhereUniqueInput | WordsOnWordListsWhereUniqueInput[]
    delete?: WordsOnWordListsWhereUniqueInput | WordsOnWordListsWhereUniqueInput[]
    connect?: WordsOnWordListsWhereUniqueInput | WordsOnWordListsWhereUniqueInput[]
    update?: WordsOnWordListsUpdateWithWhereUniqueWithoutWordListInput | WordsOnWordListsUpdateWithWhereUniqueWithoutWordListInput[]
    updateMany?: WordsOnWordListsUpdateManyWithWhereWithoutWordListInput | WordsOnWordListsUpdateManyWithWhereWithoutWordListInput[]
    deleteMany?: WordsOnWordListsScalarWhereInput | WordsOnWordListsScalarWhereInput[]
  }

  ;export  type UsersOnWordListsUpdateManyWithoutWordListNestedInput = {
    create?: XOR<UsersOnWordListsCreateWithoutWordListInput, UsersOnWordListsUncheckedCreateWithoutWordListInput> | UsersOnWordListsCreateWithoutWordListInput[] | UsersOnWordListsUncheckedCreateWithoutWordListInput[]
    connectOrCreate?: UsersOnWordListsCreateOrConnectWithoutWordListInput | UsersOnWordListsCreateOrConnectWithoutWordListInput[]
    upsert?: UsersOnWordListsUpsertWithWhereUniqueWithoutWordListInput | UsersOnWordListsUpsertWithWhereUniqueWithoutWordListInput[]
    createMany?: UsersOnWordListsCreateManyWordListInputEnvelope
    set?: UsersOnWordListsWhereUniqueInput | UsersOnWordListsWhereUniqueInput[]
    disconnect?: UsersOnWordListsWhereUniqueInput | UsersOnWordListsWhereUniqueInput[]
    delete?: UsersOnWordListsWhereUniqueInput | UsersOnWordListsWhereUniqueInput[]
    connect?: UsersOnWordListsWhereUniqueInput | UsersOnWordListsWhereUniqueInput[]
    update?: UsersOnWordListsUpdateWithWhereUniqueWithoutWordListInput | UsersOnWordListsUpdateWithWhereUniqueWithoutWordListInput[]
    updateMany?: UsersOnWordListsUpdateManyWithWhereWithoutWordListInput | UsersOnWordListsUpdateManyWithWhereWithoutWordListInput[]
    deleteMany?: UsersOnWordListsScalarWhereInput | UsersOnWordListsScalarWhereInput[]
  }

  ;export  type WordsOnWordListsUncheckedUpdateManyWithoutWordListNestedInput = {
    create?: XOR<WordsOnWordListsCreateWithoutWordListInput, WordsOnWordListsUncheckedCreateWithoutWordListInput> | WordsOnWordListsCreateWithoutWordListInput[] | WordsOnWordListsUncheckedCreateWithoutWordListInput[]
    connectOrCreate?: WordsOnWordListsCreateOrConnectWithoutWordListInput | WordsOnWordListsCreateOrConnectWithoutWordListInput[]
    upsert?: WordsOnWordListsUpsertWithWhereUniqueWithoutWordListInput | WordsOnWordListsUpsertWithWhereUniqueWithoutWordListInput[]
    createMany?: WordsOnWordListsCreateManyWordListInputEnvelope
    set?: WordsOnWordListsWhereUniqueInput | WordsOnWordListsWhereUniqueInput[]
    disconnect?: WordsOnWordListsWhereUniqueInput | WordsOnWordListsWhereUniqueInput[]
    delete?: WordsOnWordListsWhereUniqueInput | WordsOnWordListsWhereUniqueInput[]
    connect?: WordsOnWordListsWhereUniqueInput | WordsOnWordListsWhereUniqueInput[]
    update?: WordsOnWordListsUpdateWithWhereUniqueWithoutWordListInput | WordsOnWordListsUpdateWithWhereUniqueWithoutWordListInput[]
    updateMany?: WordsOnWordListsUpdateManyWithWhereWithoutWordListInput | WordsOnWordListsUpdateManyWithWhereWithoutWordListInput[]
    deleteMany?: WordsOnWordListsScalarWhereInput | WordsOnWordListsScalarWhereInput[]
  }

  ;export  type UsersOnWordListsUncheckedUpdateManyWithoutWordListNestedInput = {
    create?: XOR<UsersOnWordListsCreateWithoutWordListInput, UsersOnWordListsUncheckedCreateWithoutWordListInput> | UsersOnWordListsCreateWithoutWordListInput[] | UsersOnWordListsUncheckedCreateWithoutWordListInput[]
    connectOrCreate?: UsersOnWordListsCreateOrConnectWithoutWordListInput | UsersOnWordListsCreateOrConnectWithoutWordListInput[]
    upsert?: UsersOnWordListsUpsertWithWhereUniqueWithoutWordListInput | UsersOnWordListsUpsertWithWhereUniqueWithoutWordListInput[]
    createMany?: UsersOnWordListsCreateManyWordListInputEnvelope
    set?: UsersOnWordListsWhereUniqueInput | UsersOnWordListsWhereUniqueInput[]
    disconnect?: UsersOnWordListsWhereUniqueInput | UsersOnWordListsWhereUniqueInput[]
    delete?: UsersOnWordListsWhereUniqueInput | UsersOnWordListsWhereUniqueInput[]
    connect?: UsersOnWordListsWhereUniqueInput | UsersOnWordListsWhereUniqueInput[]
    update?: UsersOnWordListsUpdateWithWhereUniqueWithoutWordListInput | UsersOnWordListsUpdateWithWhereUniqueWithoutWordListInput[]
    updateMany?: UsersOnWordListsUpdateManyWithWhereWithoutWordListInput | UsersOnWordListsUpdateManyWithWhereWithoutWordListInput[]
    deleteMany?: UsersOnWordListsScalarWhereInput | UsersOnWordListsScalarWhereInput[]
  }

  ;export  type WordCreateNestedOneWithoutWordsOnWordListsInput = {
    create?: XOR<WordCreateWithoutWordsOnWordListsInput, WordUncheckedCreateWithoutWordsOnWordListsInput>
    connectOrCreate?: WordCreateOrConnectWithoutWordsOnWordListsInput
    connect?: WordWhereUniqueInput
  }

  ;export  type WordListCreateNestedOneWithoutWordsInput = {
    create?: XOR<WordListCreateWithoutWordsInput, WordListUncheckedCreateWithoutWordsInput>
    connectOrCreate?: WordListCreateOrConnectWithoutWordsInput
    connect?: WordListWhereUniqueInput
  }

  ;export  type WordUpdateOneRequiredWithoutWordsOnWordListsNestedInput = {
    create?: XOR<WordCreateWithoutWordsOnWordListsInput, WordUncheckedCreateWithoutWordsOnWordListsInput>
    connectOrCreate?: WordCreateOrConnectWithoutWordsOnWordListsInput
    upsert?: WordUpsertWithoutWordsOnWordListsInput
    connect?: WordWhereUniqueInput
    update?: XOR<XOR<WordUpdateToOneWithWhereWithoutWordsOnWordListsInput, WordUpdateWithoutWordsOnWordListsInput>, WordUncheckedUpdateWithoutWordsOnWordListsInput>
  }

  ;export  type WordListUpdateOneRequiredWithoutWordsNestedInput = {
    create?: XOR<WordListCreateWithoutWordsInput, WordListUncheckedCreateWithoutWordsInput>
    connectOrCreate?: WordListCreateOrConnectWithoutWordsInput
    upsert?: WordListUpsertWithoutWordsInput
    connect?: WordListWhereUniqueInput
    update?: XOR<XOR<WordListUpdateToOneWithWhereWithoutWordsInput, WordListUpdateWithoutWordsInput>, WordListUncheckedUpdateWithoutWordsInput>
  }

  ;export  type UserCreateNestedOneWithoutUsersOnWordListsInput = {
    create?: XOR<UserCreateWithoutUsersOnWordListsInput, UserUncheckedCreateWithoutUsersOnWordListsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsersOnWordListsInput
    connect?: UserWhereUniqueInput
  }

  ;export  type WordListCreateNestedOneWithoutUsersInput = {
    create?: XOR<WordListCreateWithoutUsersInput, WordListUncheckedCreateWithoutUsersInput>
    connectOrCreate?: WordListCreateOrConnectWithoutUsersInput
    connect?: WordListWhereUniqueInput
  }

  ;export  type UserUpdateOneRequiredWithoutUsersOnWordListsNestedInput = {
    create?: XOR<UserCreateWithoutUsersOnWordListsInput, UserUncheckedCreateWithoutUsersOnWordListsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsersOnWordListsInput
    upsert?: UserUpsertWithoutUsersOnWordListsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUsersOnWordListsInput, UserUpdateWithoutUsersOnWordListsInput>, UserUncheckedUpdateWithoutUsersOnWordListsInput>
  }

  ;export  type WordListUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<WordListCreateWithoutUsersInput, WordListUncheckedCreateWithoutUsersInput>
    connectOrCreate?: WordListCreateOrConnectWithoutUsersInput
    upsert?: WordListUpsertWithoutUsersInput
    connect?: WordListWhereUniqueInput
    update?: XOR<XOR<WordListUpdateToOneWithWhereWithoutUsersInput, WordListUpdateWithoutUsersInput>, WordListUncheckedUpdateWithoutUsersInput>
  }

  ;export  type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  ;export  type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  ;export  type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  ;export  type NestedEnumWordDefinitionSourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WordDefinitionSourceType | EnumWordDefinitionSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WordDefinitionSourceType[] | ListEnumWordDefinitionSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WordDefinitionSourceType[] | ListEnumWordDefinitionSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWordDefinitionSourceTypeFilter<$PrismaModel> | $Enums.WordDefinitionSourceType
  }

  ;export  type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  ;export  type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  ;export  type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  ;export  type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  ;export  type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  ;export  type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  ;export  type NestedEnumWordDefinitionSourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WordDefinitionSourceType | EnumWordDefinitionSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WordDefinitionSourceType[] | ListEnumWordDefinitionSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WordDefinitionSourceType[] | ListEnumWordDefinitionSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWordDefinitionSourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.WordDefinitionSourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWordDefinitionSourceTypeFilter<$PrismaModel>
    _max?: NestedEnumWordDefinitionSourceTypeFilter<$PrismaModel>
  }

  ;export  type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  ;export  type NestedEnumSentenceSourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SentenceSourceType | EnumSentenceSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SentenceSourceType[] | ListEnumSentenceSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SentenceSourceType[] | ListEnumSentenceSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSentenceSourceTypeFilter<$PrismaModel> | $Enums.SentenceSourceType
  }

  ;export  type NestedEnumSentenceSourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SentenceSourceType | EnumSentenceSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SentenceSourceType[] | ListEnumSentenceSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SentenceSourceType[] | ListEnumSentenceSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSentenceSourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.SentenceSourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSentenceSourceTypeFilter<$PrismaModel>
    _max?: NestedEnumSentenceSourceTypeFilter<$PrismaModel>
  }

  ;export  type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  ;export  type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  ;export  type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  ;export  type NestedEnumUserMeaningRelationFilter<$PrismaModel = never> = {
    equals?: $Enums.UserMeaningRelation | EnumUserMeaningRelationFieldRefInput<$PrismaModel>
    in?: $Enums.UserMeaningRelation[] | ListEnumUserMeaningRelationFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserMeaningRelation[] | ListEnumUserMeaningRelationFieldRefInput<$PrismaModel>
    not?: NestedEnumUserMeaningRelationFilter<$PrismaModel> | $Enums.UserMeaningRelation
  }

  ;export  type NestedEnumUserMeaningRelationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserMeaningRelation | EnumUserMeaningRelationFieldRefInput<$PrismaModel>
    in?: $Enums.UserMeaningRelation[] | ListEnumUserMeaningRelationFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserMeaningRelation[] | ListEnumUserMeaningRelationFieldRefInput<$PrismaModel>
    not?: NestedEnumUserMeaningRelationWithAggregatesFilter<$PrismaModel> | $Enums.UserMeaningRelation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserMeaningRelationFilter<$PrismaModel>
    _max?: NestedEnumUserMeaningRelationFilter<$PrismaModel>
  }

  ;export  type MeaningCreateWithoutWordInput = {
    id?: string
    term: string
    partOfSpeech: string
    meaning: string
    synonyms?: MeaningCreatesynonymsInput | string[]
    antonyms?: MeaningCreateantonymsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    sentences?: SentenceCreateNestedManyWithoutMeaningInput
    users?: UsersOnMeaningsCreateNestedManyWithoutMeaningInput
  }

  ;export  type MeaningUncheckedCreateWithoutWordInput = {
    id?: string
    term: string
    partOfSpeech: string
    meaning: string
    synonyms?: MeaningCreatesynonymsInput | string[]
    antonyms?: MeaningCreateantonymsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    sentences?: SentenceUncheckedCreateNestedManyWithoutMeaningInput
    users?: UsersOnMeaningsUncheckedCreateNestedManyWithoutMeaningInput
  }

  ;export  type MeaningCreateOrConnectWithoutWordInput = {
    where: MeaningWhereUniqueInput
    create: XOR<MeaningCreateWithoutWordInput, MeaningUncheckedCreateWithoutWordInput>
  }

  ;export  type MeaningCreateManyWordInputEnvelope = {
    data: MeaningCreateManyWordInput | MeaningCreateManyWordInput[]
    skipDuplicates?: boolean
  }

  ;export  type UsersOnWordsCreateWithoutWordInput = {
    level?: number
    lastTimeRecalledCorrectly: Date | string
    timeQuotient?: number
    user: UserCreateNestedOneWithoutWordsInput
  }

  ;export  type UsersOnWordsUncheckedCreateWithoutWordInput = {
    userId: string
    level?: number
    lastTimeRecalledCorrectly: Date | string
    timeQuotient?: number
  }

  ;export  type UsersOnWordsCreateOrConnectWithoutWordInput = {
    where: UsersOnWordsWhereUniqueInput
    create: XOR<UsersOnWordsCreateWithoutWordInput, UsersOnWordsUncheckedCreateWithoutWordInput>
  }

  ;export  type UsersOnWordsCreateManyWordInputEnvelope = {
    data: UsersOnWordsCreateManyWordInput | UsersOnWordsCreateManyWordInput[]
    skipDuplicates?: boolean
  }

  ;export  type WordsOnWordListsCreateWithoutWordInput = {
    wordList: WordListCreateNestedOneWithoutWordsInput
  }

  ;export  type WordsOnWordListsUncheckedCreateWithoutWordInput = {
    wordListId: string
  }

  ;export  type WordsOnWordListsCreateOrConnectWithoutWordInput = {
    where: WordsOnWordListsWhereUniqueInput
    create: XOR<WordsOnWordListsCreateWithoutWordInput, WordsOnWordListsUncheckedCreateWithoutWordInput>
  }

  ;export  type WordsOnWordListsCreateManyWordInputEnvelope = {
    data: WordsOnWordListsCreateManyWordInput | WordsOnWordListsCreateManyWordInput[]
    skipDuplicates?: boolean
  }

  ;export  type MeaningUpsertWithWhereUniqueWithoutWordInput = {
    where: MeaningWhereUniqueInput
    update: XOR<MeaningUpdateWithoutWordInput, MeaningUncheckedUpdateWithoutWordInput>
    create: XOR<MeaningCreateWithoutWordInput, MeaningUncheckedCreateWithoutWordInput>
  }

  ;export  type MeaningUpdateWithWhereUniqueWithoutWordInput = {
    where: MeaningWhereUniqueInput
    data: XOR<MeaningUpdateWithoutWordInput, MeaningUncheckedUpdateWithoutWordInput>
  }

  ;export  type MeaningUpdateManyWithWhereWithoutWordInput = {
    where: MeaningScalarWhereInput
    data: XOR<MeaningUpdateManyMutationInput, MeaningUncheckedUpdateManyWithoutWordInput>
  }

  ;export  type MeaningScalarWhereInput = {
    AND?: MeaningScalarWhereInput | MeaningScalarWhereInput[]
    OR?: MeaningScalarWhereInput[]
    NOT?: MeaningScalarWhereInput | MeaningScalarWhereInput[]
    id?: UuidFilter<"Meaning"> | string
    term?: StringFilter<"Meaning"> | string
    partOfSpeech?: StringFilter<"Meaning"> | string
    meaning?: StringFilter<"Meaning"> | string
    synonyms?: StringNullableListFilter<"Meaning">
    antonyms?: StringNullableListFilter<"Meaning">
    createdAt?: DateTimeFilter<"Meaning"> | Date | string
    updatedAt?: DateTimeFilter<"Meaning"> | Date | string
    wordId?: UuidFilter<"Meaning"> | string
  }

  ;export  type UsersOnWordsUpsertWithWhereUniqueWithoutWordInput = {
    where: UsersOnWordsWhereUniqueInput
    update: XOR<UsersOnWordsUpdateWithoutWordInput, UsersOnWordsUncheckedUpdateWithoutWordInput>
    create: XOR<UsersOnWordsCreateWithoutWordInput, UsersOnWordsUncheckedCreateWithoutWordInput>
  }

  ;export  type UsersOnWordsUpdateWithWhereUniqueWithoutWordInput = {
    where: UsersOnWordsWhereUniqueInput
    data: XOR<UsersOnWordsUpdateWithoutWordInput, UsersOnWordsUncheckedUpdateWithoutWordInput>
  }

  ;export  type UsersOnWordsUpdateManyWithWhereWithoutWordInput = {
    where: UsersOnWordsScalarWhereInput
    data: XOR<UsersOnWordsUpdateManyMutationInput, UsersOnWordsUncheckedUpdateManyWithoutWordInput>
  }

  ;export  type UsersOnWordsScalarWhereInput = {
    AND?: UsersOnWordsScalarWhereInput | UsersOnWordsScalarWhereInput[]
    OR?: UsersOnWordsScalarWhereInput[]
    NOT?: UsersOnWordsScalarWhereInput | UsersOnWordsScalarWhereInput[]
    userId?: UuidFilter<"UsersOnWords"> | string
    wordId?: UuidFilter<"UsersOnWords"> | string
    level?: IntFilter<"UsersOnWords"> | number
    lastTimeRecalledCorrectly?: DateTimeFilter<"UsersOnWords"> | Date | string
    timeQuotient?: FloatFilter<"UsersOnWords"> | number
  }

  ;export  type WordsOnWordListsUpsertWithWhereUniqueWithoutWordInput = {
    where: WordsOnWordListsWhereUniqueInput
    update: XOR<WordsOnWordListsUpdateWithoutWordInput, WordsOnWordListsUncheckedUpdateWithoutWordInput>
    create: XOR<WordsOnWordListsCreateWithoutWordInput, WordsOnWordListsUncheckedCreateWithoutWordInput>
  }

  ;export  type WordsOnWordListsUpdateWithWhereUniqueWithoutWordInput = {
    where: WordsOnWordListsWhereUniqueInput
    data: XOR<WordsOnWordListsUpdateWithoutWordInput, WordsOnWordListsUncheckedUpdateWithoutWordInput>
  }

  ;export  type WordsOnWordListsUpdateManyWithWhereWithoutWordInput = {
    where: WordsOnWordListsScalarWhereInput
    data: XOR<WordsOnWordListsUpdateManyMutationInput, WordsOnWordListsUncheckedUpdateManyWithoutWordInput>
  }

  ;export  type WordsOnWordListsScalarWhereInput = {
    AND?: WordsOnWordListsScalarWhereInput | WordsOnWordListsScalarWhereInput[]
    OR?: WordsOnWordListsScalarWhereInput[]
    NOT?: WordsOnWordListsScalarWhereInput | WordsOnWordListsScalarWhereInput[]
    wordId?: UuidFilter<"WordsOnWordLists"> | string
    wordListId?: UuidFilter<"WordsOnWordLists"> | string
  }

  ;export  type SentenceCreateWithoutMeaningInput = {
    id?: string
    fullText: string
    wordToLearn: string
    options?: SentenceCreateoptionsInput | string[]
    source: $Enums.SentenceSourceType
    greatVotesCount?: number
    fineVotesCount?: number
    badVotesCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  ;export  type SentenceUncheckedCreateWithoutMeaningInput = {
    id?: string
    fullText: string
    wordToLearn: string
    options?: SentenceCreateoptionsInput | string[]
    source: $Enums.SentenceSourceType
    greatVotesCount?: number
    fineVotesCount?: number
    badVotesCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  ;export  type SentenceCreateOrConnectWithoutMeaningInput = {
    where: SentenceWhereUniqueInput
    create: XOR<SentenceCreateWithoutMeaningInput, SentenceUncheckedCreateWithoutMeaningInput>
  }

  ;export  type SentenceCreateManyMeaningInputEnvelope = {
    data: SentenceCreateManyMeaningInput | SentenceCreateManyMeaningInput[]
    skipDuplicates?: boolean
  }

  ;export  type WordCreateWithoutMeaningsInput = {
    id?: string
    word: string
    transcription: string
    audio?: string | null
    source: $Enums.WordDefinitionSourceType
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UsersOnWordsCreateNestedManyWithoutWordInput
    WordsOnWordLists?: WordsOnWordListsCreateNestedManyWithoutWordInput
  }

  ;export  type WordUncheckedCreateWithoutMeaningsInput = {
    id?: string
    word: string
    transcription: string
    audio?: string | null
    source: $Enums.WordDefinitionSourceType
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UsersOnWordsUncheckedCreateNestedManyWithoutWordInput
    WordsOnWordLists?: WordsOnWordListsUncheckedCreateNestedManyWithoutWordInput
  }

  ;export  type WordCreateOrConnectWithoutMeaningsInput = {
    where: WordWhereUniqueInput
    create: XOR<WordCreateWithoutMeaningsInput, WordUncheckedCreateWithoutMeaningsInput>
  }

  ;export  type UsersOnMeaningsCreateWithoutMeaningInput = {
    relation?: $Enums.UserMeaningRelation
    user: UserCreateNestedOneWithoutMeaningsInput
  }

  ;export  type UsersOnMeaningsUncheckedCreateWithoutMeaningInput = {
    userId: string
    relation?: $Enums.UserMeaningRelation
  }

  ;export  type UsersOnMeaningsCreateOrConnectWithoutMeaningInput = {
    where: UsersOnMeaningsWhereUniqueInput
    create: XOR<UsersOnMeaningsCreateWithoutMeaningInput, UsersOnMeaningsUncheckedCreateWithoutMeaningInput>
  }

  ;export  type UsersOnMeaningsCreateManyMeaningInputEnvelope = {
    data: UsersOnMeaningsCreateManyMeaningInput | UsersOnMeaningsCreateManyMeaningInput[]
    skipDuplicates?: boolean
  }

  ;export  type SentenceUpsertWithWhereUniqueWithoutMeaningInput = {
    where: SentenceWhereUniqueInput
    update: XOR<SentenceUpdateWithoutMeaningInput, SentenceUncheckedUpdateWithoutMeaningInput>
    create: XOR<SentenceCreateWithoutMeaningInput, SentenceUncheckedCreateWithoutMeaningInput>
  }

  ;export  type SentenceUpdateWithWhereUniqueWithoutMeaningInput = {
    where: SentenceWhereUniqueInput
    data: XOR<SentenceUpdateWithoutMeaningInput, SentenceUncheckedUpdateWithoutMeaningInput>
  }

  ;export  type SentenceUpdateManyWithWhereWithoutMeaningInput = {
    where: SentenceScalarWhereInput
    data: XOR<SentenceUpdateManyMutationInput, SentenceUncheckedUpdateManyWithoutMeaningInput>
  }

  ;export  type SentenceScalarWhereInput = {
    AND?: SentenceScalarWhereInput | SentenceScalarWhereInput[]
    OR?: SentenceScalarWhereInput[]
    NOT?: SentenceScalarWhereInput | SentenceScalarWhereInput[]
    id?: UuidFilter<"Sentence"> | string
    fullText?: StringFilter<"Sentence"> | string
    wordToLearn?: StringFilter<"Sentence"> | string
    options?: StringNullableListFilter<"Sentence">
    meaningId?: UuidFilter<"Sentence"> | string
    source?: EnumSentenceSourceTypeFilter<"Sentence"> | $Enums.SentenceSourceType
    greatVotesCount?: IntFilter<"Sentence"> | number
    fineVotesCount?: IntFilter<"Sentence"> | number
    badVotesCount?: IntFilter<"Sentence"> | number
    createdAt?: DateTimeFilter<"Sentence"> | Date | string
    updatedAt?: DateTimeFilter<"Sentence"> | Date | string
  }

  ;export  type WordUpsertWithoutMeaningsInput = {
    update: XOR<WordUpdateWithoutMeaningsInput, WordUncheckedUpdateWithoutMeaningsInput>
    create: XOR<WordCreateWithoutMeaningsInput, WordUncheckedCreateWithoutMeaningsInput>
    where?: WordWhereInput
  }

  ;export  type WordUpdateToOneWithWhereWithoutMeaningsInput = {
    where?: WordWhereInput
    data: XOR<WordUpdateWithoutMeaningsInput, WordUncheckedUpdateWithoutMeaningsInput>
  }

  ;export  type WordUpdateWithoutMeaningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    word?: StringFieldUpdateOperationsInput | string
    transcription?: StringFieldUpdateOperationsInput | string
    audio?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumWordDefinitionSourceTypeFieldUpdateOperationsInput | $Enums.WordDefinitionSourceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersOnWordsUpdateManyWithoutWordNestedInput
    WordsOnWordLists?: WordsOnWordListsUpdateManyWithoutWordNestedInput
  }

  ;export  type WordUncheckedUpdateWithoutMeaningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    word?: StringFieldUpdateOperationsInput | string
    transcription?: StringFieldUpdateOperationsInput | string
    audio?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumWordDefinitionSourceTypeFieldUpdateOperationsInput | $Enums.WordDefinitionSourceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersOnWordsUncheckedUpdateManyWithoutWordNestedInput
    WordsOnWordLists?: WordsOnWordListsUncheckedUpdateManyWithoutWordNestedInput
  }

  ;export  type UsersOnMeaningsUpsertWithWhereUniqueWithoutMeaningInput = {
    where: UsersOnMeaningsWhereUniqueInput
    update: XOR<UsersOnMeaningsUpdateWithoutMeaningInput, UsersOnMeaningsUncheckedUpdateWithoutMeaningInput>
    create: XOR<UsersOnMeaningsCreateWithoutMeaningInput, UsersOnMeaningsUncheckedCreateWithoutMeaningInput>
  }

  ;export  type UsersOnMeaningsUpdateWithWhereUniqueWithoutMeaningInput = {
    where: UsersOnMeaningsWhereUniqueInput
    data: XOR<UsersOnMeaningsUpdateWithoutMeaningInput, UsersOnMeaningsUncheckedUpdateWithoutMeaningInput>
  }

  ;export  type UsersOnMeaningsUpdateManyWithWhereWithoutMeaningInput = {
    where: UsersOnMeaningsScalarWhereInput
    data: XOR<UsersOnMeaningsUpdateManyMutationInput, UsersOnMeaningsUncheckedUpdateManyWithoutMeaningInput>
  }

  ;export  type UsersOnMeaningsScalarWhereInput = {
    AND?: UsersOnMeaningsScalarWhereInput | UsersOnMeaningsScalarWhereInput[]
    OR?: UsersOnMeaningsScalarWhereInput[]
    NOT?: UsersOnMeaningsScalarWhereInput | UsersOnMeaningsScalarWhereInput[]
    userId?: UuidFilter<"UsersOnMeanings"> | string
    meaningId?: UuidFilter<"UsersOnMeanings"> | string
    relation?: EnumUserMeaningRelationFilter<"UsersOnMeanings"> | $Enums.UserMeaningRelation
  }

  ;export  type MeaningCreateWithoutSentencesInput = {
    id?: string
    term: string
    partOfSpeech: string
    meaning: string
    synonyms?: MeaningCreatesynonymsInput | string[]
    antonyms?: MeaningCreateantonymsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    Word: WordCreateNestedOneWithoutMeaningsInput
    users?: UsersOnMeaningsCreateNestedManyWithoutMeaningInput
  }

  ;export  type MeaningUncheckedCreateWithoutSentencesInput = {
    id?: string
    term: string
    partOfSpeech: string
    meaning: string
    synonyms?: MeaningCreatesynonymsInput | string[]
    antonyms?: MeaningCreateantonymsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    wordId: string
    users?: UsersOnMeaningsUncheckedCreateNestedManyWithoutMeaningInput
  }

  ;export  type MeaningCreateOrConnectWithoutSentencesInput = {
    where: MeaningWhereUniqueInput
    create: XOR<MeaningCreateWithoutSentencesInput, MeaningUncheckedCreateWithoutSentencesInput>
  }

  ;export  type MeaningUpsertWithoutSentencesInput = {
    update: XOR<MeaningUpdateWithoutSentencesInput, MeaningUncheckedUpdateWithoutSentencesInput>
    create: XOR<MeaningCreateWithoutSentencesInput, MeaningUncheckedCreateWithoutSentencesInput>
    where?: MeaningWhereInput
  }

  ;export  type MeaningUpdateToOneWithWhereWithoutSentencesInput = {
    where?: MeaningWhereInput
    data: XOR<MeaningUpdateWithoutSentencesInput, MeaningUncheckedUpdateWithoutSentencesInput>
  }

  ;export  type MeaningUpdateWithoutSentencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    partOfSpeech?: StringFieldUpdateOperationsInput | string
    meaning?: StringFieldUpdateOperationsInput | string
    synonyms?: MeaningUpdatesynonymsInput | string[]
    antonyms?: MeaningUpdateantonymsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Word?: WordUpdateOneRequiredWithoutMeaningsNestedInput
    users?: UsersOnMeaningsUpdateManyWithoutMeaningNestedInput
  }

  ;export  type MeaningUncheckedUpdateWithoutSentencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    partOfSpeech?: StringFieldUpdateOperationsInput | string
    meaning?: StringFieldUpdateOperationsInput | string
    synonyms?: MeaningUpdatesynonymsInput | string[]
    antonyms?: MeaningUpdateantonymsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wordId?: StringFieldUpdateOperationsInput | string
    users?: UsersOnMeaningsUncheckedUpdateManyWithoutMeaningNestedInput
  }

  ;export  type UsersOnWordsCreateWithoutUserInput = {
    level?: number
    lastTimeRecalledCorrectly: Date | string
    timeQuotient?: number
    word: WordCreateNestedOneWithoutUsersInput
  }

  ;export  type UsersOnWordsUncheckedCreateWithoutUserInput = {
    wordId: string
    level?: number
    lastTimeRecalledCorrectly: Date | string
    timeQuotient?: number
  }

  ;export  type UsersOnWordsCreateOrConnectWithoutUserInput = {
    where: UsersOnWordsWhereUniqueInput
    create: XOR<UsersOnWordsCreateWithoutUserInput, UsersOnWordsUncheckedCreateWithoutUserInput>
  }

  ;export  type UsersOnWordsCreateManyUserInputEnvelope = {
    data: UsersOnWordsCreateManyUserInput | UsersOnWordsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  ;export  type UsersOnMeaningsCreateWithoutUserInput = {
    relation?: $Enums.UserMeaningRelation
    meaning: MeaningCreateNestedOneWithoutUsersInput
  }

  ;export  type UsersOnMeaningsUncheckedCreateWithoutUserInput = {
    meaningId: string
    relation?: $Enums.UserMeaningRelation
  }

  ;export  type UsersOnMeaningsCreateOrConnectWithoutUserInput = {
    where: UsersOnMeaningsWhereUniqueInput
    create: XOR<UsersOnMeaningsCreateWithoutUserInput, UsersOnMeaningsUncheckedCreateWithoutUserInput>
  }

  ;export  type UsersOnMeaningsCreateManyUserInputEnvelope = {
    data: UsersOnMeaningsCreateManyUserInput | UsersOnMeaningsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  ;export  type UsersOnWordListsCreateWithoutUserInput = {
    wordList: WordListCreateNestedOneWithoutUsersInput
  }

  ;export  type UsersOnWordListsUncheckedCreateWithoutUserInput = {
    wordListId: string
  }

  ;export  type UsersOnWordListsCreateOrConnectWithoutUserInput = {
    where: UsersOnWordListsWhereUniqueInput
    create: XOR<UsersOnWordListsCreateWithoutUserInput, UsersOnWordListsUncheckedCreateWithoutUserInput>
  }

  ;export  type UsersOnWordListsCreateManyUserInputEnvelope = {
    data: UsersOnWordListsCreateManyUserInput | UsersOnWordListsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  ;export  type UsersOnWordsUpsertWithWhereUniqueWithoutUserInput = {
    where: UsersOnWordsWhereUniqueInput
    update: XOR<UsersOnWordsUpdateWithoutUserInput, UsersOnWordsUncheckedUpdateWithoutUserInput>
    create: XOR<UsersOnWordsCreateWithoutUserInput, UsersOnWordsUncheckedCreateWithoutUserInput>
  }

  ;export  type UsersOnWordsUpdateWithWhereUniqueWithoutUserInput = {
    where: UsersOnWordsWhereUniqueInput
    data: XOR<UsersOnWordsUpdateWithoutUserInput, UsersOnWordsUncheckedUpdateWithoutUserInput>
  }

  ;export  type UsersOnWordsUpdateManyWithWhereWithoutUserInput = {
    where: UsersOnWordsScalarWhereInput
    data: XOR<UsersOnWordsUpdateManyMutationInput, UsersOnWordsUncheckedUpdateManyWithoutUserInput>
  }

  ;export  type UsersOnMeaningsUpsertWithWhereUniqueWithoutUserInput = {
    where: UsersOnMeaningsWhereUniqueInput
    update: XOR<UsersOnMeaningsUpdateWithoutUserInput, UsersOnMeaningsUncheckedUpdateWithoutUserInput>
    create: XOR<UsersOnMeaningsCreateWithoutUserInput, UsersOnMeaningsUncheckedCreateWithoutUserInput>
  }

  ;export  type UsersOnMeaningsUpdateWithWhereUniqueWithoutUserInput = {
    where: UsersOnMeaningsWhereUniqueInput
    data: XOR<UsersOnMeaningsUpdateWithoutUserInput, UsersOnMeaningsUncheckedUpdateWithoutUserInput>
  }

  ;export  type UsersOnMeaningsUpdateManyWithWhereWithoutUserInput = {
    where: UsersOnMeaningsScalarWhereInput
    data: XOR<UsersOnMeaningsUpdateManyMutationInput, UsersOnMeaningsUncheckedUpdateManyWithoutUserInput>
  }

  ;export  type UsersOnWordListsUpsertWithWhereUniqueWithoutUserInput = {
    where: UsersOnWordListsWhereUniqueInput
    update: XOR<UsersOnWordListsUpdateWithoutUserInput, UsersOnWordListsUncheckedUpdateWithoutUserInput>
    create: XOR<UsersOnWordListsCreateWithoutUserInput, UsersOnWordListsUncheckedCreateWithoutUserInput>
  }

  ;export  type UsersOnWordListsUpdateWithWhereUniqueWithoutUserInput = {
    where: UsersOnWordListsWhereUniqueInput
    data: XOR<UsersOnWordListsUpdateWithoutUserInput, UsersOnWordListsUncheckedUpdateWithoutUserInput>
  }

  ;export  type UsersOnWordListsUpdateManyWithWhereWithoutUserInput = {
    where: UsersOnWordListsScalarWhereInput
    data: XOR<UsersOnWordListsUpdateManyMutationInput, UsersOnWordListsUncheckedUpdateManyWithoutUserInput>
  }

  ;export  type UsersOnWordListsScalarWhereInput = {
    AND?: UsersOnWordListsScalarWhereInput | UsersOnWordListsScalarWhereInput[]
    OR?: UsersOnWordListsScalarWhereInput[]
    NOT?: UsersOnWordListsScalarWhereInput | UsersOnWordListsScalarWhereInput[]
    userId?: UuidFilter<"UsersOnWordLists"> | string
    wordListId?: UuidFilter<"UsersOnWordLists"> | string
  }

  ;export  type UserCreateWithoutWordsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    meanings?: UsersOnMeaningsCreateNestedManyWithoutUserInput
    UsersOnWordLists?: UsersOnWordListsCreateNestedManyWithoutUserInput
  }

  ;export  type UserUncheckedCreateWithoutWordsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    meanings?: UsersOnMeaningsUncheckedCreateNestedManyWithoutUserInput
    UsersOnWordLists?: UsersOnWordListsUncheckedCreateNestedManyWithoutUserInput
  }

  ;export  type UserCreateOrConnectWithoutWordsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWordsInput, UserUncheckedCreateWithoutWordsInput>
  }

  ;export  type WordCreateWithoutUsersInput = {
    id?: string
    word: string
    transcription: string
    audio?: string | null
    source: $Enums.WordDefinitionSourceType
    createdAt?: Date | string
    updatedAt?: Date | string
    meanings?: MeaningCreateNestedManyWithoutWordInput
    WordsOnWordLists?: WordsOnWordListsCreateNestedManyWithoutWordInput
  }

  ;export  type WordUncheckedCreateWithoutUsersInput = {
    id?: string
    word: string
    transcription: string
    audio?: string | null
    source: $Enums.WordDefinitionSourceType
    createdAt?: Date | string
    updatedAt?: Date | string
    meanings?: MeaningUncheckedCreateNestedManyWithoutWordInput
    WordsOnWordLists?: WordsOnWordListsUncheckedCreateNestedManyWithoutWordInput
  }

  ;export  type WordCreateOrConnectWithoutUsersInput = {
    where: WordWhereUniqueInput
    create: XOR<WordCreateWithoutUsersInput, WordUncheckedCreateWithoutUsersInput>
  }

  ;export  type UserUpsertWithoutWordsInput = {
    update: XOR<UserUpdateWithoutWordsInput, UserUncheckedUpdateWithoutWordsInput>
    create: XOR<UserCreateWithoutWordsInput, UserUncheckedCreateWithoutWordsInput>
    where?: UserWhereInput
  }

  ;export  type UserUpdateToOneWithWhereWithoutWordsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWordsInput, UserUncheckedUpdateWithoutWordsInput>
  }

  ;export  type UserUpdateWithoutWordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meanings?: UsersOnMeaningsUpdateManyWithoutUserNestedInput
    UsersOnWordLists?: UsersOnWordListsUpdateManyWithoutUserNestedInput
  }

  ;export  type UserUncheckedUpdateWithoutWordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meanings?: UsersOnMeaningsUncheckedUpdateManyWithoutUserNestedInput
    UsersOnWordLists?: UsersOnWordListsUncheckedUpdateManyWithoutUserNestedInput
  }

  ;export  type WordUpsertWithoutUsersInput = {
    update: XOR<WordUpdateWithoutUsersInput, WordUncheckedUpdateWithoutUsersInput>
    create: XOR<WordCreateWithoutUsersInput, WordUncheckedCreateWithoutUsersInput>
    where?: WordWhereInput
  }

  ;export  type WordUpdateToOneWithWhereWithoutUsersInput = {
    where?: WordWhereInput
    data: XOR<WordUpdateWithoutUsersInput, WordUncheckedUpdateWithoutUsersInput>
  }

  ;export  type WordUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    word?: StringFieldUpdateOperationsInput | string
    transcription?: StringFieldUpdateOperationsInput | string
    audio?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumWordDefinitionSourceTypeFieldUpdateOperationsInput | $Enums.WordDefinitionSourceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meanings?: MeaningUpdateManyWithoutWordNestedInput
    WordsOnWordLists?: WordsOnWordListsUpdateManyWithoutWordNestedInput
  }

  ;export  type WordUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    word?: StringFieldUpdateOperationsInput | string
    transcription?: StringFieldUpdateOperationsInput | string
    audio?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumWordDefinitionSourceTypeFieldUpdateOperationsInput | $Enums.WordDefinitionSourceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meanings?: MeaningUncheckedUpdateManyWithoutWordNestedInput
    WordsOnWordLists?: WordsOnWordListsUncheckedUpdateManyWithoutWordNestedInput
  }

  ;export  type UserCreateWithoutMeaningsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    words?: UsersOnWordsCreateNestedManyWithoutUserInput
    UsersOnWordLists?: UsersOnWordListsCreateNestedManyWithoutUserInput
  }

  ;export  type UserUncheckedCreateWithoutMeaningsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    words?: UsersOnWordsUncheckedCreateNestedManyWithoutUserInput
    UsersOnWordLists?: UsersOnWordListsUncheckedCreateNestedManyWithoutUserInput
  }

  ;export  type UserCreateOrConnectWithoutMeaningsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMeaningsInput, UserUncheckedCreateWithoutMeaningsInput>
  }

  ;export  type MeaningCreateWithoutUsersInput = {
    id?: string
    term: string
    partOfSpeech: string
    meaning: string
    synonyms?: MeaningCreatesynonymsInput | string[]
    antonyms?: MeaningCreateantonymsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    sentences?: SentenceCreateNestedManyWithoutMeaningInput
    Word: WordCreateNestedOneWithoutMeaningsInput
  }

  ;export  type MeaningUncheckedCreateWithoutUsersInput = {
    id?: string
    term: string
    partOfSpeech: string
    meaning: string
    synonyms?: MeaningCreatesynonymsInput | string[]
    antonyms?: MeaningCreateantonymsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    wordId: string
    sentences?: SentenceUncheckedCreateNestedManyWithoutMeaningInput
  }

  ;export  type MeaningCreateOrConnectWithoutUsersInput = {
    where: MeaningWhereUniqueInput
    create: XOR<MeaningCreateWithoutUsersInput, MeaningUncheckedCreateWithoutUsersInput>
  }

  ;export  type UserUpsertWithoutMeaningsInput = {
    update: XOR<UserUpdateWithoutMeaningsInput, UserUncheckedUpdateWithoutMeaningsInput>
    create: XOR<UserCreateWithoutMeaningsInput, UserUncheckedCreateWithoutMeaningsInput>
    where?: UserWhereInput
  }

  ;export  type UserUpdateToOneWithWhereWithoutMeaningsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMeaningsInput, UserUncheckedUpdateWithoutMeaningsInput>
  }

  ;export  type UserUpdateWithoutMeaningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    words?: UsersOnWordsUpdateManyWithoutUserNestedInput
    UsersOnWordLists?: UsersOnWordListsUpdateManyWithoutUserNestedInput
  }

  ;export  type UserUncheckedUpdateWithoutMeaningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    words?: UsersOnWordsUncheckedUpdateManyWithoutUserNestedInput
    UsersOnWordLists?: UsersOnWordListsUncheckedUpdateManyWithoutUserNestedInput
  }

  ;export  type MeaningUpsertWithoutUsersInput = {
    update: XOR<MeaningUpdateWithoutUsersInput, MeaningUncheckedUpdateWithoutUsersInput>
    create: XOR<MeaningCreateWithoutUsersInput, MeaningUncheckedCreateWithoutUsersInput>
    where?: MeaningWhereInput
  }

  ;export  type MeaningUpdateToOneWithWhereWithoutUsersInput = {
    where?: MeaningWhereInput
    data: XOR<MeaningUpdateWithoutUsersInput, MeaningUncheckedUpdateWithoutUsersInput>
  }

  ;export  type MeaningUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    partOfSpeech?: StringFieldUpdateOperationsInput | string
    meaning?: StringFieldUpdateOperationsInput | string
    synonyms?: MeaningUpdatesynonymsInput | string[]
    antonyms?: MeaningUpdateantonymsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentences?: SentenceUpdateManyWithoutMeaningNestedInput
    Word?: WordUpdateOneRequiredWithoutMeaningsNestedInput
  }

  ;export  type MeaningUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    partOfSpeech?: StringFieldUpdateOperationsInput | string
    meaning?: StringFieldUpdateOperationsInput | string
    synonyms?: MeaningUpdatesynonymsInput | string[]
    antonyms?: MeaningUpdateantonymsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wordId?: StringFieldUpdateOperationsInput | string
    sentences?: SentenceUncheckedUpdateManyWithoutMeaningNestedInput
  }

  ;export  type WordsOnWordListsCreateWithoutWordListInput = {
    word: WordCreateNestedOneWithoutWordsOnWordListsInput
  }

  ;export  type WordsOnWordListsUncheckedCreateWithoutWordListInput = {
    wordId: string
  }

  ;export  type WordsOnWordListsCreateOrConnectWithoutWordListInput = {
    where: WordsOnWordListsWhereUniqueInput
    create: XOR<WordsOnWordListsCreateWithoutWordListInput, WordsOnWordListsUncheckedCreateWithoutWordListInput>
  }

  ;export  type WordsOnWordListsCreateManyWordListInputEnvelope = {
    data: WordsOnWordListsCreateManyWordListInput | WordsOnWordListsCreateManyWordListInput[]
    skipDuplicates?: boolean
  }

  ;export  type UsersOnWordListsCreateWithoutWordListInput = {
    user: UserCreateNestedOneWithoutUsersOnWordListsInput
  }

  ;export  type UsersOnWordListsUncheckedCreateWithoutWordListInput = {
    userId: string
  }

  ;export  type UsersOnWordListsCreateOrConnectWithoutWordListInput = {
    where: UsersOnWordListsWhereUniqueInput
    create: XOR<UsersOnWordListsCreateWithoutWordListInput, UsersOnWordListsUncheckedCreateWithoutWordListInput>
  }

  ;export  type UsersOnWordListsCreateManyWordListInputEnvelope = {
    data: UsersOnWordListsCreateManyWordListInput | UsersOnWordListsCreateManyWordListInput[]
    skipDuplicates?: boolean
  }

  ;export  type WordsOnWordListsUpsertWithWhereUniqueWithoutWordListInput = {
    where: WordsOnWordListsWhereUniqueInput
    update: XOR<WordsOnWordListsUpdateWithoutWordListInput, WordsOnWordListsUncheckedUpdateWithoutWordListInput>
    create: XOR<WordsOnWordListsCreateWithoutWordListInput, WordsOnWordListsUncheckedCreateWithoutWordListInput>
  }

  ;export  type WordsOnWordListsUpdateWithWhereUniqueWithoutWordListInput = {
    where: WordsOnWordListsWhereUniqueInput
    data: XOR<WordsOnWordListsUpdateWithoutWordListInput, WordsOnWordListsUncheckedUpdateWithoutWordListInput>
  }

  ;export  type WordsOnWordListsUpdateManyWithWhereWithoutWordListInput = {
    where: WordsOnWordListsScalarWhereInput
    data: XOR<WordsOnWordListsUpdateManyMutationInput, WordsOnWordListsUncheckedUpdateManyWithoutWordListInput>
  }

  ;export  type UsersOnWordListsUpsertWithWhereUniqueWithoutWordListInput = {
    where: UsersOnWordListsWhereUniqueInput
    update: XOR<UsersOnWordListsUpdateWithoutWordListInput, UsersOnWordListsUncheckedUpdateWithoutWordListInput>
    create: XOR<UsersOnWordListsCreateWithoutWordListInput, UsersOnWordListsUncheckedCreateWithoutWordListInput>
  }

  ;export  type UsersOnWordListsUpdateWithWhereUniqueWithoutWordListInput = {
    where: UsersOnWordListsWhereUniqueInput
    data: XOR<UsersOnWordListsUpdateWithoutWordListInput, UsersOnWordListsUncheckedUpdateWithoutWordListInput>
  }

  ;export  type UsersOnWordListsUpdateManyWithWhereWithoutWordListInput = {
    where: UsersOnWordListsScalarWhereInput
    data: XOR<UsersOnWordListsUpdateManyMutationInput, UsersOnWordListsUncheckedUpdateManyWithoutWordListInput>
  }

  ;export  type WordCreateWithoutWordsOnWordListsInput = {
    id?: string
    word: string
    transcription: string
    audio?: string | null
    source: $Enums.WordDefinitionSourceType
    createdAt?: Date | string
    updatedAt?: Date | string
    meanings?: MeaningCreateNestedManyWithoutWordInput
    users?: UsersOnWordsCreateNestedManyWithoutWordInput
  }

  ;export  type WordUncheckedCreateWithoutWordsOnWordListsInput = {
    id?: string
    word: string
    transcription: string
    audio?: string | null
    source: $Enums.WordDefinitionSourceType
    createdAt?: Date | string
    updatedAt?: Date | string
    meanings?: MeaningUncheckedCreateNestedManyWithoutWordInput
    users?: UsersOnWordsUncheckedCreateNestedManyWithoutWordInput
  }

  ;export  type WordCreateOrConnectWithoutWordsOnWordListsInput = {
    where: WordWhereUniqueInput
    create: XOR<WordCreateWithoutWordsOnWordListsInput, WordUncheckedCreateWithoutWordsOnWordListsInput>
  }

  ;export  type WordListCreateWithoutWordsInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UsersOnWordListsCreateNestedManyWithoutWordListInput
  }

  ;export  type WordListUncheckedCreateWithoutWordsInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UsersOnWordListsUncheckedCreateNestedManyWithoutWordListInput
  }

  ;export  type WordListCreateOrConnectWithoutWordsInput = {
    where: WordListWhereUniqueInput
    create: XOR<WordListCreateWithoutWordsInput, WordListUncheckedCreateWithoutWordsInput>
  }

  ;export  type WordUpsertWithoutWordsOnWordListsInput = {
    update: XOR<WordUpdateWithoutWordsOnWordListsInput, WordUncheckedUpdateWithoutWordsOnWordListsInput>
    create: XOR<WordCreateWithoutWordsOnWordListsInput, WordUncheckedCreateWithoutWordsOnWordListsInput>
    where?: WordWhereInput
  }

  ;export  type WordUpdateToOneWithWhereWithoutWordsOnWordListsInput = {
    where?: WordWhereInput
    data: XOR<WordUpdateWithoutWordsOnWordListsInput, WordUncheckedUpdateWithoutWordsOnWordListsInput>
  }

  ;export  type WordUpdateWithoutWordsOnWordListsInput = {
    id?: StringFieldUpdateOperationsInput | string
    word?: StringFieldUpdateOperationsInput | string
    transcription?: StringFieldUpdateOperationsInput | string
    audio?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumWordDefinitionSourceTypeFieldUpdateOperationsInput | $Enums.WordDefinitionSourceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meanings?: MeaningUpdateManyWithoutWordNestedInput
    users?: UsersOnWordsUpdateManyWithoutWordNestedInput
  }

  ;export  type WordUncheckedUpdateWithoutWordsOnWordListsInput = {
    id?: StringFieldUpdateOperationsInput | string
    word?: StringFieldUpdateOperationsInput | string
    transcription?: StringFieldUpdateOperationsInput | string
    audio?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumWordDefinitionSourceTypeFieldUpdateOperationsInput | $Enums.WordDefinitionSourceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meanings?: MeaningUncheckedUpdateManyWithoutWordNestedInput
    users?: UsersOnWordsUncheckedUpdateManyWithoutWordNestedInput
  }

  ;export  type WordListUpsertWithoutWordsInput = {
    update: XOR<WordListUpdateWithoutWordsInput, WordListUncheckedUpdateWithoutWordsInput>
    create: XOR<WordListCreateWithoutWordsInput, WordListUncheckedCreateWithoutWordsInput>
    where?: WordListWhereInput
  }

  ;export  type WordListUpdateToOneWithWhereWithoutWordsInput = {
    where?: WordListWhereInput
    data: XOR<WordListUpdateWithoutWordsInput, WordListUncheckedUpdateWithoutWordsInput>
  }

  ;export  type WordListUpdateWithoutWordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersOnWordListsUpdateManyWithoutWordListNestedInput
  }

  ;export  type WordListUncheckedUpdateWithoutWordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UsersOnWordListsUncheckedUpdateManyWithoutWordListNestedInput
  }

  ;export  type UserCreateWithoutUsersOnWordListsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    words?: UsersOnWordsCreateNestedManyWithoutUserInput
    meanings?: UsersOnMeaningsCreateNestedManyWithoutUserInput
  }

  ;export  type UserUncheckedCreateWithoutUsersOnWordListsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    words?: UsersOnWordsUncheckedCreateNestedManyWithoutUserInput
    meanings?: UsersOnMeaningsUncheckedCreateNestedManyWithoutUserInput
  }

  ;export  type UserCreateOrConnectWithoutUsersOnWordListsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUsersOnWordListsInput, UserUncheckedCreateWithoutUsersOnWordListsInput>
  }

  ;export  type WordListCreateWithoutUsersInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    words?: WordsOnWordListsCreateNestedManyWithoutWordListInput
  }

  ;export  type WordListUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    words?: WordsOnWordListsUncheckedCreateNestedManyWithoutWordListInput
  }

  ;export  type WordListCreateOrConnectWithoutUsersInput = {
    where: WordListWhereUniqueInput
    create: XOR<WordListCreateWithoutUsersInput, WordListUncheckedCreateWithoutUsersInput>
  }

  ;export  type UserUpsertWithoutUsersOnWordListsInput = {
    update: XOR<UserUpdateWithoutUsersOnWordListsInput, UserUncheckedUpdateWithoutUsersOnWordListsInput>
    create: XOR<UserCreateWithoutUsersOnWordListsInput, UserUncheckedCreateWithoutUsersOnWordListsInput>
    where?: UserWhereInput
  }

  ;export  type UserUpdateToOneWithWhereWithoutUsersOnWordListsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUsersOnWordListsInput, UserUncheckedUpdateWithoutUsersOnWordListsInput>
  }

  ;export  type UserUpdateWithoutUsersOnWordListsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    words?: UsersOnWordsUpdateManyWithoutUserNestedInput
    meanings?: UsersOnMeaningsUpdateManyWithoutUserNestedInput
  }

  ;export  type UserUncheckedUpdateWithoutUsersOnWordListsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    words?: UsersOnWordsUncheckedUpdateManyWithoutUserNestedInput
    meanings?: UsersOnMeaningsUncheckedUpdateManyWithoutUserNestedInput
  }

  ;export  type WordListUpsertWithoutUsersInput = {
    update: XOR<WordListUpdateWithoutUsersInput, WordListUncheckedUpdateWithoutUsersInput>
    create: XOR<WordListCreateWithoutUsersInput, WordListUncheckedCreateWithoutUsersInput>
    where?: WordListWhereInput
  }

  ;export  type WordListUpdateToOneWithWhereWithoutUsersInput = {
    where?: WordListWhereInput
    data: XOR<WordListUpdateWithoutUsersInput, WordListUncheckedUpdateWithoutUsersInput>
  }

  ;export  type WordListUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    words?: WordsOnWordListsUpdateManyWithoutWordListNestedInput
  }

  ;export  type WordListUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    words?: WordsOnWordListsUncheckedUpdateManyWithoutWordListNestedInput
  }

  ;export  type MeaningCreateManyWordInput = {
    id?: string
    term: string
    partOfSpeech: string
    meaning: string
    synonyms?: MeaningCreatesynonymsInput | string[]
    antonyms?: MeaningCreateantonymsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  ;export  type UsersOnWordsCreateManyWordInput = {
    userId: string
    level?: number
    lastTimeRecalledCorrectly: Date | string
    timeQuotient?: number
  }

  ;export  type WordsOnWordListsCreateManyWordInput = {
    wordListId: string
  }

  ;export  type MeaningUpdateWithoutWordInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    partOfSpeech?: StringFieldUpdateOperationsInput | string
    meaning?: StringFieldUpdateOperationsInput | string
    synonyms?: MeaningUpdatesynonymsInput | string[]
    antonyms?: MeaningUpdateantonymsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentences?: SentenceUpdateManyWithoutMeaningNestedInput
    users?: UsersOnMeaningsUpdateManyWithoutMeaningNestedInput
  }

  ;export  type MeaningUncheckedUpdateWithoutWordInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    partOfSpeech?: StringFieldUpdateOperationsInput | string
    meaning?: StringFieldUpdateOperationsInput | string
    synonyms?: MeaningUpdatesynonymsInput | string[]
    antonyms?: MeaningUpdateantonymsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sentences?: SentenceUncheckedUpdateManyWithoutMeaningNestedInput
    users?: UsersOnMeaningsUncheckedUpdateManyWithoutMeaningNestedInput
  }

  ;export  type MeaningUncheckedUpdateManyWithoutWordInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    partOfSpeech?: StringFieldUpdateOperationsInput | string
    meaning?: StringFieldUpdateOperationsInput | string
    synonyms?: MeaningUpdatesynonymsInput | string[]
    antonyms?: MeaningUpdateantonymsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  ;export  type UsersOnWordsUpdateWithoutWordInput = {
    level?: IntFieldUpdateOperationsInput | number
    lastTimeRecalledCorrectly?: DateTimeFieldUpdateOperationsInput | Date | string
    timeQuotient?: FloatFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutWordsNestedInput
  }

  ;export  type UsersOnWordsUncheckedUpdateWithoutWordInput = {
    userId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    lastTimeRecalledCorrectly?: DateTimeFieldUpdateOperationsInput | Date | string
    timeQuotient?: FloatFieldUpdateOperationsInput | number
  }

  ;export  type UsersOnWordsUncheckedUpdateManyWithoutWordInput = {
    userId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    lastTimeRecalledCorrectly?: DateTimeFieldUpdateOperationsInput | Date | string
    timeQuotient?: FloatFieldUpdateOperationsInput | number
  }

  ;export  type WordsOnWordListsUpdateWithoutWordInput = {
    wordList?: WordListUpdateOneRequiredWithoutWordsNestedInput
  }

  ;export  type WordsOnWordListsUncheckedUpdateWithoutWordInput = {
    wordListId?: StringFieldUpdateOperationsInput | string
  }

  ;export  type WordsOnWordListsUncheckedUpdateManyWithoutWordInput = {
    wordListId?: StringFieldUpdateOperationsInput | string
  }

  ;export  type SentenceCreateManyMeaningInput = {
    id?: string
    fullText: string
    wordToLearn: string
    options?: SentenceCreateoptionsInput | string[]
    source: $Enums.SentenceSourceType
    greatVotesCount?: number
    fineVotesCount?: number
    badVotesCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  ;export  type UsersOnMeaningsCreateManyMeaningInput = {
    userId: string
    relation?: $Enums.UserMeaningRelation
  }

  ;export  type SentenceUpdateWithoutMeaningInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullText?: StringFieldUpdateOperationsInput | string
    wordToLearn?: StringFieldUpdateOperationsInput | string
    options?: SentenceUpdateoptionsInput | string[]
    source?: EnumSentenceSourceTypeFieldUpdateOperationsInput | $Enums.SentenceSourceType
    greatVotesCount?: IntFieldUpdateOperationsInput | number
    fineVotesCount?: IntFieldUpdateOperationsInput | number
    badVotesCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  ;export  type SentenceUncheckedUpdateWithoutMeaningInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullText?: StringFieldUpdateOperationsInput | string
    wordToLearn?: StringFieldUpdateOperationsInput | string
    options?: SentenceUpdateoptionsInput | string[]
    source?: EnumSentenceSourceTypeFieldUpdateOperationsInput | $Enums.SentenceSourceType
    greatVotesCount?: IntFieldUpdateOperationsInput | number
    fineVotesCount?: IntFieldUpdateOperationsInput | number
    badVotesCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  ;export  type SentenceUncheckedUpdateManyWithoutMeaningInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullText?: StringFieldUpdateOperationsInput | string
    wordToLearn?: StringFieldUpdateOperationsInput | string
    options?: SentenceUpdateoptionsInput | string[]
    source?: EnumSentenceSourceTypeFieldUpdateOperationsInput | $Enums.SentenceSourceType
    greatVotesCount?: IntFieldUpdateOperationsInput | number
    fineVotesCount?: IntFieldUpdateOperationsInput | number
    badVotesCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  ;export  type UsersOnMeaningsUpdateWithoutMeaningInput = {
    relation?: EnumUserMeaningRelationFieldUpdateOperationsInput | $Enums.UserMeaningRelation
    user?: UserUpdateOneRequiredWithoutMeaningsNestedInput
  }

  ;export  type UsersOnMeaningsUncheckedUpdateWithoutMeaningInput = {
    userId?: StringFieldUpdateOperationsInput | string
    relation?: EnumUserMeaningRelationFieldUpdateOperationsInput | $Enums.UserMeaningRelation
  }

  ;export  type UsersOnMeaningsUncheckedUpdateManyWithoutMeaningInput = {
    userId?: StringFieldUpdateOperationsInput | string
    relation?: EnumUserMeaningRelationFieldUpdateOperationsInput | $Enums.UserMeaningRelation
  }

  ;export  type UsersOnWordsCreateManyUserInput = {
    wordId: string
    level?: number
    lastTimeRecalledCorrectly: Date | string
    timeQuotient?: number
  }

  ;export  type UsersOnMeaningsCreateManyUserInput = {
    meaningId: string
    relation?: $Enums.UserMeaningRelation
  }

  ;export  type UsersOnWordListsCreateManyUserInput = {
    wordListId: string
  }

  ;export  type UsersOnWordsUpdateWithoutUserInput = {
    level?: IntFieldUpdateOperationsInput | number
    lastTimeRecalledCorrectly?: DateTimeFieldUpdateOperationsInput | Date | string
    timeQuotient?: FloatFieldUpdateOperationsInput | number
    word?: WordUpdateOneRequiredWithoutUsersNestedInput
  }

  ;export  type UsersOnWordsUncheckedUpdateWithoutUserInput = {
    wordId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    lastTimeRecalledCorrectly?: DateTimeFieldUpdateOperationsInput | Date | string
    timeQuotient?: FloatFieldUpdateOperationsInput | number
  }

  ;export  type UsersOnWordsUncheckedUpdateManyWithoutUserInput = {
    wordId?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    lastTimeRecalledCorrectly?: DateTimeFieldUpdateOperationsInput | Date | string
    timeQuotient?: FloatFieldUpdateOperationsInput | number
  }

  ;export  type UsersOnMeaningsUpdateWithoutUserInput = {
    relation?: EnumUserMeaningRelationFieldUpdateOperationsInput | $Enums.UserMeaningRelation
    meaning?: MeaningUpdateOneRequiredWithoutUsersNestedInput
  }

  ;export  type UsersOnMeaningsUncheckedUpdateWithoutUserInput = {
    meaningId?: StringFieldUpdateOperationsInput | string
    relation?: EnumUserMeaningRelationFieldUpdateOperationsInput | $Enums.UserMeaningRelation
  }

  ;export  type UsersOnMeaningsUncheckedUpdateManyWithoutUserInput = {
    meaningId?: StringFieldUpdateOperationsInput | string
    relation?: EnumUserMeaningRelationFieldUpdateOperationsInput | $Enums.UserMeaningRelation
  }

  ;export  type UsersOnWordListsUpdateWithoutUserInput = {
    wordList?: WordListUpdateOneRequiredWithoutUsersNestedInput
  }

  ;export  type UsersOnWordListsUncheckedUpdateWithoutUserInput = {
    wordListId?: StringFieldUpdateOperationsInput | string
  }

  ;export  type UsersOnWordListsUncheckedUpdateManyWithoutUserInput = {
    wordListId?: StringFieldUpdateOperationsInput | string
  }

  ;export  type WordsOnWordListsCreateManyWordListInput = {
    wordId: string
  }

  ;export  type UsersOnWordListsCreateManyWordListInput = {
    userId: string
  }

  ;export  type WordsOnWordListsUpdateWithoutWordListInput = {
    word?: WordUpdateOneRequiredWithoutWordsOnWordListsNestedInput
  }

  ;export  type WordsOnWordListsUncheckedUpdateWithoutWordListInput = {
    wordId?: StringFieldUpdateOperationsInput | string
  }

  ;export  type WordsOnWordListsUncheckedUpdateManyWithoutWordListInput = {
    wordId?: StringFieldUpdateOperationsInput | string
  }

  ;export  type UsersOnWordListsUpdateWithoutWordListInput = {
    user?: UserUpdateOneRequiredWithoutUsersOnWordListsNestedInput
  }

  ;export  type UsersOnWordListsUncheckedUpdateWithoutWordListInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  ;export  type UsersOnWordListsUncheckedUpdateManyWithoutWordListInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use WordCountOutputTypeDefaultArgs instead
     */
    ;export  type WordCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WordCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MeaningCountOutputTypeDefaultArgs instead
     */
    ;export  type MeaningCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MeaningCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    ;export  type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WordListCountOutputTypeDefaultArgs instead
     */
    ;export  type WordListCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WordListCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WordDefaultArgs instead
     */
    ;export  type WordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MeaningDefaultArgs instead
     */
    ;export  type MeaningArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MeaningDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SentenceDefaultArgs instead
     */
    ;export  type SentenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SentenceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    ;export  type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsersOnWordsDefaultArgs instead
     */
    ;export  type UsersOnWordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersOnWordsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsersOnMeaningsDefaultArgs instead
     */
    ;export  type UsersOnMeaningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersOnMeaningsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WordListDefaultArgs instead
     */
    ;export  type WordListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WordListDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WordsOnWordListsDefaultArgs instead
     */
    ;export  type WordsOnWordListsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WordsOnWordListsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsersOnWordListsDefaultArgs instead
     */
    ;export  type UsersOnWordListsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersOnWordListsDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  ;export  type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  ;export  const dmmf: runtime.BaseDMMF
}
